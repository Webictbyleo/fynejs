{"version":3,"names":["ARRAY_ISARRAY","Array","isArray","WkMap","WeakMap","quMct","queueMicrotask","XToolFramework","_se","fn","_tr","s","trim","_Afrom","from","_AisArr","_Okeys","Object","keys","STR_STYLE","STR_DISPLAY","STR_NONE","STR_TAGNAME","STR_TEMPLATE","STR_LENGTH","STR_SOURCE","STR_READONLY","XTOOL_ENABLE_STATIC_DIRECTIVES","d","document","STR_CONTENTS","EV_DELEGATED","head","getElementById","style","createElement","id","textContent","appendChild","PFX","attrCache","Map","attrName","name","cached","get","value","set","TokenType","keywords","Set","visibility","WS_RE","NUM_RE","ReactiveComponent","attachToParent","parent","this","_parent","_addChild","_id","framework","_framework","element","_element","el","isBound","_isBound","v","isMounted","_isMounted","isDestroyed","_isDestroyed","_abortInvokerResources","byKind","_invokerResources","values","cleanup","clear","_cancelUserResources","_resolveBindingMeta","attributeName","elAny","propName","camel","replace","_","c","toUpperCase","toLowerCase","isBooleanProp","hasNonFunctionProp","isKnownBooleanAttr","_BA","_applyGenericBinding","meta","boolVal","setAttribute","removeAttribute","normalized","parts","k","push","length","join","String","getAttribute","_scanDirectiveAttrs","opts","prefixDash","prefixColon","namesOut","hasTextOrHtml","forName","names","getAttributeNames","i","startsWith","skipRootFor","setFrozen","on","_isFrozen","_sealedBeforeFreeze","_isSealed","_scheduleRender","_setSealed","_addDirective","directive","existing","_directives","constructor","def","_propUpdateActive","_runningPropEffect","_beforeMountCalled","_children","_computed","_propEffects","_computedCache","_computedDeps","_computedKeyStack","_isInComputedEvaluation","_isInMethodExecution","_allEffects","_hasComputed","_cleanupFunctions","_directiveAbort","AbortController","_targetIds","_targetSeq","_isMutationEnabled","_effectsToRun","_currentInvoker","_loopScopes","_expressionCache","_propertyDependencies","_activeEffect","_renderScheduled","_nextTickQueue","_changeFrameId","_renderFrameId","_initialClassSets","_rawData","_propParent","_callLifecycleHook","hookName","hook","_lifecycle","_safeExecute","_runWithGlobalInterception","_addCleanupFunction","wrapped","delete","add","_originalMethods","methods","_bindComputed","computed","propEffects","_bindPropEffects","mounted","unmounted","destroyed","updated","beforeMount","beforeUnmount","beforeDestroy","_cloneData","data","_data","_createReactiveData","_methods","_bindMethods","seen","has","arr","Date","getTime","RegExp","source","flags","m","forEach","st","proto","getPrototypeOf","prototype","out","create","key","callBeforeMount","_onDataChange","_property","self","cancelAnimationFrame","effectsToRun","directDeps","size","queue","visited","affectedComputed","queueIdx","base","compKey","baseDeps","entries","compEffects","requestAnimationFrame","effect","_bindFunctionMap","src","kind","makeNoArgCtxRunner","test","isNative","body","compiled","Function","ctx","_createMethodContext","call","original","args","prev","prevInv","newValue","oldValue","prevFlag","_getComputedValue","_trackDependency","getter","undefined","pop","e","propKey","activeEff","deps","includes","stackLen","current","_render","q","splice","fallback","error","bindToElement","completeBinding","getContext","includeComputed","_applyAsyncTemplateResolved","_parseDirectives","_getComponentByElement","_registerElement","child","_removeChild","index","indexOf","wrapper","thisArg","_createContextProxy","apply","destroy","directives","type","customDirective","unbind","abort","_runCleanupCallbacks","_propEffect","idx","_unregisterElement","_deepReactiveCache","_unregisterComponent","_initReactiveProps","expr","evalFn","update","obj","$props","_listen","event","handler","options","signal","addEventListener","capture","merged","_targetKey","target","toString","processElement","isRoot","hasAttribute","isComponentTag","directiveNames","_bindDirective","attr","_bindTextInterpolationsIn","_walkElements","nodes","childNodes","node","nodeType","Node","TEXT_NODE","textNode","raw","nodeValue","__x_ti_bound","segs","charCodeAt","run","start","close","text","slice","repeat","code","nextEsc","nextOpen","end","some","literalOut","map","evaluators","_createElementEvaluator","ei","dirInfo","expression","_createEffect","processor","firstElementChild","next","nextElementSibling","directiveName","isAtEvent","isShortBind","_bindAttributeDirective","_bindSimpleDirective","_bindIfDirective","_bindForDirective","_bindModelDirective","prefix","rest","split","suffix","mods","modifiers","reduce","acc","_getCustomDirective","_bindCustomDirective","_bindEventDirective","_bindIntersectDirective","phase","trimmed","runExpr","_compileHandler","payload","once","rootMargin","unobserve","_ioObserve","cb","entry","info","updateFn","directiveRef","_static","found","evaluator","originalDisplay","_prevShown","innerHTML","property","isCheckbox","isNumeric","isMultiSelect","tagName","multiple","getValueEvaluator","setValueEvaluator","_createEvaluator","checkboxValue","loopScope","_collectLoopScope","inferCheckboxValue","member","checked","sel","selected","setInputValue","t","currentData","parseFloat","getInputValue","currentVal","$value","placeholder","createComment","parentNode","insertBefore","__x_if_anchorParent","parentElement","branches","makeActualElement","content","cloneNode","isTemplate","first","firstEval","__x_tool_bound","originalNodes","sib","isElse","isElseIf","branch","active","orig","removeChild","mountBranch","b","__x_if_current","nextSibling","unmountBranch","eventName","passive","onlySelf","shouldPrevent","prevent","shouldStop","stop","isOutside","outside","deferExec","defer","keyAliasMap","enter","esc","escape","space","tab","backspace","del","arrowup","arrowdown","arrowleft","arrowright","home","pageup","pagedown","comboRequirements","ctrl","alt","shift","buttonMap","left","middle","right","touchSingle","single","touchMulti","multi","modifierKeys","allowedKeys","aliases","allowedButtons","btn","needKeyCheck","needButtonCheck","needTouchCheck","passesFilters","path","composedPath","tgt","contains","TouchEvent","tCount","touches","MouseEvent","button","KeyboardEvent","ctrlKey","altKey","shiftKey","metaKey","ev","createEventHandler","preventDefault","stopPropagation","canDelegate","_getConfig","delegate","remover","_registerDelegated","filter","comp","ownerDocument","isStatement","_extractArrowFunction","match","params","p","Boolean","isBlock","endsWith","paramsList","_compileArrowForEvent","mapArgs","arrow","thisCtx","compiledArrow","executor","result","_assertMutable","parentKey","method","Error","_wrapData","isArr","isSet","isMap","makeCollectionWrapper","beforeLen","beforeFirst","beforeLast","before","existed","proxy","Proxy","receiver","isCollection","Symbol","iterator","Reflect","bind","ownKeys","had","defineProperty","configurable","enumerable","writable","deleteProperty","ok","pc","eff","_includeComputed","specials","$log","$destroy","$forceUpdate","$addCleanupFunction","$nextTick","Promise","resolve","$el","$id","$isMounted","$isDestroyed","$isSealed","$isFrozen","$parent","$children","$seal","$mutate","prevMethod","propStr","_target","targetElement","component","mergedScope","gWindow","window","gDocument","cfg","sandbox","sandboxExpressions","allow","allowGlobals","ensureInvoker","registerResource","setup","inv","wrapTarget","prop","optSig","removeEventListener","querySelector","querySelectorAll","doc","win","defaultView","wrapObserverCtor","Orig","observerArgs","observe","disconnect","inst","$target","$event","_routerEnabled","location","_t","_navigate","href","setTimeout","ms","clearTimeout","setInterval","clearInterval","MutationObserver","ResizeObserver","IntersectionObserver","hasOwnProperty","_name","directiveInfo","baseSet","oc","className","cls","tokens","tk","classList","toggle","cssText","cssProp","setProperty","removeProperty","cur","anchorParent","__x_scope","scope","assign","_updateElementDirectives","root","force","Element","_updateElementDirectivesForVar","varName","re","_cleanupElementSubtree","toDelete","itemVar","indexVar","listCode","keyAttrName","keyExpr","templateToClone","contextAnchor","listEval","keyEval","BP_FOR","BP_KEY","BP_TEXT","BP_HTML","BP_DATA","hydrateFromBlueprint","cloneRoot","bp","instr","_resolveNodeByPath","j","dn","blueprint","walk","isRootEl","scan","dnames","n","concat","buildBlueprint","instances","createScope","item","idxOrKey","objIds","objSeq","keyFor","explicit","o","extractId","evalKeyExpr","dir","norm","list","tag","keysArr","oldByObjKey","oldPrimQueues","__x_for_key","ps","__x_primSig","newNodes","nodeKey","explicitKey","prevIdxRef","__x_idxRef","prevItemRef","__x_itemRef","needsUpdate","indexChanged","clone","initScope","oldIndexMap","seq","oldIdx","lisMask","lis","_computeLISMask","tailAnchor","anchor","ref","predecessors","tails","tailIdx","lo","hi","mid","lisLen","fill","dr","itemscope","formnovalidate","novalidate","default","readonly","_components","_byEl","_pending","_config","_customDirectives","_currentArrayInterceptorComp","_namedComponentDefs","_delegated","_delegatedRootBound","_prefetched","_currentDocURL","_scrollPositions","registerComponent","definition","_getRegisteredComponentDef","_preDiscoveryTasks","init","config","container","debug","staticDirectives","router","enabled","transitionName","_hpf","async","_applyPrefixInitialCSS","allSettled","_autoDiscoverComponents","_ensureRootObserver","_ensureDelegation","_installRouting","_normalizeDocURL","readyState","_inflightComponentLoads","_lazyComponentSources","loadComponents","sources","items","mode","tasks","it","_fetchAndEvalComponent","catch","then","inferredName","status","results","settled","failed","r","createComponent","_generateComponentId","dataAttr","_bindElementAsComponent","componentElements","reusable","_instantiateNamedComponent","_processPending","components","lastComponent","maybe","parentForEval","dataExpression","parentCtx","_parseDataExpression","initExpr","_finalizeComponentMount","xInitExpr","now","random","Math","substring","componentId","_log","_routerTransitionName","_isSameOrigin","u","URL","baseURI","origin","_isSameDocument","pathname","search","_scrollToHash","hash","decodeURIComponent","CSS","scrollIntoView","block","behavior","defaultPrevented","a","url","prefetchOnHover","preloadEventHandler","link","preload","targetURL","targetKey","err","curKey","x","scrollX","y","scrollY","html","_fetchHTML","history","pushState","_swapDocument","pos","scrollTo","after","message","res","fetch","credentials","cache","redirect","redirected","finalUrl","statusText","DOMParser","parseFromString","newHead","newTitle","applySwap","title","_morphElement","vt","startViewTransition","cont","getPropertyValue","transition","finished","_setAttributes","curAttrs","nextAttrs","val","_attributesEqual","aNames","bNames","_isDynamicNode","nodeName","replaceWith","firstChild","curChildren","nextChildren","max","cn","nn","toRemove","retries","baseDelay","isTypeScript","strings","str","attempt","isIdentifierStart","ch","ID_START_RE","isIdentifierPart","ID_PART_RE","isGenericStartEnd","startIndex","token","skipType","standalone","skipUntil","Whitespace","Punctuation","hasItem","isSimple","Keyword","Identifier","isComplex","depth","hasNewline","isContinued","Arrow","isObjectLiteralStart","prevToken","isWhitespace","isNumber","pred","context","collection","input","createToken","Comment","Number","quoteType","tplExprDepth","nestedDepth","tokenize","isObjectLiteral","isClassBody","braceDepth","lastIdentifier","lastKeyword","objectBraceDepth","outputString","tt","paramToken","pt","pv","gt","stripTypes","delay","pow","finally","_rootObserver","records","addedNodes","removedNodes","isConnected","stack","_onComponentSourceChanged","ro","childList","subtree","attributes","attributeFilter","_ensureIO","_ioObservers","_ioRegistry","io","reg","isIntersecting","visible","leave","onEnter","onLeave","existingMounted","parentComp","lazy","promise","par","props","dynamicPropObj","rawPropExpression","propExpr","initDef","baseData","makeData","compDef","originalChildren","replaceChildren","template","applyTemplate","tpl","slots","slotEl","matched","tplVal","append","nested","cancelBubble","h","captureEvents","bubbleEvents","l","w","XTool","FyneJS"],"sourceRoot":"./dist","sources":["dist/x-tool.js"],"sourcesContent":["\"use strict\";\nconst ARRAY_ISARRAY = Array.isArray;\nconst WkMap = WeakMap;\nconst quMct = queueMicrotask;\nconst FT_C = true;\nconst FT_TI = typeof __FEAT_TEXT_INTERP__ === 'boolean' ? __FEAT_TEXT_INTERP__ : true;\nconst _FT_DR = typeof __FEAT_DEEP_REACTIVE__ === 'boolean' ? __FEAT_DEEP_REACTIVE__ : true;\nconst FT_IFB = typeof __FEAT_IF_BRANCHES__ === 'boolean' ? __FEAT_IF_BRANCHES__ : true;\nconst XToolFramework = function () {\n    const _se = (fn) => { try {\n        fn();\n    }\n    catch { } };\n    const _tr = (s) => (s || '').trim();\n    const _Afrom = Array.from;\n    const _AisArr = ARRAY_ISARRAY;\n    const _Okeys = Object.keys;\n    const STR_STYLE = 'style';\n    const STR_DISPLAY = 'display';\n    const STR_NONE = 'none';\n    const STR_TAGNAME = 'tagName';\n    const STR_TEMPLATE = 'TEMPLATE';\n    const STR_LENGTH = 'length';\n    const STR_SOURCE = 'source';\n    const STR_READONLY = 'readonly';\n    let XTOOL_ENABLE_STATIC_DIRECTIVES = true;\n    const d = (typeof document !== 'undefined' ? document : null);\n    const STR_CONTENTS = 'contents';\n    const EV_CLICK = 'click', EV_INPUT = 'input', EV_CHANGE = 'change', EV_KEYDOWN = 'keydown', EV_KEYUP = 'keyup';\n    const EV_DELEGATED = [EV_CLICK, EV_INPUT, EV_CHANGE, EV_KEYDOWN, EV_KEYUP];\n    const LS_PENDING = 0, LS_LOADING = 1, LS_LOADED = 2, LS_ERROR = 3;\n    try {\n        if (d && d.head && !d.getElementById('x-tool-initial-css')) {\n            const style = d.createElement(STR_STYLE);\n            style.id = 'x-tool-initial-css';\n            style.textContent = '[x-show],[x-if],[x-else],[x-else-if],[x\\\\:show],[x\\\\:if],[x\\\\:else],[x\\\\:else-if]{display:none;}';\n            d.head.appendChild(style);\n        }\n    }\n    catch { }\n    let PFX = 'x';\n    let attrCache = new Map();\n    const attrName = (name) => {\n        const cached = attrCache.get(name);\n        if (cached)\n            return cached;\n        const value = `${PFX}-${name}`;\n        attrCache.set(name, value);\n        return value;\n    };\n    let TokenType;\n    (function (TokenType) {\n        TokenType[TokenType[\"Identifier\"] = 0] = \"Identifier\";\n        TokenType[TokenType[\"Keyword\"] = 1] = \"Keyword\";\n        TokenType[TokenType[\"Punctuation\"] = 2] = \"Punctuation\";\n        TokenType[TokenType[\"String\"] = 3] = \"String\";\n        TokenType[TokenType[\"Comment\"] = 4] = \"Comment\";\n        TokenType[TokenType[\"Whitespace\"] = 5] = \"Whitespace\";\n        TokenType[TokenType[\"Number\"] = 6] = \"Number\";\n        TokenType[TokenType[\"Arrow\"] = 7] = \"Arrow\";\n    })(TokenType || (TokenType = {}));\n    const keywords = new Set([\n        'as', 'interface', 'type', 'import', 'export', 'from', 'extends', 'implements',\n        'declare', 'namespace', 'module', 'any', 'unknown', 'never', 'void',\n        'number', 'string', 'boolean', 'symbol', 'bigint', 'object', 'enum', 'function'\n    ]);\n    const visibility = ['public', 'private', 'protected', 'static', 'abstract', 'readonly'];\n    const WS_RE = /\\s/;\n    const NUM_RE = /\\d/;\n    function stripTypes(source) {\n        const ID_START_RE = /[a-zA-Z_$]/;\n        const ID_PART_RE = /[a-zA-Z0-9_$]/;\n        function isIdentifierStart(ch) { return ID_START_RE.test(ch); }\n        function isIdentifierPart(ch) { return ID_PART_RE.test(ch); }\n        const isWhitespace = (ch) => WS_RE.test(ch);\n        const isNumber = (ch) => NUM_RE.test(ch);\n        function isGenericStartEnd(startIndex, tokens) {\n            const token = tokens[startIndex];\n            const ch = token.value == '<' ? '<' : '>';\n            return token.value == ch && (token.next?.value !== ch && token.prev?.value !== ch);\n        }\n        const skipUntil = (tokens, index, pred) => {\n            const context = { index, depth: 0 };\n            while (index < tokens.length && !pred(tokens[index], context))\n                index++;\n            return index;\n        };\n        const hasItem = (item, collection) => {\n            return collection.indexOf(item) !== -1;\n        };\n        function skipType(tokens, startIndex, standalone = true) {\n            let i = startIndex;\n            const ctx = {};\n            i = skipUntil(tokens, i, t => t.type !== TokenType.Whitespace && !(t.type === TokenType.Punctuation && hasItem(t.value, '|?&:')));\n            let isSimple = hasItem(tokens[i].type, [TokenType.Keyword, TokenType.Identifier]);\n            if (isSimple && tokens[i] && tokens[i].next?.type === TokenType.Punctuation && hasItem(tokens[i].next?.value, '<[{(')) {\n                i = skipUntil(tokens, i, t => t.type === TokenType.Punctuation);\n            }\n            let isComplex = tokens[i].type === TokenType.Punctuation && hasItem(tokens[i].value, '<[{(');\n            while (i < tokens.length) {\n                if (isComplex) {\n                    i = skipUntil(tokens, i, (t, ctx) => {\n                        if (t.type === TokenType.Punctuation) {\n                            if (hasItem(t.value, ']})>'))\n                                ctx.depth--;\n                            else if (hasItem(t.value, '<[{('))\n                                ctx.depth++;\n                        }\n                        return ctx.depth <= 0;\n                    });\n                    i++;\n                }\n                else {\n                    i = skipUntil(tokens, i, t => (TokenType.Whitespace === t.type && t.value !== \" \") || (t.type === TokenType.Punctuation && t.value !== '.'));\n                    if (standalone && tokens[i] && tokens[i].type === TokenType.Punctuation && hasItem(tokens[i].value, '<[{(')) {\n                        let hasNewline = false;\n                        skipUntil(tokens, i, t => { if (t.type === TokenType.Whitespace && hasItem(\"\\n\", t.value))\n                            hasNewline = true; return hasNewline || t.start >= tokens[i].start; });\n                        if (!hasNewline) {\n                            i = skipUntil(tokens, i, (t, ctx) => {\n                                if (t.type === TokenType.Punctuation) {\n                                    if (hasItem(t.value, ']})>'))\n                                        ctx.depth--;\n                                    else if (hasItem(t.value, '<[{('))\n                                        ctx.depth++;\n                                }\n                                return ctx.depth <= 0;\n                            });\n                            i++;\n                        }\n                    }\n                }\n                if (i >= tokens.length) {\n                    break;\n                }\n                if (tokens[i].type === TokenType.Whitespace && hasItem(\"\\n\", tokens[i].value) && tokens[i].prev?.next && tokens[i].prev?.next?.type === TokenType.Punctuation && hasItem(tokens[i].prev?.next?.value, '?&|:')) {\n                    i = skipUntil(tokens, i, t => t.type == TokenType.Punctuation);\n                }\n                if (tokens[i].type === TokenType.Whitespace)\n                    i = skipUntil(tokens, i, t => !t.value.startsWith(' '));\n                let cur = tokens[i];\n                const isContinued = cur.type === TokenType.Punctuation && hasItem(cur.value, \"?&|:\") || (cur.type === TokenType.Arrow && cur.prev?.value === ')');\n                if (!isContinued && (isSimple && cur.type === TokenType.Punctuation && (hasItem(cur.value, '(<[') || standalone && cur.value == '{'))) {\n                    isComplex = true;\n                    i = skipUntil(tokens, i, t => t.type !== TokenType.Whitespace);\n                    continue;\n                }\n                if (isContinued) {\n                    i++;\n                    i = skipUntil(tokens, i, t => !t.value.startsWith(' '));\n                }\n                ctx.isContinued = isContinued;\n                ctx.token = tokens[i];\n                if (!isContinued) {\n                    if (standalone) {\n                        i++;\n                    }\n                    break;\n                }\n                else {\n                    isSimple = hasItem(tokens[i].type, [TokenType.Keyword, TokenType.Identifier]);\n                    isComplex = tokens[i].type === TokenType.Punctuation && hasItem(tokens[i].value, '<[{(');\n                }\n            }\n            return i;\n        }\n        function tokenize(input) {\n            const tokens = [];\n            let pos = 0;\n            const length = input.length;\n            let prevToken;\n            const createToken = (type, start, end) => {\n                const token = {\n                    type,\n                    value: input.slice(start, end),\n                    start,\n                    end\n                };\n                if (prevToken) {\n                    token.prev = prevToken;\n                    prevToken.next = token;\n                }\n                if (type !== TokenType.Whitespace && type !== TokenType.Comment) {\n                    prevToken = token;\n                }\n                return token;\n            };\n            while (pos < length) {\n                const ch = input[pos];\n                let start = pos;\n                if (isWhitespace(ch)) {\n                    do {\n                        pos++;\n                    } while (pos < length && isWhitespace(input[pos]));\n                    tokens.push(createToken(TokenType.Whitespace, start, pos));\n                    continue;\n                }\n                if (isIdentifierStart(ch)) {\n                    pos++;\n                    while (pos < length && isIdentifierPart(input[pos]))\n                        pos++;\n                    const value = input.slice(start, pos);\n                    tokens.push(createToken(keywords.has(value) || hasItem(value, visibility) ? TokenType.Keyword : TokenType.Identifier, start, pos));\n                    continue;\n                }\n                if (isNumber(ch)) {\n                    do {\n                        pos++;\n                    } while (pos < length && isNumber(input[pos]));\n                    tokens.push(createToken(TokenType.Number, start, pos));\n                    continue;\n                }\n                if (ch === '\"' || ch === \"'\" || ch === '`') {\n                    const quoteType = ch;\n                    pos++;\n                    if (quoteType !== '`') {\n                        while (pos < length) {\n                            if (input[pos] === '\\\\')\n                                pos += 2;\n                            else if (input[pos] === quoteType) {\n                                pos++;\n                                break;\n                            }\n                            else\n                                pos++;\n                        }\n                        tokens.push(createToken(TokenType.String, start, pos));\n                        continue;\n                    }\n                    let tplExprDepth = 0;\n                    while (pos < length) {\n                        const c = input[pos];\n                        if (c === '\\\\') {\n                            pos += 2;\n                            continue;\n                        }\n                        if (c === '`' && tplExprDepth === 0) {\n                            pos++;\n                            break;\n                        }\n                        if (c === '$' && pos + 1 < length && input[pos + 1] === '{') {\n                            tplExprDepth++;\n                            pos += 2;\n                            while (pos < length && tplExprDepth > 0) {\n                                const e = input[pos];\n                                if (e === '\\\\') {\n                                    pos += 2;\n                                    continue;\n                                }\n                                if (e === '\"' || e === \"'\") {\n                                    const q = e;\n                                    pos++;\n                                    while (pos < length) {\n                                        if (input[pos] === '\\\\')\n                                            pos += 2;\n                                        else if (input[pos] === q) {\n                                            pos++;\n                                            break;\n                                        }\n                                        else\n                                            pos++;\n                                    }\n                                    continue;\n                                }\n                                if (e === '`') {\n                                    pos++;\n                                    let nestedDepth = 0;\n                                    while (pos < length) {\n                                        const n = input[pos];\n                                        if (n === '\\\\') {\n                                            pos += 2;\n                                            continue;\n                                        }\n                                        if (n === '`' && nestedDepth === 0) {\n                                            pos++;\n                                            break;\n                                        }\n                                        if (n === '$' && pos + 1 < length && input[pos + 1] === '{') {\n                                            nestedDepth++;\n                                            pos += 2;\n                                            continue;\n                                        }\n                                        if (n === '}' && nestedDepth > 0) {\n                                            nestedDepth--;\n                                            pos++;\n                                            continue;\n                                        }\n                                        pos++;\n                                    }\n                                    continue;\n                                }\n                                if (e === '{') {\n                                    tplExprDepth++;\n                                    pos++;\n                                    continue;\n                                }\n                                if (e === '}') {\n                                    tplExprDepth--;\n                                    pos++;\n                                    continue;\n                                }\n                                pos++;\n                            }\n                            continue;\n                        }\n                        pos++;\n                    }\n                    tokens.push(createToken(TokenType.String, start, pos));\n                    continue;\n                }\n                if (ch === '/' && pos + 1 < length) {\n                    if (input[pos + 1] === '/') {\n                        pos += 2;\n                        while (pos < length && input[pos] !== '\\n')\n                            pos++;\n                        tokens.push(createToken(TokenType.Comment, start, pos));\n                        continue;\n                    }\n                    if (input[pos + 1] === '*') {\n                        pos += 2;\n                        while (pos < length && !(input[pos] === '*' && input[pos + 1] === '/'))\n                            pos++;\n                        pos += 2;\n                        tokens.push(createToken(TokenType.Comment, start, pos));\n                        continue;\n                    }\n                }\n                if (ch === '=' && pos + 1 < length && input[pos + 1] === '>') {\n                    pos += 2;\n                    tokens.push(createToken(TokenType.Arrow, start, pos));\n                    continue;\n                }\n                tokens.push(createToken(TokenType.Punctuation, pos, ++pos));\n            }\n            return tokens;\n        }\n        function isObjectLiteralStart(tokens, index) {\n            let j = index - 1;\n            while (j >= 0 && tokens[j].type === TokenType.Whitespace)\n                j--;\n            if (j < 0)\n                return false;\n            const prevToken = tokens[j];\n            if (prevToken.type === TokenType.Arrow)\n                return false;\n            return (prevToken.type === TokenType.Identifier && prevToken.value === 'return') || prevToken.type === TokenType.Punctuation && (prevToken.value === '=' || prevToken.value === '(' || prevToken.value === '[' ||\n                prevToken.value === ',' || prevToken.value === ':' || prevToken.value === '?');\n        }\n        const tokens = tokenize(source);\n        let i = 0;\n        const context = {\n            isObjectLiteral: false,\n            isClassBody: false,\n            braceDepth: 0,\n            lastIdentifier: undefined,\n            lastKeyword: undefined\n        };\n        let objectBraceDepth = 0;\n        let outputString = '';\n        while (i < tokens.length) {\n            const token = tokens[i];\n            const tt = token.type;\n            const v = token.value;\n            if (tt === TokenType.Comment) {\n                i++;\n                continue;\n            }\n            if (tt === TokenType.Identifier) {\n                context.lastIdentifier = v;\n            }\n            if ((tt == TokenType.Identifier || tt == TokenType.Keyword) && ((token.next?.type === TokenType.Keyword && token.next.value == 'enum') || (v == 'enum'))) {\n                i = skipUntil(tokens, i, t => t.value == '}');\n                i++;\n                continue;\n            }\n            if (tt == TokenType.String || (tt != TokenType.Punctuation && TokenType.Whitespace != tt && TokenType.Keyword != tt)) {\n                i++;\n                outputString += v;\n                continue;\n            }\n            if (tt === TokenType.Whitespace) {\n                outputString += (v.includes('\\n') ? '\\n' : v);\n                i++;\n                continue;\n            }\n            if (context.lastIdentifier === 'class') {\n                context.isClassBody = true;\n            }\n            if (tt === TokenType.Punctuation && v === '{') {\n                context.braceDepth++;\n                if (isObjectLiteralStart(tokens, i)) {\n                    objectBraceDepth++;\n                    context.isObjectLiteral = true;\n                }\n                outputString += token.value;\n                i++;\n                continue;\n            }\n            if (tt === TokenType.Punctuation && v === '}') {\n                context.braceDepth--;\n                if (context.isObjectLiteral) {\n                    objectBraceDepth--;\n                    if (objectBraceDepth <= 0)\n                        context.isObjectLiteral = false;\n                }\n                if (context.braceDepth <= 0) {\n                    context.isClassBody = false;\n                }\n                outputString += token.value;\n                i++;\n                continue;\n            }\n            if (tt === TokenType.Keyword) {\n                if (!context.isObjectLiteral && v === 'import') {\n                    i = skipUntil(tokens, i, t => (t.type === TokenType.Keyword && t.value === 'from'));\n                    i = skipUntil(tokens, i, t => t.value === ';' || (t.type === TokenType.Whitespace && t.value.includes(\"\\n\")));\n                    if (i < tokens.length && tokens[i].value === ';')\n                        i++;\n                    continue;\n                }\n                if (v === 'as' && !isObjectLiteralStart(tokens, i)) {\n                    i++;\n                    i = skipUntil(tokens, i, t => t.type !== TokenType.Whitespace);\n                    i = skipType(tokens, i, false);\n                    continue;\n                }\n                if (v === 'export' && !context.isObjectLiteral && (String(token.next?.value + token.next?.next?.value).match(/(const\\s+)?(type|interface|enum|namespace|function)/))) {\n                    i++;\n                    i = skipUntil(tokens, i, t => t.type !== TokenType.Whitespace);\n                    continue;\n                }\n                if (v === 'function' && token.next?.type === TokenType.Identifier && token.next?.next?.type === TokenType.Punctuation && token.next?.next?.value === '(' && token.next?.next?.next && token.next?.next?.next?.type === TokenType.Identifier) {\n                    let j = i + 4;\n                    let depth = 1;\n                    while (j < tokens.length && depth > 0) {\n                        const t = tokens[j];\n                        if (t.type === TokenType.Punctuation) {\n                            if (t.value === '(')\n                                depth++;\n                            else if (t.value === ')')\n                                depth--;\n                        }\n                        j++;\n                    }\n                    j = skipUntil(tokens, j, t => t.type !== TokenType.Whitespace);\n                    if (j < tokens.length && tokens[j].type === TokenType.Punctuation && tokens[j].value === ':') {\n                        j++;\n                        j = skipType(tokens, j, false);\n                        j = skipUntil(tokens, j, t => t.type !== TokenType.Whitespace);\n                    }\n                    if (j < tokens.length && tokens[j].type === TokenType.Punctuation && tokens[j].value === ';') {\n                        i = j + 1;\n                        continue;\n                    }\n                }\n            }\n            if (!context.isObjectLiteral && tt === TokenType.Keyword && !isObjectLiteralStart(tokens, i) && hasItem(v, ['interface', 'type', 'declare', 'namespace', 'module'])) {\n                if (v === 'type')\n                    i = skipUntil(tokens, i, (t, ctx) => {\n                        if (t.type === TokenType.Punctuation) {\n                            if (hasItem(t.value, '<[({')) {\n                                ctx.depth++;\n                            }\n                            else if (hasItem(t.value, '>])}')) {\n                                ctx.depth--;\n                            }\n                        }\n                        return ctx.depth <= 0 && t.type === TokenType.Punctuation && t.value == '=';\n                    }), i++;\n                else\n                    i++;\n                i = skipType(tokens, i, true);\n                continue;\n            }\n            if (!context.isObjectLiteral && tt === TokenType.Keyword && v === 'implements' && token.next?.type !== TokenType.Punctuation && !context.isObjectLiteral) {\n                i++;\n                i = skipUntil(tokens, i, t => t.type === TokenType.Punctuation && t.value == '{');\n                continue;\n            }\n            if (tt === TokenType.Punctuation && v === '!' && token.prev?.type !== TokenType.Punctuation && token.prev?.type !== TokenType.Arrow) {\n                i++;\n                continue;\n            }\n            if (tt === TokenType.Punctuation && v === '(') {\n                if (token.next && token.next.value === '{') {\n                    outputString += token.value;\n                    i++;\n                    continue;\n                }\n                outputString += v;\n                i++;\n                let depth = 1;\n                while (i < tokens.length && depth > 0) {\n                    const paramToken = tokens[i];\n                    const pt = paramToken.type;\n                    const pv = paramToken.value;\n                    if (pt == TokenType.Punctuation && pv == '{' && isObjectLiteralStart(tokens, i)) {\n                        skipUntil(tokens, i, (t, ctx) => {\n                            if (t.type === TokenType.Punctuation) {\n                                if (t.value === '{')\n                                    ctx.depth++;\n                                else if (t.value === '}')\n                                    ctx.depth--;\n                            }\n                            outputString += tokens[i].value;\n                            i++;\n                            return ctx.depth <= 0;\n                        });\n                        continue;\n                    }\n                    if (pt == TokenType.Comment) {\n                        i++;\n                        continue;\n                    }\n                    if (pt === TokenType.Punctuation && pv === '(') {\n                        depth++;\n                    }\n                    else if (pt === TokenType.Punctuation && pv === ')') {\n                        depth--;\n                    }\n                    if (pt === TokenType.Keyword && hasItem(pv, visibility)) {\n                        i++;\n                        if (tokens[i].type === TokenType.Whitespace)\n                            i = skipUntil(tokens, i, t => t.type !== TokenType.Whitespace);\n                        continue;\n                    }\n                    if (pt === TokenType.Punctuation && pv === '!' && paramToken.prev && paramToken.prev.type === TokenType.Identifier) {\n                        i++;\n                        continue;\n                    }\n                    if (pt === TokenType.Punctuation && (pv === ':' || (pv == '?' && paramToken.next?.type == TokenType.Punctuation && paramToken.next?.value == ':')) || (TokenType.Keyword === pt && pv == 'as')) {\n                        i++;\n                        i = skipType(tokens, i, false);\n                        continue;\n                    }\n                    if (i < tokens.length && tokens[i].type === TokenType.Punctuation && tokens[i].value === ')') {\n                        outputString += tokens[i].value;\n                        i++;\n                        if (i < tokens.length && tokens[i].type === TokenType.Punctuation && tokens[i].value === ':') {\n                            i++;\n                            i = skipType(tokens, i, false);\n                        }\n                        continue;\n                    }\n                    outputString += paramToken.value;\n                    i++;\n                }\n                continue;\n            }\n            if (tt === TokenType.Punctuation && (v === ':' || (v === '?' && token.next?.type === TokenType.Punctuation && token.next.value == ':'))) {\n                if (token.prev && token.prev.type === TokenType.Identifier && !context.isObjectLiteral) {\n                    i++;\n                    i = skipType(tokens, i, false);\n                    continue;\n                }\n            }\n            if (tt === TokenType.Punctuation && v === '<' && isGenericStartEnd(i, tokens)) {\n                if (i < tokens.length) {\n                    let j = skipType(tokens, i, false);\n                    if (tokens[j] && tokens[j].type === TokenType.Whitespace)\n                        j = skipUntil(tokens, j, t => t.type !== TokenType.Whitespace);\n                    let gt = tokens[j];\n                    if (gt && gt.type == TokenType.Punctuation && '({['.indexOf(gt.value) !== -1) {\n                        i = j;\n                        continue;\n                    }\n                }\n            }\n            if (!context.isObjectLiteral && tt === TokenType.Keyword &&\n                hasItem(v, visibility)) {\n                i++;\n                continue;\n            }\n            if (tt === TokenType.Keyword) {\n                context.lastKeyword = token.value;\n            }\n            outputString += v;\n            i++;\n        }\n        return outputString;\n    }\n    class XToolFramework {\n        constructor() {\n            this._components = new Map();\n            this._byEl = new WkMap();\n            this._pending = [];\n            this._config = {};\n            this._customDirectives = new Map();\n            this._currentArrayInterceptorComp = null;\n            this._namedComponentDefs = new Map();\n            this._delegated = new WkMap();\n            this._delegatedRootBound = false;\n            this._prefetched = new Set();\n            this._currentDocURL = '';\n            this._scrollPositions = new Map();\n            this.directive = (name, directive) => {\n                if (name.startsWith(PFX + '-')) {\n                    throw new Error(`Custom directive names should not start with \"${PFX}-\". Use: XTool.directive(\"my-directive\", ...)`);\n                }\n                this._customDirectives.set(name, directive);\n                return this;\n            };\n            this.registerComponent = (definition) => {\n                if (!definition || !definition.name)\n                    throw new Error('registerComponent requires a name');\n                const name = definition.name.toLowerCase();\n                if (this._namedComponentDefs.has(name))\n                    return this;\n                this._namedComponentDefs.set(name, definition);\n                return this;\n            };\n            this._getRegisteredComponentDef = (name) => this._namedComponentDefs.get(name.toLowerCase());\n            this._getCustomDirective = (name) => this._customDirectives.get(name);\n            this._getConfig = () => this._config;\n            this._preDiscoveryTasks = [];\n            this.init = (config = {}) => {\n                const base = { container: 'body', debug: false, staticDirectives: true, router: { enabled: false, transitionName: 'route' } };\n                this._config = { ...base, ...config, router: { ...base.router, ...(config.router || {}) } };\n                if (typeof this._config.staticDirectives === 'boolean') {\n                    XTOOL_ENABLE_STATIC_DIRECTIVES = this._config.staticDirectives;\n                }\n                const _hpf = this._config.prefix;\n                if (_hpf && typeof _hpf === 'string' && _hpf[STR_LENGTH] > 0) {\n                    PFX = _hpf;\n                }\n                else {\n                    PFX = 'x';\n                }\n                attrCache.clear();\n                const start = async () => {\n                    this._applyPrefixInitialCSS();\n                    if (this._preDiscoveryTasks.length) {\n                        try {\n                            await Promise.allSettled(this._preDiscoveryTasks);\n                        }\n                        catch { }\n                    }\n                    this._autoDiscoverComponents();\n                    const c = d?.querySelector(this._config.container);\n                    if (c) {\n                        this._ensureRootObserver(c);\n                        if (this._config.delegate)\n                            this._ensureDelegation(c);\n                        if (this._routerEnabled())\n                            this._installRouting(c);\n                    }\n                    try {\n                        this._currentDocURL = this._normalizeDocURL(location.href);\n                    }\n                    catch { }\n                };\n                if (d && d.readyState === 'loading') {\n                    d.addEventListener('DOMContentLoaded', () => { void start(); });\n                }\n                else if (!d || d.readyState === 'complete' || d.readyState === 'interactive') {\n                    void start();\n                }\n                return this;\n            };\n            this._inflightComponentLoads = new Map();\n            this._lazyComponentSources = new Map();\n            this.loadComponents = (sources) => {\n                const items = sources.map(s => typeof s === 'string' ? { path: s, mode: 'preload', name: undefined } : { path: s.path, mode: (s.mode || 'preload'), name: s.name });\n                const tasks = [];\n                for (const it of items) {\n                    if (it.mode === 'defer') {\n                        const p = this._fetchAndEvalComponent(it.path).catch(() => { throw new Error('load failed'); });\n                        this._preDiscoveryTasks.push(p);\n                        tasks.push(p.then(() => { }));\n                    }\n                    else if (it.mode === 'lazy') {\n                        const inferredName = (it.name || it.path.split('/').pop() || '').replace(/\\.(mjs|js|ts)(\\?.*)?$/i, '').toLowerCase();\n                        if (inferredName && !this._lazyComponentSources.has(inferredName)) {\n                            this._lazyComponentSources.set(inferredName, { path: it.path, status: LS_PENDING });\n                        }\n                    }\n                    else {\n                        const p = this._fetchAndEvalComponent(it.path).catch(() => { throw new Error('load failed'); });\n                        tasks.push(p);\n                    }\n                }\n                return Promise.allSettled(tasks).then(results => {\n                    try {\n                        this._autoDiscoverComponents();\n                    }\n                    catch { }\n                    const settled = results.length;\n                    const failed = results.filter(r => r.status === 'rejected').length;\n                    return { settled, failed };\n                });\n            };\n            this.createComponent = (definition) => {\n                const component = new ReactiveComponent(this._generateComponentId(), definition, this);\n                this._components.set(component.id, component);\n                component.callBeforeMount();\n                return component;\n            };\n            this._autoDiscoverComponents = () => {\n                const container = d?.querySelector(this._config.container);\n                if (!container)\n                    return;\n                const dataAttr = attrName('data');\n                if (container.hasAttribute(dataAttr) && !this._getComponentByElement(container)) {\n                    this._bindElementAsComponent(container, undefined);\n                }\n                const componentElements = container.querySelectorAll(`[${dataAttr}]`);\n                for (const element of componentElements) {\n                    if (!this._getComponentByElement(element))\n                        this._bindElementAsComponent(element);\n                }\n                const reusable = container.querySelectorAll('component[source]');\n                for (const el of reusable) {\n                    if (!this._getComponentByElement(el))\n                        this._instantiateNamedComponent(el);\n                }\n                this._processPending();\n                if (componentElements[STR_LENGTH] === 0 && !this._getComponentByElement(container)) {\n                    const components = _Afrom(this._components.values());\n                    const lastComponent = components[components[STR_LENGTH] - 1];\n                    if (lastComponent && !lastComponent.isBound) {\n                        lastComponent.bindToElement(container);\n                    }\n                }\n            };\n            this._processPending = () => {\n                if (!this._pending[STR_LENGTH])\n                    return;\n                for (const p of this._pending) {\n                    let cur = p.el.parentElement;\n                    let parent;\n                    while (cur && !parent) {\n                        const maybe = this._getComponentByElement(cur);\n                        if (maybe)\n                            parent = maybe;\n                        else\n                            cur = cur.parentElement;\n                    }\n                    if (parent) {\n                        p.comp.attachToParent(parent);\n                    }\n                }\n                for (const p of this._pending)\n                    p.comp.completeBinding();\n                this._pending = [];\n            };\n            this._bindElementAsComponent = (element, parentForEval) => {\n                const dataExpression = element.getAttribute(attrName('data'));\n                let data = {};\n                if (dataExpression) {\n                    element.removeAttribute(attrName('data'));\n                    try {\n                        if (parentForEval) {\n                            let parentCtx = {};\n                            if (parentForEval._createMethodContext) {\n                                try {\n                                    parentCtx = parentForEval._createMethodContext();\n                                }\n                                catch { }\n                            }\n                            const evalFn = new Function('parent', `with(parent){ return (${dataExpression}) }`);\n                            data = evalFn(parentCtx);\n                        }\n                        else {\n                            data = this._parseDataExpression(dataExpression);\n                        }\n                        const hasOwnMethods = data.methods;\n                        data = hasOwnMethods ? { methods: data.methods, data: { ...data } } : { data: { ...data } };\n                        if (parentForEval) {\n                            data.data.$parent = parentForEval;\n                        }\n                    }\n                    catch (e) {\n                    }\n                }\n                const comp = this.createComponent(data);\n                const initExpr = element.getAttribute(attrName('init')) || undefined;\n                if (initExpr)\n                    element.removeAttribute(attrName('init'));\n                this._finalizeComponentMount(element, comp, { callBeforeMount: true, xInitExpr: initExpr });\n            };\n            this._generateComponentId = () => {\n                const now = Date.now();\n                const random = Math.random().toString(36).substring(2, 15);\n                const counter = (this._components.size + 1).toString(36);\n                return `component_${now}_${counter}_${random}`;\n            };\n            this._parseDataExpression = (expression) => {\n                try {\n                    return new Function('return ' + expression.trim())();\n                }\n                catch {\n                    return {};\n                }\n            };\n            this._unregisterComponent = (componentId) => { this._components.delete(componentId); };\n            this._log = (..._args) => { };\n            this._registerElement = (element, component) => {\n                this._byEl.set(element, component);\n            };\n            this._unregisterElement = (element) => { try {\n                this._byEl.delete(element);\n            }\n            catch { } };\n        }\n        _routerEnabled() { const c = this._config; return !!(c.router?.enabled); }\n        _routerTransitionName() { const c = this._config; return (c.router?.transitionName ?? 'route'); }\n        _isSameOrigin(href) {\n            try {\n                const u = new URL(href, d?.baseURI || location.href);\n                const cur = new URL(location.href);\n                return u.origin === cur.origin;\n            }\n            catch {\n                return false;\n            }\n        }\n        _isSameDocument(target) {\n            try {\n                const u = typeof target === 'string' ? new URL(target, d?.baseURI || location.href) : target;\n                const cur = new URL(location.href);\n                return (u.origin === cur.origin && u.pathname === cur.pathname && u.search === cur.search);\n            }\n            catch {\n                return false;\n            }\n        }\n        _normalizeDocURL(target) {\n            const u = typeof target === 'string' ? new URL(target, d?.baseURI || location.href) : target;\n            return `${u.origin}${u.pathname}${u.search}`;\n        }\n        _scrollToHash(hash) {\n            try {\n                if (!hash || hash === '#')\n                    return false;\n                const id = decodeURIComponent(hash.replace(/^#/, ''));\n                const el = d.getElementById(id) || d.querySelector(`[name=\"${CSS.escape(id)}\"]`);\n                if (el) {\n                    el.scrollIntoView({ block: 'start', 'behavior': 'instant' });\n                    return true;\n                }\n            }\n            catch { }\n            return false;\n        }\n        _installRouting(root) {\n            const self = this;\n            const preload = (href) => {\n                try {\n                    if (!self._isSameOrigin(href))\n                        return;\n                }\n                catch {\n                    return;\n                }\n                const u = new URL(href, location.href);\n                if (self._isSameDocument(u))\n                    return;\n                u.hash = '';\n                const url = u.toString();\n                if (self._prefetched.has(url))\n                    return;\n                const existing = d?.head?.querySelector(`link[rel=\"prefetch\"][href=\"${CSS.escape(url)}\"]`);\n                if (existing) {\n                    self._prefetched.add(url);\n                    return;\n                }\n                try {\n                    const link = d.createElement('link');\n                    link.setAttribute('rel', 'prefetch');\n                    link.setAttribute('as', 'document');\n                    link.setAttribute('href', url);\n                    d.head.appendChild(link);\n                    self._prefetched.add(url);\n                }\n                catch { }\n            };\n            const onClick = (e) => {\n                const ev = e;\n                if (ev.defaultPrevented || ev.metaKey || ev.ctrlKey || ev.shiftKey || ev.altKey)\n                    return;\n                let el = ev.target;\n                while (el && el !== root && el.tagName !== 'A')\n                    el = el.parentElement;\n                if (!el || el.tagName !== 'A' || el.hasAttribute('download'))\n                    return;\n                const a = el;\n                const href = a.getAttribute('href');\n                if (!href || href.startsWith('#'))\n                    return;\n                const target = a.getAttribute('target');\n                if (target && target.toLowerCase() === '_blank')\n                    return;\n                if (!self._isSameOrigin(href))\n                    return;\n                const url = new URL(href, location.href);\n                if (self._isSameDocument(url))\n                    return;\n                ev.preventDefault();\n                self._navigate(url.toString(), true, 'link').catch(() => { location.assign(url.toString()); });\n            };\n            root.addEventListener('click', onClick);\n            if (this._config.router?.prefetchOnHover) {\n                const preloadEventHandler = (e) => {\n                    const t = e.target;\n                    let el = t;\n                    while (el && el !== root && el.tagName !== 'A')\n                        el = el.parentElement;\n                    if (!el || el.tagName !== 'A' || el.hasAttribute('download'))\n                        return;\n                    const href = el.getAttribute('href');\n                    if (!href || href.startsWith('#'))\n                        return;\n                    preload(href);\n                };\n                root.addEventListener('mouseover', preloadEventHandler, { passive: true });\n                root.addEventListener('touchstart', preloadEventHandler, { passive: true });\n            }\n            window.addEventListener('popstate', () => { self._navigate(location.href, false, 'popstate').catch(() => { }); });\n        }\n        async _navigate(url, push, source = 'program') {\n            if (!this._routerEnabled())\n                return Promise.resolve();\n            if (!this._isSameOrigin(url)) {\n                location.assign(url);\n                return;\n            }\n            const targetURL = new URL(url);\n            const targetKey = this._normalizeDocURL(targetURL);\n            if (source !== 'popstate') {\n                if (this._isSameDocument(targetURL)) {\n                    location.href = url;\n                    return;\n                }\n            }\n            else {\n                if (this._currentDocURL && targetKey === this._currentDocURL) {\n                    this._scrollToHash(targetURL.hash);\n                    return;\n                }\n            }\n            const from = location.href;\n            try {\n                const res = await (this._config.router?.before?.(url, from, { source }));\n                if (res === false)\n                    return;\n            }\n            catch (err) {\n                try {\n                    this._config.router?.error?.(err, url, from);\n                }\n                catch { }\n                return;\n            }\n            const curKey = this._currentDocURL || this._normalizeDocURL(from);\n            this._scrollPositions.set(curKey, { x: window.scrollX || 0, y: window.scrollY || 0 });\n            try {\n                const html = await this._fetchHTML(url);\n                if (push)\n                    history.pushState({}, '', url);\n                await this._swapDocument(html);\n                this._currentDocURL = targetKey;\n                _se(() => {\n                    if (source === 'popstate') {\n                        const pos = this._scrollPositions.get(targetKey);\n                        if (pos)\n                            (window).scrollTo(pos.x, pos.y);\n                        else if (!this._scrollToHash(targetURL.hash))\n                            (window).scrollTo(0, 0);\n                    }\n                    else {\n                        if (!this._scrollToHash(targetURL.hash))\n                            (window).scrollTo(0, 0);\n                    }\n                });\n                try {\n                    await this._config.router?.after?.(url, from, { source });\n                }\n                catch { }\n            }\n            catch (err) {\n                if (err && (err.name === 'XToolRedirect' || err.message === 'XToolRedirect'))\n                    return;\n                _se(() => this._config.router?.error?.(err, url, from));\n                try {\n                    location.assign(url);\n                }\n                catch {\n                    _se(() => location.href = url);\n                }\n            }\n        }\n        async _fetchHTML(url) {\n            const res = await fetch(url, { credentials: 'same-origin', cache: 'default', redirect: 'follow' });\n            if (res.redirected) {\n                const finalUrl = res.url;\n                try {\n                    location.assign(finalUrl);\n                }\n                catch {\n                    _se(() => location.href = finalUrl);\n                }\n                const e = new Error('XToolRedirect');\n                e.name = 'XToolRedirect';\n                e.url = finalUrl;\n                throw e;\n            }\n            if (!res.ok)\n                throw new Error(res.status + ' ' + res.statusText);\n            return await res.text();\n        }\n        async _swapDocument(html) {\n            const parser = new DOMParser();\n            const doc = parser.parseFromString(html, 'text/html');\n            const newHead = doc.head;\n            const newTitle = newHead?.querySelector('title');\n            const applySwap = () => {\n                if (newTitle) {\n                    const t = newTitle.textContent || '';\n                    if (document.title !== t)\n                        document.title = t;\n                }\n                const sel = this._config.container || 'body';\n                const cur = d.querySelector(sel);\n                const next = doc.querySelector(sel);\n                if (cur && next) {\n                    this._morphElement(cur, next);\n                }\n                else if (next) {\n                    d.body.innerHTML = next.innerHTML;\n                }\n                else {\n                    d.body.innerHTML = doc.body.innerHTML;\n                }\n                this._byEl.delete(cur);\n                this._autoDiscoverComponents();\n                const c = d?.querySelector(this._config.container);\n                if (c) {\n                    this._ensureRootObserver(c);\n                    if (this._config.delegate)\n                        this._ensureDelegation(c);\n                }\n            };\n            const vt = (document).startViewTransition?.bind(document);\n            if (vt && this._getConfig().router?.transitionName) {\n                const sel = this._config.container || 'body';\n                const cont = d.querySelector(sel);\n                const prev = cont ? (cont.style.getPropertyValue('view-transition-name') || '') : '';\n                _se(() => { if (cont)\n                    cont.style.setProperty('view-transition-name', this._routerTransitionName()); });\n                try {\n                    const transition = vt(applySwap);\n                    await transition.finished;\n                }\n                finally {\n                    try {\n                        if (cont) {\n                            if (prev)\n                                cont.style.setProperty('view-transition-name', prev);\n                            else\n                                cont.style.removeProperty('view-transition-name');\n                        }\n                    }\n                    catch { }\n                }\n            }\n            else\n                applySwap();\n        }\n        _setAttributes(cur, next) {\n            const curAttrs = cur.getAttributeNames();\n            for (let i = 0; i < curAttrs.length; i++) {\n                const name = curAttrs[i];\n                if (!next.hasAttribute(name))\n                    cur.removeAttribute(name);\n            }\n            const nextAttrs = next.getAttributeNames();\n            for (let i = 0; i < nextAttrs.length; i++) {\n                const name = nextAttrs[i];\n                const val = next.getAttribute(name);\n                if (cur.getAttribute(name) !== val)\n                    cur.setAttribute(name, val);\n            }\n        }\n        _attributesEqual(a, b) {\n            const aNames = a.getAttributeNames();\n            const bNames = b.getAttributeNames();\n            if (aNames.length !== bNames.length)\n                return false;\n            const map = new Map();\n            for (let i = 0; i < aNames.length; i++) {\n                const n = aNames[i];\n                map.set(n, a.getAttribute(n));\n            }\n            for (let i = 0; i < bNames.length; i++) {\n                const n = bNames[i];\n                if (!map.has(n))\n                    return false;\n                if (map.get(n) !== b.getAttribute(n))\n                    return false;\n            }\n            return true;\n        }\n        _isDynamicNode(el) {\n            const tag = el.tagName;\n            if (tag === 'IFRAME' && el.hasAttribute('src'))\n                return true;\n            if (tag === 'COMPONENT' && el.hasAttribute('source'))\n                return true;\n            return false;\n        }\n        _morphElement(cur, next) {\n            if (cur.nodeName !== next.nodeName || this._isDynamicNode(next)) {\n                cur.replaceWith(next.cloneNode(true));\n                return;\n            }\n            this._setAttributes(cur, next);\n            if (!cur.firstChild && !next.firstChild)\n                return;\n            const curChildren = Array.from(cur.childNodes);\n            const nextChildren = Array.from(next.childNodes);\n            const max = nextChildren.length;\n            for (let i = 0; i < max; i++) {\n                const n = nextChildren[i];\n                const c = curChildren[i];\n                if (!c) {\n                    cur.appendChild(n.cloneNode(true));\n                    continue;\n                }\n                if (n.nodeType === c.nodeType) {\n                    if (n.nodeType === 3) {\n                        const a = c;\n                        const b = n;\n                        if (a.data !== b.data)\n                            a.data = b.data;\n                    }\n                    else if (n.nodeType === 1) {\n                        const cn = c;\n                        const nn = n;\n                        if (this._isDynamicNode(nn)) {\n                            try {\n                                cn.replaceWith(nn.cloneNode(true));\n                            }\n                            catch { }\n                        }\n                        else if (cn.nodeName === nn.nodeName && this._attributesEqual(cn, nn)) {\n                            this._morphElement(cn, nn);\n                        }\n                        else {\n                            try {\n                                cn.replaceWith(nn.cloneNode(true));\n                            }\n                            catch { }\n                        }\n                    }\n                    else {\n                        try {\n                            c.replaceWith(n.cloneNode(true));\n                        }\n                        catch { }\n                    }\n                }\n                else {\n                    try {\n                        c.replaceWith(n.cloneNode(true));\n                    }\n                    catch { }\n                }\n            }\n            if (curChildren.length > max) {\n                for (let i = curChildren.length - 1; i >= max; i--) {\n                    const toRemove = cur.childNodes[i];\n                    try {\n                        cur.removeChild(toRemove);\n                    }\n                    catch { }\n                }\n            }\n        }\n        _fetchAndEvalComponent(path, retries = 2, baseDelay = 300) {\n            const existing = this._inflightComponentLoads.get(path);\n            if (existing)\n                return existing;\n            const self = this;\n            const isTypeScript = /\\.ts?$/.test(new URL(path, d?.baseURI || location.href).pathname);\n            const html = (strings, ...values) => strings.reduce((acc, str, i) => acc + str + (i < values.length ? values[i] : ''), '') + `\\n`;\n            const attempt = (n) => {\n                return fetch(path, { cache: 'no-cache' }).then(res => {\n                    if (!res.ok)\n                        throw new Error(res.status + ' ' + res.statusText);\n                    return res.text();\n                }).then(code => {\n                    if (isTypeScript) {\n                        code = stripTypes(code);\n                    }\n                    const wrapped = code + `\\n//# sourceURL=${path}`;\n                    try {\n                        new Function('XTool', 'html', wrapped)(self, html);\n                    }\n                    catch (err) {\n                        console.error(`Error evaluating component script at ${path}:`, err);\n                    }\n                }).catch(err => {\n                    if (n >= retries)\n                        throw err;\n                    const delay = baseDelay * Math.pow(2, n);\n                    return new Promise(resolve => setTimeout(resolve, delay)).then(() => attempt(n + 1));\n                });\n            };\n            const p = attempt(0).finally(() => { this._inflightComponentLoads.delete(path); });\n            this._inflightComponentLoads.set(path, p);\n            return p;\n        }\n        _applyPrefixInitialCSS() {\n            if (!d)\n                return;\n            if (PFX === 'x')\n                return;\n            const id = `x-tool-initial-css-${PFX}`;\n            if (d.head && !d.getElementById(id)) {\n                const style = d.createElement(STR_STYLE);\n                style.id = id;\n                style.textContent = `[${PFX}-show],[${PFX}-if],[${PFX}-else],[${PFX}-else-if],[${PFX}\\\\:show],[${PFX}\\\\:if],[${PFX}\\\\:else],[${PFX}\\\\:else-if]{display:none;}`;\n                d.head.appendChild(style);\n            }\n        }\n        _ensureRootObserver(container) {\n            if (this._rootObserver || typeof MutationObserver === 'undefined')\n                return;\n            this._rootObserver = new MutationObserver(records => {\n                for (const r of records) {\n                    if (r.type === 'childList') {\n                        for (let i = 0; i < r.addedNodes.length; i++) {\n                            const n = r.addedNodes[i];\n                            if (n.nodeType !== 1)\n                                continue;\n                            const el = n;\n                            if (el[STR_TAGNAME] === 'COMPONENT') {\n                                const src = el.getAttribute(STR_SOURCE);\n                                if (src && !this._getComponentByElement(el))\n                                    this._instantiateNamedComponent(el);\n                            }\n                        }\n                        for (let i = 0; i < r.removedNodes.length; i++) {\n                            const n = r.removedNodes[i];\n                            if (n.nodeType !== 1)\n                                continue;\n                            const el = n;\n                            quMct(() => {\n                                if (el.isConnected)\n                                    return;\n                                const stack = [el];\n                                while (stack.length) {\n                                    const cur = stack.pop();\n                                    const comp = this._getComponentByElement(cur);\n                                    if (comp && !comp.isDestroyed) {\n                                        try {\n                                            comp.destroy();\n                                        }\n                                        catch { }\n                                    }\n                                    let child = cur.firstElementChild;\n                                    while (child) {\n                                        stack.push(child);\n                                        child = child.nextElementSibling;\n                                    }\n                                }\n                            });\n                        }\n                    }\n                    else if (r.type === 'attributes') {\n                        const target = r.target;\n                        if (target && target[STR_TAGNAME] === 'COMPONENT') {\n                            if (r.attributeName === STR_SOURCE) {\n                                this._onComponentSourceChanged(target);\n                            }\n                            else if (r.attributeName === STR_READONLY) {\n                                const comp = this._getComponentByElement(target);\n                                if (comp) {\n                                    try {\n                                        const ro = target.hasAttribute(STR_READONLY);\n                                        comp.setFrozen(!!ro);\n                                    }\n                                    catch { }\n                                }\n                            }\n                        }\n                    }\n                }\n                this._processPending();\n            });\n            this._rootObserver.observe(container, { childList: true, subtree: true, attributes: true, attributeFilter: [STR_SOURCE, STR_READONLY] });\n        }\n        _ensureIO(rootMargin) {\n            if (typeof IntersectionObserver === 'undefined')\n                return null;\n            if (!this._ioObservers)\n                this._ioObservers = new Map();\n            if (!this._ioRegistry)\n                this._ioRegistry = new WkMap();\n            const key = rootMargin || '0px';\n            let io = this._ioObservers.get(key);\n            if (io)\n                return io;\n            const handle = (entries) => {\n                for (const entry of entries) {\n                    const el = entry.target;\n                    const reg = this._ioRegistry.get(el);\n                    if (!reg)\n                        continue;\n                    const now = !!entry.isIntersecting;\n                    const before = !!reg.visible;\n                    reg.visible = now;\n                    if (now && (!before)) {\n                        const arr = reg.enter || [];\n                        for (let i = 0; i < arr.length; i++) {\n                            _se(() => arr[i].cb(entry, { phase: 'enter', visible: now, before }));\n                        }\n                        if (arr.length)\n                            reg.enter = arr.filter(a => !a.once);\n                    }\n                    else if (!now && before) {\n                        const arr = reg.leave || [];\n                        for (let i = 0; i < arr.length; i++) {\n                            _se(() => arr[i].cb(entry, { phase: 'leave', visible: now, before }));\n                        }\n                        if (arr.length)\n                            reg.leave = arr.filter(a => !a.once);\n                    }\n                }\n            };\n            io = new IntersectionObserver(handle, { root: null, rootMargin: key });\n            this._ioObservers.set(key, io);\n            return io;\n        }\n        _ioObserve(el, rootMargin, onEnter, onLeave) {\n            const io = this._ensureIO(rootMargin);\n            if (!io)\n                return () => { };\n            if (!this._ioRegistry)\n                this._ioRegistry = new WkMap();\n            let reg = this._ioRegistry.get(el);\n            if (!reg) {\n                reg = { rootMargin };\n                this._ioRegistry.set(el, reg);\n            }\n            if (onEnter && onEnter.cb) {\n                (reg.enter || (reg.enter = [])).push({ cb: onEnter.cb, once: !!onEnter.once });\n            }\n            if (onLeave && onLeave.cb) {\n                (reg.leave || (reg.leave = [])).push({ cb: onLeave.cb, once: !!onLeave.once });\n            }\n            _se(() => io.observe(el));\n            return () => { _se(() => io.unobserve(el)); };\n        }\n        _onComponentSourceChanged(el) {\n            const src = _tr(el.getAttribute('source'));\n            const existing = this._getComponentByElement(el);\n            if (!src) {\n                if (existing && !existing.isDestroyed) {\n                    try {\n                        existing.destroy();\n                    }\n                    catch { }\n                }\n                el.innerHTML = '';\n                return;\n            }\n            if (existing && !existing.isDestroyed) {\n                try {\n                    existing.destroy();\n                }\n                catch { }\n            }\n            el.innerHTML = '';\n            this._instantiateNamedComponent(el);\n        }\n        _finalizeComponentMount(el, comp, opts) {\n            comp.element = el;\n            if (opts?.callBeforeMount) {\n                _se(() => comp.callBeforeMount());\n            }\n            this._registerElement(comp.element, comp);\n            this._pending.push({ el, comp });\n            if (opts?.xInitExpr) {\n                const initExpr = opts.xInitExpr;\n                const existingMounted = comp._lifecycle?.mounted;\n                comp._lifecycle.mounted = function () {\n                    if (existingMounted) {\n                        _se(() => existingMounted.call(this));\n                    }\n                    const evaluator = new Function('ctx', 'with(ctx){' + initExpr + '} ');\n                    quMct(() => {\n                        if (comp.isDestroyed || !comp.element || !comp.element.isConnected)\n                            return;\n                        try {\n                            const ctx = comp._createMethodContext?.() || comp.getContext?.() || {};\n                            const result = evaluator(ctx);\n                            if (typeof result === 'function') {\n                                _se(() => result());\n                            }\n                        }\n                        catch { }\n                    });\n                };\n            }\n        }\n        _instantiateNamedComponent(el) {\n            const source = el.getAttribute('source');\n            if (!source)\n                return;\n            let def = this._getRegisteredComponentDef(source);\n            if (!def) {\n                const name = source.toLowerCase();\n                const lazy = this._lazyComponentSources?.get(name);\n                if (lazy) {\n                    if (lazy.status === LS_PENDING) {\n                        lazy.status = LS_LOADING;\n                        lazy.promise = this._fetchAndEvalComponent(lazy.path)\n                            .then(() => { lazy.status = LS_LOADED; })\n                            .catch(() => { lazy.status = LS_ERROR; });\n                    }\n                    lazy.promise?.then(() => { _se(() => { const again = this._getRegisteredComponentDef(source); if (again)\n                        this._instantiateNamedComponent(el); }); });\n                }\n                return;\n            }\n            let parentComp;\n            let par = el.parentElement;\n            while (par && !parentComp) {\n                const maybe = this._getComponentByElement(par);\n                if (maybe)\n                    parentComp = maybe;\n                else\n                    par = par.parentElement;\n            }\n            let props = null;\n            let dynamicPropObj = null;\n            let rawPropExpression = null;\n            if (!props)\n                props = {};\n            const propExpr = el.getAttribute(attrName('prop'));\n            if (propExpr) {\n                rawPropExpression = propExpr;\n                if (parentComp) {\n                    try {\n                        const fn = new Function('ctx', 'with(ctx){return (' + propExpr + ')}');\n                        const ctx = parentComp.getContext(true);\n                        dynamicPropObj = fn(ctx);\n                    }\n                    catch {\n                        dynamicPropObj = null;\n                    }\n                }\n                else {\n                    try {\n                        dynamicPropObj = new Function('return (' + propExpr + ')')();\n                    }\n                    catch {\n                        dynamicPropObj = null;\n                    }\n                }\n                if (dynamicPropObj && typeof dynamicPropObj === 'object')\n                    for (const k in dynamicPropObj)\n                        if (!(k in props))\n                            props[k] = String(dynamicPropObj[k]);\n                el.removeAttribute(attrName('prop'));\n            }\n            let baseData = {};\n            if (def.makeData) {\n                _se(() => { const result = def.makeData(props); if (result)\n                    baseData = result; });\n            }\n            if (def.data) {\n                for (const k in def.data) {\n                    baseData[k] = def.data[k];\n                }\n            }\n            for (const k in props) {\n                if (!(k in baseData))\n                    baseData[k] = props[k];\n            }\n            baseData.$props = props;\n            let initDef;\n            if (typeof def.init === 'function') {\n                try {\n                    const maybe = def.init(props);\n                    initDef = (maybe && typeof maybe === 'object') ? maybe : undefined;\n                }\n                catch {\n                    initDef = undefined;\n                }\n            }\n            const compDef = {\n                data: baseData,\n                methods: { ...(def.methods || {}), ...(initDef?.methods || {}) },\n                computed: { ...(def.computed || {}), ...(initDef?.computed || {}) },\n                propEffects: { ...(def.propEffects || {}), ...(initDef?.propEffects || {}) },\n                mounted: initDef?.mounted || def.mounted,\n                unmounted: initDef?.unmounted || def.unmounted,\n                beforeMount: initDef?.beforeMount || def.beforeMount,\n                beforeUnmount: initDef?.beforeUnmount || def.beforeUnmount,\n                updated: initDef?.updated || def.updated,\n                destroyed: initDef?.destroyed || def.destroyed,\n                beforeDestroy: initDef?.beforeDestroy || def.beforeDestroy\n            };\n            const comp = this.createComponent(compDef);\n            const originalChildren = Array.from(el.childNodes);\n            if (originalChildren.length)\n                el.replaceChildren();\n            if (def.template) {\n                const applyTemplate = (tpl) => {\n                    el.innerHTML = tpl;\n                    const slots = el.querySelectorAll('slot');\n                    if (slots.length) {\n                        for (const slotEl of slots) {\n                            const name = slotEl.getAttribute('name');\n                            const matched = name\n                                ? originalChildren.filter(n => n.nodeType === 1 && n.getAttribute('slot') === name)\n                                : originalChildren.filter(n => n.nodeType !== 1 || !n.hasAttribute('slot'));\n                            if (matched.length)\n                                slotEl.replaceWith(...matched);\n                        }\n                    }\n                };\n                const tplVal = def.template;\n                if (typeof tplVal === 'string') {\n                    applyTemplate(tplVal);\n                }\n                else if (typeof tplVal === 'function') {\n                    try {\n                        const res = tplVal();\n                        if (res && typeof res.then === 'function') {\n                            el.innerHTML = '';\n                            res.then(html => { applyTemplate(html || ''); _se(() => comp._applyAsyncTemplateResolved()); });\n                        }\n                        else {\n                            applyTemplate(String(res || ''));\n                        }\n                    }\n                    catch {\n                        el.innerHTML = '';\n                    }\n                }\n                else if (tplVal && typeof tplVal.then === 'function') {\n                    el.innerHTML = '';\n                    tplVal.then(html => { applyTemplate(html || ''); _se(() => comp._applyAsyncTemplateResolved()); });\n                }\n            }\n            else {\n                if (originalChildren.length)\n                    el.append(...originalChildren);\n            }\n            this._finalizeComponentMount(el, comp, { callBeforeMount: false });\n            try {\n                const nested = el.querySelectorAll(`[${attrName('data')}]`);\n                for (const node of nested) {\n                    if (!this._getComponentByElement(node))\n                        this._bindElementAsComponent(node, comp);\n                }\n            }\n            catch { }\n            if (rawPropExpression && parentComp) {\n                _se(() => comp._initReactiveProps(rawPropExpression, parentComp));\n            }\n            this._processPending();\n        }\n        _getComponentByElement(element) { return this._byEl.get(element); }\n        observe(_element) { }\n        _ensureDelegation(container) {\n            if (this._delegatedRootBound)\n                return;\n            const root = container;\n            const handler = (e) => {\n                let cur = e.target;\n                while (cur && cur !== root.parentElement) {\n                    if (e.cancelBubble)\n                        break;\n                    const map = this._delegated.get(cur);\n                    if (map) {\n                        const list = map.get(e.type);\n                        if (list && list.length) {\n                            for (const h of [...list]) {\n                                try {\n                                    if (h.comp && h.comp.isDestroyed) {\n                                        const i = list.indexOf(h);\n                                        if (i > -1)\n                                            list.splice(i, 1);\n                                        continue;\n                                    }\n                                    if (!h.filter || h.filter(e)) {\n                                        h.run(e);\n                                        if (h.once) {\n                                            const idx = list.indexOf(h);\n                                            if (idx > -1)\n                                                list.splice(idx, 1);\n                                        }\n                                    }\n                                }\n                                catch { }\n                            }\n                        }\n                    }\n                    cur = cur.parentElement;\n                }\n            };\n            const captureEvents = ['keydown', 'keyup'];\n            const bubbleEvents = ['click', 'input', 'change'];\n            for (const ev of captureEvents)\n                root.addEventListener(ev, handler, true);\n            for (const ev of bubbleEvents)\n                root.addEventListener(ev, handler, false);\n            this._delegatedRootBound = true;\n        }\n        _registerDelegated(element, event, entry) {\n            let map = this._delegated.get(element);\n            if (!map) {\n                map = new Map();\n                this._delegated.set(element, map);\n            }\n            let list = map.get(event);\n            if (!list) {\n                list = [];\n                map.set(event, list);\n            }\n            list.push(entry);\n            return () => {\n                try {\n                    const m = this._delegated.get(element);\n                    const l = m?.get(event);\n                    if (!l)\n                        return;\n                    const idx = l.indexOf(entry);\n                    if (idx > -1)\n                        l.splice(idx, 1);\n                }\n                catch { }\n            };\n        }\n    }\n    class ReactiveComponent {\n        attachToParent(parent) {\n            this._parent = parent;\n            parent._addChild(this);\n        }\n        get id() { return this._id; }\n        get framework() { return this._framework; }\n        get element() { return this._element; }\n        set element(el) { this._element = el; }\n        get isBound() { return this._isBound; }\n        set isBound(v) { this._isBound = v; }\n        get isMounted() { return this._isMounted; }\n        set isMounted(v) { this._isMounted = v; }\n        get isDestroyed() { return this._isDestroyed; }\n        set isDestroyed(v) { this._isDestroyed = v; }\n        _abortInvokerResources() {\n            for (const byKind of this._invokerResources.values()) {\n                for (const cleanup of byKind.values()) {\n                    _se(cleanup);\n                }\n            }\n            this._invokerResources.clear();\n        }\n        _cancelUserResources() {\n            this._abortInvokerResources();\n        }\n        _resolveBindingMeta(element, attributeName) {\n            const elAny = element;\n            let propName = attributeName in elAny ? attributeName : null;\n            if (!propName) {\n                const camel = attributeName.replace(/-([a-z])/g, (_, c) => c.toUpperCase());\n                propName = camel in elAny ? camel : (attributeName.toLowerCase() === 'readonly' && 'readOnly' in elAny ? 'readOnly' : null);\n            }\n            const isBooleanProp = !!(propName && typeof elAny[propName] === 'boolean');\n            const hasNonFunctionProp = !!(propName && typeof elAny[propName] !== 'function');\n            const isKnownBooleanAttr = !!ReactiveComponent._BA[attributeName.toLowerCase()];\n            return { elAny, propName, isBooleanProp, hasNonFunctionProp, isKnownBooleanAttr };\n        }\n        _applyGenericBinding(element, attributeName, value, meta) {\n            const { elAny, propName, isBooleanProp, hasNonFunctionProp, isKnownBooleanAttr } = meta;\n            if ((isBooleanProp && propName) || isKnownBooleanAttr) {\n                const boolVal = !!value;\n                if (propName && isBooleanProp)\n                    elAny[propName] = boolVal;\n                if (boolVal)\n                    element.setAttribute(attributeName, '');\n                else\n                    element.removeAttribute(attributeName);\n                return;\n            }\n            let normalized = null;\n            if (value && typeof value === 'object') {\n                const parts = [];\n                for (const k in value) {\n                    if (value[k])\n                        parts.push(k);\n                }\n                normalized = parts.length ? parts.join(' ') : null;\n            }\n            else if (value !== null && value !== undefined) {\n                normalized = String(value);\n            }\n            if (hasNonFunctionProp && propName) {\n                if (normalized !== null) {\n                    try {\n                        elAny[propName] = normalized;\n                    }\n                    catch {\n                        try {\n                            element.setAttribute(attributeName, normalized);\n                        }\n                        catch { }\n                    }\n                }\n                else {\n                    element.removeAttribute(attributeName);\n                }\n                return;\n            }\n            if (normalized !== null) {\n                const cur = element.getAttribute(attributeName);\n                if (cur !== normalized)\n                    element.setAttribute(attributeName, normalized);\n            }\n            else {\n                element.removeAttribute(attributeName);\n            }\n        }\n        _scanDirectiveAttrs(el, opts) {\n            const prefixDash = PFX + '-';\n            const prefixColon = PFX + ':';\n            const namesOut = [];\n            let hasTextOrHtml = false;\n            let forName = null;\n            const names = el.getAttributeNames();\n            for (let i = 0; i < names.length; i++) {\n                const name = names[i];\n                const isDir = name.startsWith(prefixDash) || name.startsWith(prefixColon) || name.startsWith('@');\n                if (!isDir)\n                    continue;\n                if (opts?.skipRootFor && name === attrName('for'))\n                    continue;\n                namesOut.push(name);\n                if (!hasTextOrHtml && (name === attrName('text') || name === attrName('html')))\n                    hasTextOrHtml = true;\n                if (!forName && name === attrName('for'))\n                    forName = name;\n            }\n            return { names: namesOut, hasTextOrHtml, forName };\n        }\n        setFrozen(on) {\n            if (on === this._isFrozen)\n                return;\n            this._isFrozen = on;\n            if (on) {\n                this._sealedBeforeFreeze = this._isSealed;\n                this._isSealed = true;\n                this._cancelUserResources();\n            }\n            else {\n                if (this._sealedBeforeFreeze !== null) {\n                    this._isSealed = this._sealedBeforeFreeze;\n                }\n                else {\n                    this._isSealed = false;\n                }\n                this._sealedBeforeFreeze = null;\n                try {\n                    this._scheduleRender();\n                }\n                catch { }\n            }\n        }\n        _setSealed(on) {\n            if (on === this._isSealed)\n                return;\n            this._isSealed = on;\n            if (on) {\n                this._cancelUserResources();\n            }\n        }\n        _addDirective(element, directive) {\n            const existing = this._directives.get(element) || [];\n            existing.push(directive);\n            this._directives.set(element, existing);\n        }\n        constructor(id, def, framework) {\n            this._propUpdateActive = false;\n            this._runningPropEffect = false;\n            this._element = null;\n            this._isBound = false;\n            this._isMounted = false;\n            this._isDestroyed = false;\n            this._beforeMountCalled = false;\n            this._children = [];\n            this._parent = null;\n            this._computed = {};\n            this._propEffects = {};\n            this._computedCache = new Map();\n            this._computedDeps = new Map();\n            this._computedKeyStack = [];\n            this._isInComputedEvaluation = false;\n            this._isInMethodExecution = false;\n            this._allEffects = new Set();\n            this._hasComputed = false;\n            this._directives = new Map();\n            this._cleanupFunctions = new Set();\n            this._directiveAbort = new AbortController();\n            this._invokerResources = new Map();\n            this._targetIds = new WkMap();\n            this._targetSeq = 0;\n            this._isSealed = false;\n            this._isFrozen = false;\n            this._sealedBeforeFreeze = null;\n            this._isMutationEnabled = true;\n            this._effectsToRun = new Set();\n            this._currentInvoker = null;\n            this._loopScopes = new WkMap();\n            this._expressionCache = new Map();\n            this._propertyDependencies = new Map();\n            this._activeEffect = null;\n            this._renderScheduled = false;\n            this._nextTickQueue = [];\n            this._changeFrameId = null;\n            this._renderFrameId = null;\n            this._initialClassSets = new WkMap();\n            this._rawData = {};\n            this._propParent = null;\n            this._callLifecycleHook = (hookName) => {\n                const hook = this._lifecycle[hookName];\n                if (typeof hook === 'function') {\n                    this._safeExecute(() => this._runWithGlobalInterception(hook, []));\n                }\n            };\n            this._addCleanupFunction = (fn) => {\n                if (typeof fn !== 'function')\n                    return undefined;\n                const wrapped = () => {\n                    try {\n                        fn();\n                    }\n                    catch { }\n                    this._cleanupFunctions.delete(wrapped);\n                };\n                this._cleanupFunctions.add(wrapped);\n                return () => { this._cleanupFunctions.delete(wrapped); };\n            };\n            this._id = id;\n            this._framework = framework;\n            this._originalMethods = def.methods || {};\n            this._computed = this._bindComputed(def.computed || {});\n            this._propEffects = def.propEffects || {};\n            if (this._propEffects && Object.keys(this._propEffects).length) {\n                this._propEffects = this._bindPropEffects();\n            }\n            this._hasComputed = !!(def.computed && Object.keys(def.computed).length);\n            this._lifecycle = {\n                mounted: def.mounted,\n                unmounted: def.unmounted || def.destroyed,\n                updated: def.updated,\n                beforeMount: def.beforeMount,\n                beforeUnmount: def.beforeUnmount || def.beforeDestroy\n            };\n            this._rawData = this._cloneData(def.data || {});\n            this._data = this._createReactiveData(this._rawData || {});\n            this._methods = this._bindMethods();\n        }\n        _cloneData(value, seen) {\n            if (value === null || typeof value !== 'object')\n                return value;\n            const s = seen || new WeakMap();\n            if (s.has(value))\n                return s.get(value);\n            if (ARRAY_ISARRAY(value)) {\n                const arr = [];\n                s.set(value, arr);\n                for (let i = 0; i < value.length; i++)\n                    arr[i] = this._cloneData(value[i], s);\n                return arr;\n            }\n            if (value instanceof Date)\n                return new Date(value.getTime());\n            if (value instanceof RegExp)\n                return new RegExp(value.source, value.flags);\n            if (typeof Map !== 'undefined' && value instanceof Map) {\n                const m = new Map();\n                s.set(value, m);\n                value.forEach((v, k) => { m.set(this._cloneData(k, s), this._cloneData(v, s)); });\n                return m;\n            }\n            if (typeof Set !== 'undefined' && value instanceof Set) {\n                const st = new Set();\n                s.set(value, st);\n                value.forEach(v => st.add(this._cloneData(v, s)));\n                return st;\n            }\n            const proto = Object.getPrototypeOf(value);\n            if (proto === Object.prototype || proto === null) {\n                const out = Object.create(proto);\n                s.set(value, out);\n                for (const key of Object.keys(value)) {\n                    out[key] = this._cloneData(value[key], s);\n                }\n                return out;\n            }\n            return value;\n        }\n        callBeforeMount() {\n            if (!this._beforeMountCalled) {\n                this._callLifecycleHook('beforeMount');\n                this._beforeMountCalled = true;\n            }\n        }\n        _onDataChange(_property) {\n            if (!this.isBound)\n                return;\n            const self = this;\n            if (self._changeFrameId != null) {\n                _se(() => cancelAnimationFrame(self._changeFrameId));\n                self._changeFrameId = null;\n            }\n            if (this._isMutationEnabled === false)\n                return;\n            const effectsToRun = self._effectsToRun;\n            const directDeps = self._propertyDependencies.get(_property);\n            if (directDeps) {\n                for (let i = 0; i < directDeps.length; i++)\n                    effectsToRun.add(directDeps[i]);\n            }\n            if (FT_C && self._computedDeps.size) {\n                const queue = [_property];\n                const visited = new Set();\n                const affectedComputed = new Set();\n                let queueIdx = 0;\n                while (queueIdx < queue.length) {\n                    const base = queue[queueIdx++];\n                    if (visited.has(base))\n                        continue;\n                    visited.add(base);\n                    for (const [compKey, baseDeps] of self._computedDeps.entries()) {\n                        if (baseDeps.has(base) && !affectedComputed.has(compKey)) {\n                            affectedComputed.add(compKey);\n                            queue.push(compKey);\n                        }\n                    }\n                }\n                for (const compKey of affectedComputed) {\n                    const compEffects = self._propertyDependencies.get(compKey);\n                    if (compEffects) {\n                        for (let i = 0; i < compEffects.length; i++)\n                            effectsToRun.add(compEffects[i]);\n                    }\n                    self._computedCache.delete(compKey);\n                }\n            }\n            self._changeFrameId = requestAnimationFrame(() => {\n                if (FT_C)\n                    self._computedCache.clear();\n                self._changeFrameId = null;\n                if (self.isDestroyed || self._isSealed)\n                    return;\n                for (const effect of effectsToRun)\n                    self._safeExecute(effect);\n                effectsToRun.clear();\n                if (!directDeps?.length && (self._hasComputed || !XTOOL_ENABLE_STATIC_DIRECTIVES)) {\n                    self._scheduleRender();\n                }\n                self._callLifecycleHook('updated');\n            });\n        }\n        _bindMethods() {\n            return this._bindFunctionMap(this._originalMethods, 'methods');\n        }\n        _bindComputed(src) {\n            return this._bindFunctionMap(src, 'computed');\n        }\n        _bindPropEffects() {\n            return this._bindFunctionMap(this._propEffects || {}, 'prop');\n        }\n        _bindFunctionMap(src, kind) {\n            const out = {};\n            const isNative = (fn) => /\\[native code\\]/.test(String(fn));\n            const makeNoArgCtxRunner = (fn) => {\n                try {\n                    if (!isNative(fn)) {\n                        let body = String(fn).trim();\n                        if (!/^function[\\s\\(]/.test(body) && !/^[\\w\\$_][\\w\\d\\$_]*\\s*=>/.test(body) && !/^\\(.*?\\)\\s*=>/.test(body)) {\n                            body = 'function ' + body;\n                        }\n                        const compiled = new Function('ctx', `with(ctx){ const f = (${body}); return f.apply(this, []); }`);\n                        return () => { const ctx = this._createMethodContext(); return compiled.call(ctx, ctx); };\n                    }\n                }\n                catch { }\n                return () => fn.call(this._createMethodContext());\n            };\n            for (const key in (src || {})) {\n                const original = src[key];\n                if (typeof original !== 'function')\n                    continue;\n                if (kind === 'computed') {\n                    out[key] = makeNoArgCtxRunner(original);\n                }\n                else if (kind === 'methods') {\n                    out[key] = (...args) => {\n                        const prev = this._isInMethodExecution;\n                        const prevInv = this._currentInvoker;\n                        this._isInMethodExecution = true;\n                        this._currentInvoker = key;\n                        try {\n                            return this._safeExecute(() => this._runWithGlobalInterception(original, args));\n                        }\n                        finally {\n                            this._isInMethodExecution = prev;\n                            this._currentInvoker = prevInv;\n                        }\n                    };\n                }\n                else {\n                    out[key] = (newValue, oldValue) => {\n                        const prevInv = this._currentInvoker;\n                        const prevFlag = this._runningPropEffect;\n                        this._currentInvoker = `prop:${key}`;\n                        this._runningPropEffect = true;\n                        try {\n                            return this._safeExecute(() => this._runWithGlobalInterception(original, [newValue, oldValue]));\n                        }\n                        finally {\n                            this._runningPropEffect = prevFlag;\n                            this._currentInvoker = prevInv;\n                        }\n                    };\n                }\n            }\n            return out;\n        }\n        _getComputedValue(key) {\n            if (!FT_C)\n                return undefined;\n            this._trackDependency(key);\n            if (this._computedCache.has(key))\n                return this._computedCache.get(key);\n            this._isInComputedEvaluation = true;\n            this._computedKeyStack.push(key);\n            this._computedDeps.set(key, new Set());\n            try {\n                const getter = this._computed[key];\n                const value = typeof getter === 'function' ? getter() : undefined;\n                this._computedKeyStack.pop();\n                this._isInComputedEvaluation = this._computedKeyStack.length > 0;\n                this._computedCache.set(key, value);\n                return value;\n            }\n            catch (e) {\n                this._computedKeyStack.pop();\n                this._isInComputedEvaluation = this._computedKeyStack.length > 0;\n                return undefined;\n            }\n        }\n        _trackDependency(propKey) {\n            const activeEff = this._activeEffect;\n            if (!activeEff)\n                return;\n            let deps = this._propertyDependencies.get(propKey);\n            if (!deps) {\n                deps = [];\n                this._propertyDependencies.set(propKey, deps);\n            }\n            if (!deps.includes(activeEff))\n                deps.push(activeEff);\n            const stackLen = this._computedKeyStack.length;\n            if (this._isInComputedEvaluation && stackLen) {\n                const current = this._computedKeyStack[stackLen - 1];\n                let s = this._computedDeps.get(current);\n                if (!s) {\n                    s = new Set();\n                    this._computedDeps.set(current, s);\n                }\n                s.add(propKey);\n            }\n        }\n        _scheduleRender() {\n            if (this._isSealed || this._isFrozen || this._isDestroyed || this._renderScheduled)\n                return;\n            this._renderScheduled = true;\n            requestAnimationFrame(() => {\n                this._renderFrameId = null;\n                this._renderScheduled = false;\n                if (this._isDestroyed || this._isSealed) {\n                    if (this._nextTickQueue?.length)\n                        this._nextTickQueue.length = 0;\n                    return;\n                }\n                this._render();\n                if (this._nextTickQueue?.length) {\n                    const q = this._nextTickQueue.splice(0);\n                    for (const fn of q) {\n                        _se(fn);\n                    }\n                }\n            });\n        }\n        _safeExecute(fn, fallback) {\n            try {\n                return fn();\n            }\n            catch (error) {\n                console.error(error);\n                return fallback;\n            }\n        }\n        bindToElement(element) {\n            if (this._isBound)\n                return;\n            this._element = element;\n            if (!this._beforeMountCalled) {\n                this.callBeforeMount();\n            }\n            this.completeBinding();\n        }\n        getContext(includeComputed = true) {\n            return this._createMethodContext(includeComputed);\n        }\n        _applyAsyncTemplateResolved() {\n            if (!this._element)\n                return;\n            try {\n                this._parseDirectives(this._element);\n            }\n            catch { }\n            this._scheduleRender();\n        }\n        completeBinding() {\n            if (this._isBound || !this._element)\n                return;\n            if (!this._framework._getComponentByElement(this._element))\n                this._framework._registerElement(this._element, this);\n            this._isBound = true;\n            this._isMounted = true;\n            this._parseDirectives(this._element);\n            this._render();\n            this._callLifecycleHook('mounted');\n        }\n        _addChild(child) {\n            if (!this._children.includes(child)) {\n                this._children.push(child);\n            }\n        }\n        _removeChild(child) {\n            const index = this._children.indexOf(child);\n            if (index > -1) {\n                this._children.splice(index, 1);\n            }\n        }\n        _runWithGlobalInterception(fn, args) {\n            try {\n                const src = String(fn);\n                if (!/\\[native code\\]/.test(src)) {\n                    let body = src.trim();\n                    if (!/^function[\\s\\(]/.test(body) && !/^[\\w\\$_][\\w\\d\\$_]*\\s*=>/.test(body) && !/^\\(.*?\\)\\s*=>/.test(body)) {\n                        body = 'function ' + body;\n                    }\n                    const trySrc = 'with(ctx){ const f = (' + body + '); return f.apply(thisArg, argsArray); }';\n                    const wrapper = new Function('thisArg', 'argsArray', 'ctx', trySrc);\n                    const thisArg = this._createMethodContext();\n                    return wrapper.call(thisArg, thisArg, args, this._createContextProxy(undefined, undefined));\n                }\n            }\n            catch {\n            }\n            return fn.apply(this._createMethodContext(), args);\n        }\n        destroy() {\n            const self = this;\n            if (self._isDestroyed)\n                return;\n            self._callLifecycleHook('beforeUnmount');\n            for (const child of self._children) {\n                if (!child.isDestroyed)\n                    child.destroy();\n            }\n            if (self._parent) {\n                self._parent._removeChild(self);\n            }\n            for (const [element, directives] of self._directives) {\n                for (const directive of directives) {\n                    if (directive.type === 'custom' && directive.customDirective?.unbind) {\n                        _se(() => directive.customDirective.unbind(element, self));\n                    }\n                }\n            }\n            self._directives.clear();\n            try {\n                self._directiveAbort.abort();\n            }\n            catch { }\n            self._directiveAbort = new AbortController();\n            self._abortInvokerResources();\n            self._runCleanupCallbacks();\n            self._computedCache.clear();\n            self._expressionCache.clear();\n            self._propertyDependencies.clear();\n            if (self._propParent && self._propEffect) {\n                for (const deps of self._propParent._propertyDependencies.values()) {\n                    const idx = deps.indexOf(self._propEffect);\n                    if (idx > -1)\n                        deps.splice(idx, 1);\n                }\n            }\n            if (self._element)\n                self._framework._unregisterElement(self._element);\n            if (self._changeFrameId != null) {\n                _se(() => cancelAnimationFrame(self._changeFrameId));\n                self._changeFrameId = null;\n            }\n            if (self._renderFrameId != null) {\n                _se(() => cancelAnimationFrame(self._renderFrameId));\n                self._renderFrameId = null;\n            }\n            self._callLifecycleHook('unmounted');\n            self._isDestroyed = true;\n            self._isMounted = false;\n            self._isBound = false;\n            self._children = [];\n            self._parent = null;\n            self._deepReactiveCache = new WkMap;\n            self._effectsToRun.clear();\n            self._element = null;\n            quMct(() => self._framework._unregisterComponent(self._id));\n            self._data = {};\n            self._rawData = {};\n            self._methods = {};\n            self._computed = {};\n            self._propEffects = {};\n            self._activeEffect = null;\n        }\n        _initReactiveProps(expr, parent) {\n            if (!expr || !parent)\n                return;\n            this._propParent = parent;\n            let evalFn;\n            try {\n                evalFn = new Function('ctx', 'with(ctx){return (' + expr + ')}');\n            }\n            catch {\n                return;\n            }\n            const update = () => {\n                parent._activeEffect = update;\n                let obj;\n                try {\n                    const ctx = parent.getContext(true);\n                    obj = evalFn(ctx);\n                }\n                catch {\n                    obj = null;\n                }\n                parent._activeEffect = null;\n                if (obj && typeof obj === 'object') {\n                    this._data.$props = this._data.$props || {};\n                    this._propUpdateActive = true;\n                    for (const k in obj) {\n                        const v = obj[k];\n                        if (this._data[k] !== v)\n                            this._data[k] = v;\n                    }\n                    this._propUpdateActive = false;\n                }\n            };\n            this._propEffect = update;\n            update();\n        }\n        _runCleanupCallbacks() {\n            for (const fn of this._cleanupFunctions) {\n                _se(fn);\n            }\n            this._cleanupFunctions.clear();\n        }\n        _listen(element, event, handler, options) {\n            const signal = this._directiveAbort.signal;\n            if (typeof options === 'boolean') {\n                element.addEventListener(event, handler, { capture: options, signal });\n            }\n            else if (options) {\n                const merged = options.signal && options.signal !== signal\n                    ? options\n                    : { ...options, signal };\n                element.addEventListener(event, handler, merged);\n            }\n            else {\n                element.addEventListener(event, handler, { signal });\n            }\n        }\n        _targetKey(target) {\n            let id = this._targetIds.get(target);\n            if (!id) {\n                id = (++this._targetSeq).toString(36);\n                this._targetIds.set(target, id);\n            }\n            return id;\n        }\n        _parseDirectives(element) {\n            const self = this;\n            let processedElements = 0;\n            const processElement = (el, isRoot = false) => {\n                if (!isRoot && (el.hasAttribute(attrName('data')) || this._framework._getComponentByElement(el))) {\n                    return false;\n                }\n                const isComponentTag = el[STR_TAGNAME] === 'COMPONENT';\n                const { names: directiveNames, hasTextOrHtml, forName } = self._scanDirectiveAttrs(el);\n                if (directiveNames.length > 0) {\n                    processedElements++;\n                    if (forName) {\n                        self._bindDirective(el, forName, el.getAttribute(forName) || '');\n                        return false;\n                    }\n                    for (const attr of directiveNames) {\n                        self._bindDirective(el, attr, el.getAttribute(attr) || '');\n                    }\n                }\n                if (FT_TI && !hasTextOrHtml)\n                    self._bindTextInterpolationsIn(el);\n                return isRoot || !isComponentTag;\n            };\n            processElement(element, true);\n            self._walkElements(element, processElement);\n        }\n        _bindTextInterpolationsIn(el) {\n            const nodes = Array.from(el.childNodes);\n            for (const node of nodes) {\n                if (node.nodeType !== Node.TEXT_NODE)\n                    continue;\n                const textNode = node;\n                const raw = textNode.nodeValue || '';\n                if (textNode.__x_ti_bound || raw.indexOf('{{') === -1)\n                    continue;\n                const segs = [];\n                let i = 0;\n                while (i < raw.length) {\n                    const ch = raw.charCodeAt(i);\n                    if (ch === 92) {\n                        let run = 0;\n                        const start = i;\n                        while (i < raw.length && raw.charCodeAt(i) === 92) {\n                            run++;\n                            i++;\n                        }\n                        if (raw.startsWith('{{', i)) {\n                            const close = raw.indexOf('}}', i + 2);\n                            if (close === -1) {\n                                segs.push({ type: 'lit', text: raw.slice(start) });\n                                break;\n                            }\n                            if (run > 1)\n                                segs.push({ type: 'lit', text: '\\\\'.repeat(run - 1) });\n                            segs.push({ type: 'lit', text: raw.slice(i, close + 2) });\n                            i = close + 2;\n                            continue;\n                        }\n                        segs.push({ type: 'lit', text: raw.slice(start, i) });\n                        continue;\n                    }\n                    if (raw.startsWith('{{', i)) {\n                        const close = raw.indexOf('}}', i + 2);\n                        if (close === -1) {\n                            segs.push({ type: 'lit', text: raw.slice(i) });\n                            break;\n                        }\n                        const expr = raw.slice(i + 2, close).trim();\n                        if (expr.length === 0)\n                            segs.push({ type: 'lit', text: '{{}}' });\n                        else\n                            segs.push({ type: 'expr', code: expr });\n                        i = close + 2;\n                        continue;\n                    }\n                    const nextEsc = raw.indexOf('\\\\', i);\n                    const nextOpen = raw.indexOf('{{', i);\n                    let end = raw.length;\n                    if (nextEsc !== -1 && nextEsc < end)\n                        end = nextEsc;\n                    if (nextOpen !== -1 && nextOpen < end)\n                        end = nextOpen;\n                    segs.push({ type: 'lit', text: raw.slice(i, end) });\n                    i = end;\n                }\n                const hasExpr = segs.some(s => s.type === 'expr');\n                if (!hasExpr) {\n                    textNode.__x_ti_bound = true;\n                    const literalOut = segs.map(s => s.text || '').join('');\n                    if (textNode.textContent !== literalOut)\n                        textNode.textContent = literalOut;\n                    continue;\n                }\n                const evaluators = [];\n                for (const s of segs)\n                    if (s.type === 'expr')\n                        evaluators.push(this._createElementEvaluator(s.code, el));\n                textNode.__x_ti_bound = true;\n                const update = () => {\n                    let out = '';\n                    let ei = 0;\n                    for (const s of segs) {\n                        if (s.type === 'lit')\n                            out += s.text;\n                        else {\n                            const v = evaluators[ei++]();\n                            out += (v == null ? '' : String(v));\n                        }\n                    }\n                    if (textNode.textContent !== out)\n                        textNode.textContent = out;\n                };\n                const dirInfo = { type: 'text-interpolation', expression: raw, update: undefined };\n                this._addDirective(el, dirInfo);\n                const effect = this._createEffect(update, dirInfo);\n                dirInfo.update = effect;\n            }\n        }\n        _walkElements(parent, processor) {\n            let child = parent.firstElementChild;\n            while (child) {\n                const next = child.nextElementSibling;\n                if (processor(child))\n                    this._walkElements(child, processor);\n                child = next;\n            }\n        }\n        _bindDirective(element, directiveName, expression) {\n            const self = this;\n            const isAtEvent = directiveName.startsWith('@');\n            const isShortBind = directiveName.startsWith(PFX + ':');\n            const type = isAtEvent ? ('on:' + directiveName.slice(1)) : directiveName.slice(PFX.length + 1);\n            if (!isAtEvent && (isShortBind || type === 'class' || type === STR_STYLE)) {\n                element.removeAttribute(directiveName);\n                return self._bindAttributeDirective(element, type, expression);\n            }\n            if (!isAtEvent && (type === 'text' || type === 'html' || type === 'show')) {\n                element.removeAttribute(directiveName);\n                return self._bindSimpleDirective(element, expression, type);\n            }\n            const handled = (!isAtEvent && type === 'model') ? (element.removeAttribute(directiveName), self._bindModelDirective(element, expression), true)\n                : type === 'if' ? (element.removeAttribute(directiveName), self._bindIfDirective(element, expression), true)\n                    : type === 'for' ? (element.removeAttribute(directiveName), self._bindForDirective(element, expression), true)\n                        : false;\n            if (handled)\n                return;\n            if (isAtEvent || type.indexOf(':') > -1) {\n                const [prefix, rest] = type.split(':', 2);\n                const [suffix, ...mods] = rest.split('.');\n                const modifiers = mods.reduce((acc, m) => { if (m)\n                    acc[m] = true; return acc; }, {});\n                if (prefix === 'on') {\n                    element.removeAttribute(directiveName);\n                    const customDirective = self.framework._getCustomDirective(suffix);\n                    return customDirective\n                        ? self._bindCustomDirective(element, suffix, expression, customDirective, modifiers)\n                        : self._bindEventDirective(element, suffix, expression, modifiers);\n                }\n                if (prefix === 'intersect') {\n                    element.removeAttribute(directiveName);\n                    return self._bindIntersectDirective(element, expression, modifiers, suffix);\n                }\n                element.removeAttribute(directiveName);\n                return self._bindAttributeDirective(element, suffix, expression);\n            }\n        }\n        _bindIntersectDirective(element, expression, modifiers, phase) {\n            const self = this;\n            const trimmed = _tr(expression);\n            const runExpr = self._compileHandler(trimmed, element, (payload) => [payload, element]);\n            const run = (payload) => { if (runExpr)\n                runExpr(payload); };\n            const once = !!modifiers['once'];\n            let rootMargin = '0px';\n            for (const m in modifiers) {\n                if (m.startsWith('rootMargin-')) {\n                    rootMargin = m.slice('rootMargin-'.length);\n                    break;\n                }\n            }\n            const onEnter = phase === 'enter' ? { cb: (entry, info) => run({ entry, ...info }), once } : undefined;\n            const onLeave = phase === 'leave' ? { cb: (entry, info) => run({ entry, ...info }), once } : undefined;\n            const unobserve = this.framework._ioObserve(element, rootMargin, onEnter, onLeave);\n            const dir = { type: 'intersect', expression };\n            this._addDirective(element, dir);\n            this._addCleanupFunction(() => { try {\n                unobserve();\n            }\n            catch { } });\n        }\n        _createEffect(updateFn, directiveRef) {\n            const effect = () => {\n                this._activeEffect = effect;\n                try {\n                    updateFn();\n                }\n                finally {\n                    this._activeEffect = null;\n                }\n            };\n            effect();\n            this._allEffects.add(effect);\n            if (XTOOL_ENABLE_STATIC_DIRECTIVES && directiveRef && directiveRef._static === undefined) {\n                let found = false;\n                for (const deps of this._propertyDependencies.values()) {\n                    if (deps.includes(effect)) {\n                        found = true;\n                        break;\n                    }\n                }\n                directiveRef._static = !found;\n            }\n            return effect;\n        }\n        _bindSimpleDirective(element, expression, type) {\n            if (type === 'class' || type === STR_STYLE) {\n                return this._bindAttributeDirective(element, type, expression);\n            }\n            const evaluator = this._createElementEvaluator(expression, element);\n            let originalDisplay;\n            if (type === 'show') {\n                const el = element;\n                originalDisplay = el.style[STR_DISPLAY] !== STR_NONE ? el.style[STR_DISPLAY] : undefined;\n            }\n            let _prevShown = undefined;\n            const update = () => {\n                const value = evaluator();\n                const el = element;\n                switch (type) {\n                    case 'text':\n                        el.textContent = String(value);\n                        break;\n                    case 'html':\n                        el.innerHTML = String(value || '');\n                        break;\n                    case 'show':\n                        const next = !!value;\n                        if (_prevShown === next)\n                            return;\n                        _prevShown = next;\n                        el.style[STR_DISPLAY] = next ? (originalDisplay || '') : STR_NONE;\n                        break;\n                }\n            };\n            const dirInfo = { type, expression, update: undefined, originalDisplay };\n            this._addDirective(element, dirInfo);\n            const effect = this._createEffect(update, dirInfo);\n            dirInfo.update = effect;\n        }\n        _bindModelDirective(element, property) {\n            const isCheckbox = element.type === 'checkbox';\n            const isNumeric = element.type === 'number' || element.type === 'range';\n            const isMultiSelect = element.tagName === 'SELECT' && element.multiple === true;\n            if (!(property in this._data)) {\n                this._data[property] = undefined;\n            }\n            const getValueEvaluator = this._createElementEvaluator(property, element);\n            const setValueEvaluator = this._createEvaluator(`${property} = $value`, true);\n            const inferCheckboxValue = () => {\n                if (element.hasAttribute('value'))\n                    return element.value;\n                const loopScope = this._collectLoopScope(element);\n                if (loopScope) {\n                    const keys = Object.keys(loopScope);\n                    if (keys.length === 1)\n                        return loopScope[keys[0]];\n                }\n                return element.value;\n            };\n            const checkboxValue = isCheckbox ? inferCheckboxValue() : undefined;\n            const getInputValue = () => {\n                if (isCheckbox) {\n                    const currentData = getValueEvaluator();\n                    if (Array.isArray(currentData) && checkboxValue !== undefined) {\n                        return element.checked ? checkboxValue : undefined;\n                    }\n                    return element.hasAttribute('value') ? (element.checked ? element.value : undefined) : element.checked;\n                }\n                if (isMultiSelect) {\n                    const sel = element;\n                    const values = [];\n                    const opts = sel.options;\n                    for (let i = 0; i < opts.length; i++) {\n                        if (opts[i].selected)\n                            values.push(opts[i].value);\n                    }\n                    return values;\n                }\n                return isNumeric ? parseFloat(element.value) || 0 : element.value;\n            };\n            const setInputValue = (value) => {\n                if (isCheckbox) {\n                    if (Array.isArray(value)) {\n                        const member = element.hasAttribute('value') ? element.value : checkboxValue;\n                        element.checked = member != null ? value.includes(member) : false;\n                    }\n                    else {\n                        element.checked = !!value;\n                    }\n                    return;\n                }\n                if (isMultiSelect) {\n                    const sel = element;\n                    const arr = Array.isArray(value) ? value : [];\n                    const opts = sel.options;\n                    for (let i = 0; i < opts.length; i++) {\n                        opts[i].selected = arr.includes(opts[i].value);\n                    }\n                    return;\n                }\n                element.value = String(value ?? (isNumeric ? 0 : ''));\n            };\n            this._createEffect(() => setInputValue(getValueEvaluator()));\n            const ctx = this._createContextProxy(undefined, element);\n            const updateData = () => {\n                const raw = getInputValue();\n                const currentVal = this._safeExecute(() => getValueEvaluator());\n                if (isCheckbox && Array.isArray(currentVal)) {\n                    const member = element.hasAttribute('value') ? element.value : checkboxValue;\n                    if (member !== undefined) {\n                        const idx = currentVal.indexOf(member);\n                        if (element.checked) {\n                            if (idx === -1)\n                                currentVal.push(member);\n                        }\n                        else if (idx > -1) {\n                            currentVal.splice(idx, 1);\n                        }\n                    }\n                }\n                else if (isMultiSelect && Array.isArray(currentVal)) {\n                    currentVal.splice(0, currentVal.length, ...raw);\n                }\n                else {\n                    ctx.$value = raw;\n                    this._safeExecute(() => { setValueEvaluator.call(this._createMethodContext(), ctx); });\n                }\n            };\n            const t = element.type;\n            const eventType = (element[STR_TAGNAME] === 'SELECT' || t === 'checkbox' || t === 'radio' || t === 'file') ? 'change' : 'input';\n            this._listen(element, eventType, updateData);\n            this._addDirective(element, { type: 'model', property });\n        }\n        _bindIfDirective(element, expression) {\n            const self = this;\n            const placeholder = d.createComment('x-if');\n            element.parentNode?.insertBefore(placeholder, element);\n            element.__x_if_anchorParent = placeholder.parentElement || null;\n            const branches = [];\n            const makeActualElement = (el) => {\n                if (el[STR_TAGNAME] === STR_TEMPLATE) {\n                    const wrapper = d.createElement('div');\n                    wrapper.style[STR_DISPLAY] = STR_CONTENTS;\n                    wrapper.appendChild(el.content.cloneNode(true));\n                    return { el: wrapper, isTemplate: true };\n                }\n                return { el: el, isTemplate: false };\n            };\n            const first = makeActualElement(element);\n            const firstEval = self._createElementEvaluator(expression, element);\n            branches.push({ el: first.el, test: firstEval, isTemplate: first.isTemplate });\n            if (!first.isTemplate)\n                first.el.__x_tool_bound = true;\n            const originalNodes = [element];\n            if (FT_IFB) {\n                let sib = element.nextElementSibling;\n                while (sib) {\n                    const isElse = sib.hasAttribute(attrName('else'));\n                    const isElseIf = sib.hasAttribute(attrName('else-if'));\n                    if (!isElse && !isElseIf)\n                        break;\n                    if (sib.hasAttribute(attrName('else-if'))) {\n                        const attr = sib.getAttribute(attrName('else-if')) || '';\n                        const branch = makeActualElement(sib);\n                        const evalFn = self._createElementEvaluator(_tr(attr), sib);\n                        branches.push({ el: branch.el, test: evalFn, isTemplate: branch.isTemplate });\n                        if (!branch.isTemplate)\n                            branch.el.__x_tool_bound = true;\n                    }\n                    else {\n                        const branch = makeActualElement(sib);\n                        branches.push({ el: branch.el, test: null, isTemplate: branch.isTemplate });\n                        if (!branch.isTemplate)\n                            branch.el.__x_tool_bound = true;\n                    }\n                    sib.removeAttribute(attrName('else'));\n                    sib.removeAttribute(attrName('else-if'));\n                    originalNodes.push(sib);\n                    sib = sib.nextElementSibling;\n                }\n            }\n            let active = -1;\n            for (const orig of originalNodes) {\n                if (orig.parentNode)\n                    orig.parentNode.removeChild(orig);\n            }\n            const mountBranch = (idx) => {\n                if (idx < 0)\n                    return;\n                const b = branches[idx];\n                if (!b.el.__x_tool_bound) {\n                    self._parseDirectives(b.el);\n                    b.el.__x_tool_bound = true;\n                }\n                element.__x_if_current?.parentNode?.removeChild(element.__x_if_current);\n                if (!b.el.parentNode) {\n                    placeholder.parentNode?.insertBefore(b.el, placeholder.nextSibling);\n                }\n                element.__x_if_current = b.el;\n                active = idx;\n            };\n            const unmountBranch = (idx, cb) => {\n                if (idx < 0) {\n                    if (cb)\n                        cb();\n                    return;\n                }\n                const b = branches[idx];\n                if (b.el.parentNode) {\n                    if (b.el.parentNode)\n                        b.el.parentNode.removeChild(b.el);\n                    if (cb)\n                        cb();\n                }\n                else if (cb)\n                    cb();\n                active = -1;\n            };\n            const update = () => {\n                let next = -1;\n                for (let i = 0; i < branches[STR_LENGTH]; i++) {\n                    const b = branches[i];\n                    const pass = b.test ? !!b.test() : true;\n                    if (pass) {\n                        next = i;\n                        break;\n                    }\n                }\n                if (next === active)\n                    return;\n                if (active !== -1) {\n                    unmountBranch(active, () => mountBranch(next));\n                }\n                else {\n                    mountBranch(next);\n                }\n            };\n            const effect = self._createEffect(update);\n            self._addDirective(element, { type: 'if', expression, update: effect });\n        }\n        _bindEventDirective(element, eventName, expression, modifiers) {\n            const self = this;\n            const trimmed = _tr(expression);\n            const opts = modifiers ? {\n                once: !!modifiers.once,\n                passive: !!modifiers.passive,\n                capture: !!modifiers.capture,\n            } : undefined;\n            const onlySelf = !!modifiers?.self;\n            const shouldPrevent = !!modifiers?.prevent;\n            const shouldStop = !!modifiers?.stop;\n            const isOutside = !!modifiers?.outside;\n            const deferExec = !!modifiers?.defer;\n            const keyAliasMap = { enter: ['enter'], esc: ['escape', 'esc'], escape: ['escape', 'esc'], space: [' ', 'space', 'spacebar'], tab: ['tab'], backspace: ['backspace'], delete: ['delete', 'del'], del: ['delete', 'del'], arrowup: ['arrowup', 'up'], arrowdown: ['arrowdown', 'down'], arrowleft: ['arrowleft', 'left'], arrowright: ['arrowright', 'right'], home: ['home'], end: ['end'], pageup: ['pageup'], pagedown: ['pagedown'] };\n            const comboRequirements = {\n                ctrl: !!modifiers?.ctrl,\n                alt: !!modifiers?.alt,\n                shift: !!modifiers?.shift,\n                meta: !!modifiers?.meta,\n            };\n            const buttonMap = { left: 0, middle: 1, right: 2 };\n            const touchSingle = !!modifiers?.single;\n            const touchMulti = !!modifiers?.multi;\n            const modifierKeys = modifiers ? _Okeys(modifiers) : [];\n            const allowedKeys = [];\n            for (const m of modifierKeys) {\n                const aliases = keyAliasMap[m.toLowerCase()];\n                if (aliases)\n                    allowedKeys.push(...aliases);\n            }\n            const allowedButtons = [];\n            for (const m of modifierKeys) {\n                const btn = buttonMap[m.toLowerCase()];\n                if (btn !== undefined)\n                    allowedButtons.push(btn);\n            }\n            const needKeyCheck = allowedKeys.length > 0 || comboRequirements.ctrl || comboRequirements.alt || comboRequirements.shift || comboRequirements.meta;\n            const needButtonCheck = allowedButtons.length > 0;\n            const needTouchCheck = touchSingle || touchMulti;\n            const passesFilters = (event) => {\n                const path = event.composedPath ? event.composedPath() : null;\n                const tgt = (path && path.length ? path[0] : event.target);\n                if (isOutside) {\n                    if (!tgt)\n                        return false;\n                    if (element instanceof Node && (element === tgt || element.contains(tgt)))\n                        return false;\n                }\n                if (onlySelf && event.target !== element)\n                    return false;\n                if (needTouchCheck) {\n                    if (event instanceof TouchEvent) {\n                        const tCount = event.touches.length;\n                        if (touchSingle && tCount !== 1)\n                            return false;\n                        if (touchMulti && tCount < 2)\n                            return false;\n                    }\n                    else\n                        return false;\n                }\n                if (needButtonCheck) {\n                    if (event instanceof MouseEvent) {\n                        if (!allowedButtons.includes(event.button))\n                            return false;\n                    }\n                    else\n                        return false;\n                }\n                if (needKeyCheck) {\n                    if (!(event instanceof KeyboardEvent))\n                        return false;\n                    const k = (event.key || '').toLowerCase();\n                    if (allowedKeys.length > 0 && !allowedKeys.includes(k))\n                        return false;\n                    const { ctrlKey, altKey, shiftKey, metaKey } = event;\n                    if ((comboRequirements.ctrl && !ctrlKey) || (comboRequirements.alt && !altKey) ||\n                        (comboRequirements.shift && !shiftKey) || (comboRequirements.meta && !metaKey))\n                        return false;\n                }\n                return true;\n            };\n            const runExpr = self._compileHandler(trimmed, element, (ev) => [ev, element]);\n            const createEventHandler = (event) => {\n                if (!passesFilters(event))\n                    return;\n                if (shouldPrevent)\n                    event.preventDefault();\n                if (shouldStop)\n                    event.stopPropagation();\n                if (!runExpr)\n                    return;\n                if (deferExec && typeof quMct === 'function') {\n                    const ev = event;\n                    quMct(() => self._safeExecute(() => runExpr(ev)));\n                    return;\n                }\n                self._safeExecute(() => runExpr(event));\n            };\n            const cfg = this.framework._getConfig();\n            const canDelegate = !!cfg.delegate && EV_DELEGATED.includes(eventName);\n            if (!isOutside && canDelegate) {\n                const remover = this.framework._registerDelegated(element, eventName, { filter: (e) => passesFilters(e), run: (e) => createEventHandler(e), once: !!modifiers?.once, comp: this });\n                this._addCleanupFunction(remover);\n            }\n            else {\n                const target = isOutside ? (element?.ownerDocument || d || document) : element;\n                self._listen(target, eventName, createEventHandler, opts);\n            }\n        }\n        _createEvaluator(expression, isStatement = false) {\n            const key = `${isStatement ? 's' : 'r'}:${expression}`;\n            let fn = this._expressionCache.get(key);\n            if (!fn) {\n                fn = new Function('ctx', `with(ctx){${isStatement ? expression : `return (${expression})`}}`);\n                this._expressionCache.set(key, fn);\n            }\n            return fn;\n        }\n        _createElementEvaluator(expression, element) {\n            const self = this;\n            const compiled = self._createEvaluator(expression);\n            return () => this._safeExecute(() => compiled.call(self._createMethodContext(), self._createContextProxy(undefined, element)));\n        }\n        _extractArrowFunction(expression) {\n            let m = expression.match(/^\\s*\\(\\s*([^)]*?)\\s*\\)\\s*=>\\s*([\\s\\S]+)$/);\n            if (!m)\n                m = expression.match(/^\\s*([a-zA-Z_$][a-zA-Z0-9_$]*)\\s*=>\\s*([\\s\\S]+)$/);\n            if (!m)\n                return null;\n            const params = (m[1] || '')\n                .split(',')\n                .map(p => p.trim())\n                .filter(Boolean);\n            const body = _tr(m[2]);\n            const isBlock = body.startsWith('{') && body.endsWith('}');\n            const finalBody = isBlock ? body.slice(1, -1) : body;\n            return { paramsList: params, body: finalBody, isBlock };\n        }\n        _compileArrowForEvent(params, body, isBlock) {\n            const content = isBlock ? body : 'return ( ' + body + ' );';\n            return new Function('ctx', ...params, 'with(ctx){ ' + content + ' }');\n        }\n        _compileHandler(expression, element, mapArgs) {\n            const self = this;\n            const trimmed = _tr(expression);\n            if (!trimmed)\n                return null;\n            const arrow = self._extractArrowFunction(trimmed);\n            const thisCtx = self._createMethodContext();\n            if (arrow) {\n                const { paramsList, body, isBlock } = arrow;\n                const compiledArrow = self._compileArrowForEvent(paramsList, body, isBlock);\n                return (payload) => {\n                    const ctx = self._createContextProxy(payload, element);\n                    const args = mapArgs(payload);\n                    self._safeExecute(() => compiledArrow.call(thisCtx, ctx, ...args.slice(0, paramsList.length)));\n                };\n            }\n            const isStatement = trimmed.includes(';');\n            const executor = self._createEvaluator(trimmed, isStatement);\n            return (payload) => {\n                const ctx = self._createContextProxy(payload, element);\n                const result = executor.call(thisCtx, ctx);\n                if (typeof result === 'function') {\n                    try {\n                        result.call(thisCtx, payload);\n                    }\n                    catch { }\n                }\n            };\n        }\n        _assertMutable(parentKey, method) {\n            if (this._isInComputedEvaluation) {\n                throw new Error(`[x-tool] Mutation via '${String(parentKey)}.${method}()' is not allowed during computed evaluation.`);\n            }\n            if (this._isFrozen) {\n                throw new Error(`[x-tool] Mutation via '${String(parentKey)}.${method}()' is not allowed while component is frozen.`);\n            }\n        }\n        _wrapData(data, parentKey) {\n            const isArr = ARRAY_ISARRAY(data);\n            const isSet = (typeof Set !== 'undefined') && (data instanceof Set);\n            const isMap = (typeof Map !== 'undefined') && (data instanceof Map);\n            if (!(Object.getPrototypeOf(data) === Object.prototype || isArr || isSet || isMap))\n                return data;\n            const self = this;\n            if (!this._deepReactiveCache)\n                this._deepReactiveCache = new WkMap();\n            if (this._deepReactiveCache.has(data))\n                return this._deepReactiveCache.get(data);\n            const makeCollectionWrapper = (name, fn, isArray) => function (...args) {\n                self._assertMutable(parentKey, name);\n                if (isArray) {\n                    const arr = this;\n                    const beforeLen = arr.length;\n                    const beforeFirst = arr[0];\n                    const beforeLast = arr[beforeLen - 1];\n                    const result = fn.apply(this, args);\n                    if (!self._isSealed && (arr.length !== beforeLen || arr[0] !== beforeFirst || arr[arr.length - 1] !== beforeLast)) {\n                        self._onDataChange(parentKey);\n                    }\n                    return result;\n                }\n                else {\n                    const before = this.size;\n                    const existed = (name === 'set') ? this.has(args[0]) : false;\n                    const result = fn.apply(this, args);\n                    if (!self._isSealed && (this.size !== before || (name === 'set' && !existed)))\n                        self._onDataChange(parentKey);\n                    return result;\n                }\n            };\n            const proxy = new Proxy(data, {\n                get: (target, p, receiver) => {\n                    const isCollection = isSet || isMap;\n                    if (isArr) {\n                        if (p === Symbol.iterator || p === 'length' || (typeof p === 'string' && /^\\d+$/.test(p))) {\n                            self._trackDependency(parentKey);\n                            if (p === Symbol.iterator)\n                                return Reflect.get(target, p, receiver);\n                        }\n                    }\n                    else if (isCollection) {\n                        if (p === 'size' || p === Symbol.iterator || p === 'keys' || p === 'values' || p === 'entries') {\n                            self._trackDependency(parentKey);\n                        }\n                    }\n                    else {\n                        self._trackDependency(parentKey);\n                    }\n                    const value = Reflect.get(target, p, receiver);\n                    if (isCollection && typeof value === 'function' && (p === Symbol.iterator || p === 'keys' || p === 'values' || p === 'entries')) {\n                        return function (...args) { return value.apply(target, args); };\n                    }\n                    if (typeof value === 'function') {\n                        if (isArr && ['push', 'pop', 'shift', 'unshift', 'splice', 'reverse', 'copyWithin', 'fill', 'sort'].includes(p)) {\n                            return makeCollectionWrapper(String(p), value, true).bind(target);\n                        }\n                        if (isSet && (p === 'add' || p === 'delete' || p === 'clear')) {\n                            return makeCollectionWrapper(String(p), value, false).bind(target);\n                        }\n                        if (isMap && (p === 'set' || p === 'delete' || p === 'clear')) {\n                            return makeCollectionWrapper(String(p), value, false).bind(target);\n                        }\n                    }\n                    return (value && typeof value === 'object') ? self._wrapData(value, parentKey) : value;\n                },\n                ownKeys: Reflect.ownKeys,\n                has: Reflect.has,\n                set: (target, p, value) => {\n                    if (self._isDestroyed || typeof p === 'symbol')\n                        return true;\n                    const key = String(parentKey) + '.' + String(p);\n                    if (self._isInComputedEvaluation)\n                        throw new Error(`[x-tool] Mutation of '${key}' is not allowed during computed evaluation.`);\n                    if (self._isFrozen)\n                        throw new Error(`[x-tool] Mutation of '${key}' is not allowed while component is frozen.`);\n                    const had = Reflect.has(target, p);\n                    const oldValue = had ? Reflect.get(target, p) : undefined;\n                    if (value && typeof value === 'object') {\n                        value = self._wrapData(value, (String(parentKey) + '.' + String(p)));\n                    }\n                    if (!had) {\n                        _se(() => Reflect.defineProperty(target, p, { configurable: true, enumerable: true, writable: true, value }));\n                        if (!Reflect.has(target, p))\n                            Reflect.set(target, p, value);\n                        self._onDataChange(parentKey);\n                        return true;\n                    }\n                    if (oldValue === value)\n                        return true;\n                    Reflect.set(target, p, value);\n                    if (!self._isSealed)\n                        self._onDataChange(parentKey);\n                    return true;\n                },\n                deleteProperty: (target, p) => {\n                    const key = String(parentKey) + (typeof p === 'symbol' ? '' : '.' + String(p));\n                    if (self._isInComputedEvaluation)\n                        throw new Error(`[x-tool] Deletion of '${key}' is not allowed during computed evaluation.`);\n                    if (self._isFrozen)\n                        throw new Error(`[x-tool] Deletion of '${key}' is not allowed while component is frozen.`);\n                    const ok = Reflect.deleteProperty(target, p);\n                    if (ok && !self._isSealed)\n                        self._onDataChange(parentKey);\n                    return ok;\n                }\n            });\n            this._deepReactiveCache.set(data, proxy);\n            return proxy;\n        }\n        _createReactiveData(data) {\n            const self = this;\n            return new Proxy(data, {\n                get: (target, property, receiver) => {\n                    const value = Reflect.get(target, property, receiver);\n                    if (property === Symbol.iterator)\n                        return value;\n                    if (typeof property !== 'symbol') {\n                        self._trackDependency(property);\n                    }\n                    if (value && typeof value === 'object') {\n                        return self._wrapData(value, property);\n                    }\n                    return value;\n                },\n                ownKeys: (target) => Reflect.ownKeys(target),\n                has: (target, key) => Reflect.has(target, key),\n                set: (target, property, value, receiver) => {\n                    if (self._isDestroyed)\n                        return true;\n                    if (self._isFrozen)\n                        return true;\n                    if (self._isInComputedEvaluation) {\n                        throw new Error(`[x-tool] Mutation of '${String(property)}' is not allowed during computed evaluation.`);\n                    }\n                    if (property === Symbol.iterator && ARRAY_ISARRAY(target))\n                        return value;\n                    const oldValue = Reflect.get(target, property);\n                    const had = Reflect.has(target, property);\n                    if (!had) {\n                        try {\n                            Reflect.defineProperty(target, property, {\n                                configurable: true,\n                                enumerable: true,\n                                writable: true,\n                                value\n                            });\n                        }\n                        catch {\n                            Reflect.set(target, property, value, receiver);\n                        }\n                    }\n                    else {\n                        Reflect.set(target, property, value, receiver);\n                    }\n                    if (!this._isSealed)\n                        this._onDataChange(property);\n                    if (this._propUpdateActive && property !== '$props') {\n                        const pc = target.$props;\n                        if (pc)\n                            pc[property] = value;\n                        const eff = this._propEffects[property];\n                        if (eff && !this._isSealed) {\n                            eff(value, oldValue);\n                        }\n                    }\n                    return true;\n                }\n            });\n        }\n        _createMethodContext(_includeComputed = true) {\n            const specials = {\n                '$log': (..._args) => { },\n                '$destroy': () => this.destroy(),\n                '$forceUpdate': () => this._scheduleRender(),\n                '$addCleanupFunction': (fn) => this._addCleanupFunction(fn),\n                '$nextTick': (cb) => {\n                    if (cb) {\n                        this._nextTickQueue.push(cb);\n                        if (!this._renderScheduled)\n                            quMct(() => {\n                                if (!this._renderScheduled && this._nextTickQueue.length) {\n                                    const q = this._nextTickQueue.splice(0, this._nextTickQueue.length);\n                                    for (const fn of q) {\n                                        this._safeExecute(() => fn());\n                                    }\n                                }\n                            });\n                        return;\n                    }\n                    return new Promise(resolve => {\n                        this._nextTickQueue.push(() => resolve());\n                        if (!this._renderScheduled)\n                            quMct(() => {\n                                if (!this._renderScheduled && this._nextTickQueue.length) {\n                                    const q = this._nextTickQueue.splice(0, this._nextTickQueue.length);\n                                    for (const fn of q) {\n                                        this._safeExecute(() => fn());\n                                    }\n                                }\n                            });\n                    });\n                },\n                '$el': this._element,\n                '$id': this._id,\n                '$isMounted': this._isMounted,\n                '$isDestroyed': this._isDestroyed,\n                '$isSealed': this._isSealed,\n                '$isFrozen': this._isFrozen,\n                '$parent': this._parent,\n                '$children': this._children,\n                '$seal': (on = true) => { this._setSealed(!!on); },\n                '$mutate': (fn) => {\n                    const prevMethod = this._isInMethodExecution;\n                    this._isMutationEnabled = false;\n                    if (this._isInComputedEvaluation) {\n                        throw new Error('[x-tool] $mutate cannot be used inside computed evaluation; computed getters must be pure.');\n                    }\n                    this._isInMethodExecution = false;\n                    try {\n                        return typeof fn === 'function' ? fn() : undefined;\n                    }\n                    finally {\n                        this._isInMethodExecution = prevMethod;\n                        this._isMutationEnabled = true;\n                        this._scheduleRender();\n                    }\n                }\n            };\n            let data = this._data;\n            if (this._isInComputedEvaluation) {\n                data = (this._rawData);\n            }\n            return new Proxy(data, {\n                get: (target, propStr) => {\n                    if (propStr in target) {\n                        this._trackDependency(propStr);\n                        const v = target[propStr];\n                        return v;\n                    }\n                    if (FT_C && (propStr in this._computed)) {\n                        return this._getComputedValue(propStr);\n                    }\n                    if (propStr in specials)\n                        return specials[propStr];\n                    return this._methods[propStr];\n                },\n                set: (_target, propStr, value) => {\n                    if (this._isInComputedEvaluation) {\n                        throw new Error(`[x-tool] Mutation of '${String(propStr)}' is not allowed during computed evaluation.`);\n                    }\n                    if (this._isFrozen) {\n                        throw new Error(`[x-tool] Mutation of '${String(propStr)}' is not allowed while component is frozen.`);\n                    }\n                    this._data[propStr] = value;\n                    return true;\n                }\n            });\n        }\n        _createContextProxy(event, targetElement) {\n            const component = this;\n            const mergedScope = targetElement ? this._collectLoopScope(targetElement) : null;\n            const gWindow = (typeof window !== 'undefined' ? window : undefined);\n            const gDocument = (typeof document !== 'undefined' ? document : undefined);\n            const cfg = this.framework._getConfig();\n            const sandbox = !!cfg.sandboxExpressions;\n            const allow = new Set((cfg.allowGlobals || []).map(s => String(s)));\n            const ensureInvoker = () => this._currentInvoker || '__anonymous__';\n            const registerResource = (kind, setup) => {\n                const inv = ensureInvoker();\n                let byKind = this._invokerResources.get(inv);\n                if (!byKind) {\n                    byKind = new Map();\n                    this._invokerResources.set(inv, byKind);\n                }\n                const prev = byKind.get(kind);\n                if (prev) {\n                    try {\n                        prev();\n                    }\n                    catch { }\n                    byKind.delete(kind);\n                }\n                const cleanup = setup();\n                if (typeof cleanup === 'function') {\n                    const wrapped = () => {\n                        try {\n                            cleanup();\n                        }\n                        finally {\n                            byKind?.delete(kind);\n                        }\n                    };\n                    byKind.set(kind, wrapped);\n                    this._addCleanupFunction(wrapped);\n                }\n            };\n            const wrapTarget = (target) => {\n                if (!target || typeof target.addEventListener !== 'function')\n                    return target;\n                return new Proxy(target, {\n                    get: (obj, prop) => {\n                        if (prop === 'addEventListener') {\n                            return (eventName, handler, options) => {\n                                if (this._isSealed || this._isFrozen)\n                                    return;\n                                obj.addEventListener(eventName, handler, options);\n                                const optSig = typeof options === 'boolean' ? options : options?.capture ? '1' : '0';\n                                const key = 'listener:' + this._targetKey(obj) + ':' + eventName + ':' + optSig;\n                                registerResource(key, () => () => {\n                                    try {\n                                        obj.removeEventListener(eventName, handler, options);\n                                    }\n                                    catch { }\n                                });\n                            };\n                        }\n                        if (prop === 'removeEventListener') {\n                            return (eventName, handler, options) => {\n                                try {\n                                    obj.removeEventListener(eventName, handler, options);\n                                }\n                                catch { }\n                            };\n                        }\n                        if (prop === 'querySelector') {\n                            return (sel) => wrapTarget(obj.querySelector(sel));\n                        }\n                        if (prop === 'querySelectorAll') {\n                            return (sel) => Array.from(obj.querySelectorAll(sel)).map(wrapTarget);\n                        }\n                        if (prop === 'getElementById') {\n                            return (id) => wrapTarget(obj.getElementById(id));\n                        }\n                        if (prop === 'document') {\n                            const doc = obj.document;\n                            return wrapTarget(doc) || doc;\n                        }\n                        if (prop === 'defaultView') {\n                            const win = obj.defaultView;\n                            return wrapTarget(win) || win;\n                        }\n                        if (prop === 'body') {\n                            const body = obj.body;\n                            return wrapTarget(body) || body;\n                        }\n                        const value = obj[prop];\n                        if (typeof value === 'function') {\n                            try {\n                                return value.bind(obj);\n                            }\n                            catch {\n                                return value;\n                            }\n                        }\n                        return value;\n                    }\n                });\n            };\n            const ctxSetTimeout = (fn, ms, ...args) => {\n                if (this._isSealed || this._isFrozen || this._isDestroyed)\n                    return undefined;\n                const id = gWindow?.setTimeout?.(fn, ms, ...args);\n                if (id != null)\n                    registerResource('timeout', () => () => { try {\n                        gWindow?.clearTimeout?.(id);\n                    }\n                    catch { } });\n                return id;\n            };\n            const ctxSetInterval = (fn, ms, ...args) => {\n                if (this._isSealed || this._isFrozen)\n                    return undefined;\n                const id = gWindow?.setInterval?.(fn, ms, ...args);\n                if (id != null)\n                    registerResource('interval', () => () => { try {\n                        gWindow?.clearInterval?.(id);\n                    }\n                    catch { } });\n                return id;\n            };\n            const ctxRequestAnimationFrame = (cb) => {\n                if (this._isSealed || this._isFrozen)\n                    return undefined;\n                const id = gWindow?.requestAnimationFrame?.(cb);\n                if (id != null)\n                    registerResource('raf', () => () => { try {\n                        gWindow?.cancelAnimationFrame?.(id);\n                    }\n                    catch { } });\n                return id;\n            };\n            const wrapObserverCtor = (Orig, kind) => {\n                if (!Orig)\n                    return undefined;\n                return function (...observerArgs) {\n                    if (component._isSealed || component._isFrozen)\n                        return { observe() { }, disconnect() { }, unobserve() { } };\n                    const inst = new Orig(...observerArgs);\n                    registerResource('observer:' + kind, () => () => { try {\n                        inst.disconnect();\n                    }\n                    catch { } });\n                    return inst;\n                };\n            };\n            const specials = {\n                '$target': targetElement || null,\n                '$event': event || null,\n                ...(this.framework._routerEnabled() ? {\n                    'location': new Proxy(gWindow?.location || location, {\n                        get: (t, p) => t[p],\n                        set: (_t, p, v) => {\n                            const key = String(p);\n                            if (key === 'href') {\n                                try {\n                                    this.framework._navigate(String(v), true, 'program');\n                                }\n                                catch {\n                                    location.href = String(v);\n                                }\n                                return true;\n                            }\n                            try {\n                                location[p] = v;\n                            }\n                            catch { }\n                            return true;\n                        }\n                    })\n                } : {}),\n                ...(sandbox && !allow.has('setTimeout') ? {} : { 'setTimeout': ctxSetTimeout }),\n                ...(sandbox && !allow.has('clearTimeout') ? {} : { 'clearTimeout': (id) => { try {\n                        gWindow?.clearTimeout?.(id);\n                    }\n                    catch { } } }),\n                ...(sandbox && !allow.has('setInterval') ? {} : { 'setInterval': ctxSetInterval }),\n                ...(sandbox && !allow.has('clearInterval') ? {} : { 'clearInterval': (id) => { try {\n                        gWindow?.clearInterval?.(id);\n                    }\n                    catch { } } }),\n                ...(sandbox && !allow.has('requestAnimationFrame') ? {} : { 'requestAnimationFrame': ctxRequestAnimationFrame }),\n                ...(sandbox && !allow.has('cancelAnimationFrame') ? {} : { 'cancelAnimationFrame': (id) => { try {\n                        gWindow?.cancelAnimationFrame?.(id);\n                    }\n                    catch { } } }),\n                ...(sandbox && !allow.has('MutationObserver') ? {} : { 'MutationObserver': wrapObserverCtor(gWindow?.MutationObserver, 'mutation') }),\n                ...(sandbox && !allow.has('ResizeObserver') ? {} : { 'ResizeObserver': wrapObserverCtor(gWindow?.ResizeObserver, 'resize') }),\n                ...(sandbox && !allow.has('IntersectionObserver') ? {} : { 'IntersectionObserver': wrapObserverCtor(gWindow?.IntersectionObserver, 'intersection') }),\n                ...(sandbox && !allow.has('window') ? {} : { 'window': wrapTarget(gWindow) }),\n                ...(sandbox && !allow.has('document') ? {} : { 'document': wrapTarget(gDocument) })\n            };\n            return new Proxy({}, {\n                get: (_t, propStr) => {\n                    if (mergedScope && propStr in mergedScope)\n                        return mergedScope[propStr];\n                    if (propStr in component._data)\n                        return component._data[propStr];\n                    if (propStr in component._computed)\n                        return component._getComputedValue(propStr);\n                    if (propStr in component._methods)\n                        return component._methods[propStr];\n                    if (propStr in specials)\n                        return specials[propStr];\n                    return undefined;\n                },\n                set: (_t, propStr, value) => {\n                    if (mergedScope) {\n                        let s = mergedScope;\n                        while (s) {\n                            if (Object.prototype.hasOwnProperty.call(s, propStr)) {\n                                s[propStr] = value;\n                                return true;\n                            }\n                            s = Object.getPrototypeOf(s);\n                        }\n                    }\n                    component._data[propStr] = value;\n                    return true;\n                },\n                has: (_t, propStr) => !!(mergedScope && propStr in mergedScope) ||\n                    propStr in component._data ||\n                    propStr in component._computed ||\n                    propStr in component._methods ||\n                    propStr in specials\n            });\n        }\n        _bindCustomDirective(element, _name, expression, directive, modifiers) {\n            const self = this;\n            const evaluator = self._createElementEvaluator(expression, element);\n            const directiveInfo = { type: 'custom', expression, customDirective: directive };\n            if (directive.bind) {\n                self._safeExecute(() => directive.bind(element, evaluator(), expression, self, modifiers, evaluator));\n            }\n            const update = () => {\n                if (directive.update)\n                    self._safeExecute(() => directive.update(element, evaluator(), expression, self, modifiers, evaluator));\n            };\n            const effect = self._createEffect(update);\n            directiveInfo.update = effect;\n            self._addDirective(element, directiveInfo);\n        }\n        _bindAttributeDirective(element, attributeName, expression) {\n            const self = this;\n            const evaluator = self._createElementEvaluator(expression, element);\n            if (attributeName === 'class') {\n                const el = element;\n                if (!self._initialClassSets.get(el)) {\n                    const baseSet = new Set();\n                    const oc = el.className || '';\n                    if (oc)\n                        for (const cls of oc.split(/\\s+/)) {\n                            if (cls)\n                                baseSet.add(cls);\n                        }\n                    self._initialClassSets.set(el, baseSet);\n                }\n            }\n            const meta = self._resolveBindingMeta(element, attributeName);\n            const update = () => {\n                const value = evaluator();\n                if (attributeName === 'class') {\n                    const el = element;\n                    const base = self._initialClassSets.get(el);\n                    if (typeof value === 'string') {\n                        el.className = base && base.size ? [...base].join(' ') + (value ? ' ' + value : '') : value || '';\n                    }\n                    else if (ARRAY_ISARRAY(value)) {\n                        if (base && base.size)\n                            el.className = [...base, ...value.filter(Boolean)].join(' ');\n                        else\n                            el.className = value.filter(Boolean).join(' ');\n                    }\n                    else if (value && typeof value === 'object') {\n                        if (base && base.size)\n                            el.className = [...base].join(' ');\n                        for (const raw in value) {\n                            const on = !!value[raw];\n                            if (!raw)\n                                continue;\n                            const tokens = raw.split(/\\s+/);\n                            for (let i = 0; i < tokens.length; i++) {\n                                const tk = tokens[i];\n                                if (!tk)\n                                    continue;\n                                el.classList.toggle(tk, on);\n                            }\n                        }\n                    }\n                    else if (value == null && base && base.size) {\n                        el.className = [...base].join(' ');\n                    }\n                    else if (value == null) {\n                        el.removeAttribute('class');\n                    }\n                    return;\n                }\n                if (attributeName === STR_STYLE) {\n                    const el = element;\n                    if (typeof value === 'string') {\n                        el.style.cssText = value;\n                        return;\n                    }\n                    if (value && typeof value === 'object') {\n                        for (const k in value) {\n                            const v = value[k];\n                            const cssProp = k.startsWith('--') ? k : k.replace(/[A-Z]/g, m => '-' + m.toLowerCase());\n                            if (v != null)\n                                el.style.setProperty(cssProp, String(v));\n                            else\n                                el.style.removeProperty(cssProp);\n                        }\n                        return;\n                    }\n                    if (value == null)\n                        el.removeAttribute('style');\n                    return;\n                }\n                self._applyGenericBinding(element, attributeName, value, meta);\n            };\n            const effect = self._createEffect(update);\n            self._addDirective(element, { type: 'bind', expression, update: effect });\n        }\n        _collectLoopScope(el) {\n            if (!el)\n                return null;\n            if (!el.parentElement) {\n                const cur = el.__x_if_current;\n                if (cur && cur.parentElement) {\n                    el = cur;\n                }\n                else {\n                    const anchorParent = el.__x_if_anchorParent;\n                    if (anchorParent)\n                        el = anchorParent;\n                }\n            }\n            let node = el;\n            while (node) {\n                const s = node.__x_scope;\n                if (s)\n                    return s;\n                node = node.parentElement;\n            }\n            const merged = {};\n            node = el;\n            while (node) {\n                const scope = this._loopScopes.get(node);\n                if (scope)\n                    Object.assign(merged, scope);\n                if (node === this.element)\n                    break;\n                node = node.parentElement;\n            }\n            return _Okeys(merged).length ? merged : null;\n        }\n        _updateElementDirectives(root, force) {\n            for (const [element, directives] of this._directives) {\n                for (const directive of directives) {\n                    if ((root === element || (element instanceof Element && root.contains(element))) && directive.update) {\n                        if (XTOOL_ENABLE_STATIC_DIRECTIVES && directive._static && !force)\n                            continue;\n                        directive.update();\n                    }\n                }\n            }\n        }\n        _updateElementDirectivesForVar(root, varName) {\n            const re = new RegExp('(^|[^$\\\\w])' + varName.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&') + '([^$\\\\w]|$)');\n            for (const [element, directives] of this._directives) {\n                if (!(root === element || (element instanceof Element && root.contains(element))))\n                    continue;\n                for (const directive of directives) {\n                    if (!directive.update)\n                        continue;\n                    const expr = directive.expression || '';\n                    if (re.test(expr)) {\n                        directive.update();\n                    }\n                }\n            }\n        }\n        _cleanupElementSubtree(root) {\n            const toDelete = [];\n            for (const [element, directives] of this._directives) {\n                if (root === element || (element instanceof Element && root.contains(element))) {\n                    for (const directive of directives) {\n                        if (directive.type === 'custom' && directive.customDirective?.unbind) {\n                            try {\n                                directive.customDirective.unbind(element, this);\n                            }\n                            catch { }\n                        }\n                    }\n                    toDelete.push(element);\n                }\n            }\n            if (toDelete.length) {\n                for (const el of toDelete)\n                    this._directives.delete(el);\n            }\n        }\n        _bindForDirective(element, expression) {\n            const self = this;\n            const match = expression.trim().match(/^(?:\\(\\s*([^,\\s]+)\\s*(?:,\\s*([^\\)]+))?\\s*\\)|([^,\\s]+))\\s+(in|of)\\s+(.+)$/);\n            if (!match) {\n                return;\n            }\n            const itemVar = match[1] || match[3];\n            const indexVar = match[2];\n            const listCode = match[5];\n            const keyAttrName = attrName('key');\n            const keyExpr = element.getAttribute(keyAttrName) || null;\n            if (keyExpr)\n                element.removeAttribute(keyAttrName);\n            const placeholder = d.createComment('x-for');\n            element.parentNode?.insertBefore(placeholder, element);\n            let templateToClone;\n            if (element[STR_TAGNAME] === STR_TEMPLATE) {\n                templateToClone = d.createElement('div');\n                templateToClone.style[STR_DISPLAY] = STR_CONTENTS;\n                templateToClone.appendChild(element.content.cloneNode(true));\n                element.parentNode?.removeChild(element);\n            }\n            else {\n                templateToClone = element;\n                element.parentNode?.removeChild(element);\n            }\n            const contextAnchor = placeholder.parentElement || self.element;\n            const listEval = self._createElementEvaluator(listCode.trim(), contextAnchor);\n            const keyEval = keyExpr ? self._createEvaluator(keyExpr) : null;\n            const BP_FOR = attrName('for');\n            const BP_KEY = attrName('key');\n            const BP_TEXT = attrName('text');\n            const BP_HTML = attrName('html');\n            const BP_DATA = attrName('data');\n            const buildBlueprint = (root) => {\n                const bp = [];\n                const walk = (el, path, isRootEl) => {\n                    if (!isRootEl && el.hasAttribute(BP_DATA))\n                        return;\n                    const isComponentTag = el[STR_TAGNAME] === 'COMPONENT';\n                    const scan = self._scanDirectiveAttrs(el, { skipRootFor: isRootEl });\n                    const dnames = scan.names.filter(n => n !== BP_KEY && (!isRootEl || n !== BP_FOR));\n                    const hasTextOrHtml = scan.names.includes(BP_TEXT) || scan.names.includes(BP_HTML);\n                    const forName = scan.forName;\n                    if (dnames.length) {\n                        if (forName) {\n                            bp.push({ path, directiveNames: [forName], hasTextOrHtml: hasTextOrHtml, forName });\n                            return;\n                        }\n                        bp.push({ path, directiveNames: dnames, hasTextOrHtml });\n                    }\n                    else {\n                        if (FT_TI && !hasTextOrHtml) {\n                            bp.push({ path, directiveNames: [], hasTextOrHtml });\n                        }\n                    }\n                    if (isComponentTag)\n                        return;\n                    let idx = 0;\n                    let child = el.firstElementChild;\n                    while (child) {\n                        const next = child.nextElementSibling;\n                        walk(child, path.concat(idx), false);\n                        idx++;\n                        child = next;\n                    }\n                };\n                walk(root, [], true);\n                return bp;\n            };\n            const hydrateFromBlueprint = (cloneRoot, bp) => {\n                for (let i = 0; i < bp.length; i++) {\n                    const instr = bp[i];\n                    const target = this._resolveNodeByPath(cloneRoot, instr.path);\n                    if (instr.forName) {\n                        const expr = target.getAttribute(instr.forName) || '';\n                        self._bindDirective(target, instr.forName, expr);\n                        continue;\n                    }\n                    for (let j = 0; j < instr.directiveNames.length; j++) {\n                        const dn = instr.directiveNames[j];\n                        const expr = target.getAttribute(dn) || '';\n                        if (dn === BP_KEY)\n                            continue;\n                        self._bindDirective(target, dn, expr);\n                    }\n                    if (FT_TI && !instr.hasTextOrHtml)\n                        self._bindTextInterpolationsIn(target);\n                }\n            };\n            const blueprint = buildBlueprint(templateToClone);\n            const instances = [];\n            const createScope = (item, idxOrKey, existing) => {\n                const scope = existing || {};\n                scope[itemVar] = item;\n                if (indexVar)\n                    scope[indexVar] = idxOrKey;\n                return scope;\n            };\n            const objIds = new WeakMap();\n            let objSeq = 0;\n            const extractId = (o) => {\n                if (!o || typeof o !== 'object')\n                    return null;\n                const v = o.id ?? o._id ?? o.key;\n                if (v == null)\n                    return null;\n                const t = typeof v;\n                return (t === 'string' || t === 'number') ? ('id:' + String(v)) : null;\n            };\n            const keyFor = (item) => {\n                if (item && typeof item === 'object') {\n                    const explicit = extractId(item);\n                    if (explicit)\n                        return explicit;\n                    let id = objIds.get(item);\n                    if (!id) {\n                        id = 'o#' + (++objSeq);\n                        objIds.set(item, id);\n                    }\n                    return id;\n                }\n                return 'p#' + (typeof item) + ':' + String(item);\n            };\n            const evalKeyExpr = (item, idxOrKey) => {\n                if (!keyEval)\n                    return null;\n                try {\n                    const base = self._createContextProxy(undefined, contextAnchor);\n                    const ctx = Object.create(base);\n                    ctx[itemVar] = item;\n                    if (indexVar)\n                        ctx[indexVar] = idxOrKey;\n                    const v = keyEval.call(self._createMethodContext(), ctx);\n                    const t = typeof v;\n                    return (t === 'string' || t === 'number') ? v : (v != null ? String(v) : null);\n                }\n                catch {\n                    return null;\n                }\n            };\n            const update = () => {\n                const norm = self._safeExecute(() => {\n                    const result = listEval();\n                    if (_AisArr(result))\n                        return { list: result, keys: null, src: result };\n                    const tag = result && Object.prototype.toString.call(result);\n                    const isMap = typeof Map !== 'undefined' && (result instanceof Map || tag === '[object Map]' || (result && typeof result.get === 'function' && typeof result.set === 'function' && typeof result.keys === 'function'));\n                    if (isMap) {\n                        return { list: _Afrom(result.values()), keys: _Afrom(result.keys()), src: result };\n                    }\n                    const isSet = typeof Set !== 'undefined' && (result instanceof Set || tag === '[object Set]' || (result && typeof result.add === 'function' && typeof result.has === 'function' && typeof result.values === 'function'));\n                    if (isSet) {\n                        return { list: _Afrom(result.values()), keys: null, src: result };\n                    }\n                    if (result && typeof result[Symbol.iterator] === 'function') {\n                        return { list: _Afrom(result), keys: null, src: result };\n                    }\n                    if (result && typeof result === 'object') {\n                        const keys = Object.keys(result);\n                        const list = keys.map(k => result[k]);\n                        return { list, keys, src: result };\n                    }\n                    return { list: [], keys: null, src: null };\n                }, { list: [], keys: null, src: null });\n                const list = norm.list;\n                const keysArr = norm.keys;\n                const oldByObjKey = new Map();\n                const oldPrimQueues = new Map();\n                for (let i = 0; i < instances.length; i++) {\n                    const n = instances[i];\n                    const k = n.__x_for_key;\n                    const ps = n.__x_primSig;\n                    if (ps) {\n                        let q = oldPrimQueues.get(ps);\n                        if (!q) {\n                            q = [];\n                            oldPrimQueues.set(ps, q);\n                        }\n                        q.push(n);\n                    }\n                    else if (k) {\n                        oldByObjKey.set(k, n);\n                    }\n                }\n                const newNodes = new Array(list.length);\n                const parent = placeholder.parentNode;\n                for (let i = 0; i < list.length; i++) {\n                    const item = list[i];\n                    const idxOrKey = keysArr ? keysArr[i] : i;\n                    let node;\n                    let nodeKey;\n                    const explicitKey = keyEval ? evalKeyExpr(item, idxOrKey) : null;\n                    if (explicitKey != null) {\n                        nodeKey = 'k:' + String(explicitKey);\n                        const prev = oldByObjKey.get(nodeKey);\n                        if (prev) {\n                            node = prev;\n                            oldByObjKey.delete(nodeKey);\n                        }\n                    }\n                    if (!node) {\n                        const k = keyFor(item);\n                        if (k && k.startsWith('o#') || (k && k.startsWith('id:'))) {\n                            nodeKey = k;\n                            const prev = oldByObjKey.get(k);\n                            if (prev) {\n                                node = prev;\n                                oldByObjKey.delete(k);\n                            }\n                        }\n                        else if (k && k.startsWith('p#')) {\n                            const ps = k;\n                            const q = oldPrimQueues.get(ps);\n                            if (q && q.length) {\n                                node = q.shift();\n                            }\n                            if (node) {\n                                nodeKey = node.__x_for_key;\n                            }\n                            if (node) {\n                                node.__x_primSig = ps;\n                            }\n                        }\n                    }\n                    if (!node) {\n                        const clone = templateToClone.cloneNode(true);\n                        clone.removeAttribute('x-for');\n                        if (keyExpr)\n                            clone.removeAttribute(keyAttrName);\n                        const initScope = createScope(item, idxOrKey, {});\n                        clone.__x_scope = initScope;\n                        clone.__x_itemRef = item;\n                        if (indexVar)\n                            clone.__x_idxRef = idxOrKey;\n                        self._loopScopes.set(clone, initScope);\n                        try {\n                            hydrateFromBlueprint(clone, blueprint);\n                        }\n                        catch { }\n                        node = clone;\n                        node.__x_for_key = (nodeKey !== undefined) ? nodeKey : ('n#' + (++objSeq));\n                    }\n                    else {\n                        const existingScope = node.__x_scope;\n                        const prevIdxRef = node.__x_idxRef;\n                        const prevItemRef = node.__x_itemRef;\n                        const scope = createScope(item, idxOrKey, existingScope);\n                        node.__x_scope = scope;\n                        self._loopScopes.set(node, scope);\n                        let needsUpdate = false;\n                        if (prevItemRef !== item) {\n                            needsUpdate = true;\n                            node.__x_itemRef = item;\n                        }\n                        const indexChanged = !!indexVar && prevIdxRef !== idxOrKey;\n                        if (indexChanged) {\n                            needsUpdate = true;\n                            node.__x_idxRef = idxOrKey;\n                        }\n                        if (needsUpdate) {\n                            if (indexChanged && indexVar)\n                                self._updateElementDirectivesForVar(node, indexVar);\n                            else\n                                self._updateElementDirectives(node);\n                        }\n                    }\n                    if (nodeKey)\n                        node.__x_for_key = nodeKey;\n                    const sig = (!keyExpr && !(item && typeof item === 'object')) ? ('p#' + (typeof item) + ':' + String(item)) : undefined;\n                    node.__x_primSig = sig;\n                    newNodes[i] = node;\n                }\n                for (const [, node] of oldByObjKey) {\n                    if (node && node.parentNode) {\n                        self._cleanupElementSubtree(node);\n                        node.parentNode.removeChild(node);\n                    }\n                }\n                for (const [, queue] of oldPrimQueues) {\n                    for (const node of queue) {\n                        if (node && node.parentNode) {\n                            self._cleanupElementSubtree(node);\n                            node.parentNode.removeChild(node);\n                        }\n                    }\n                }\n                if (parent) {\n                    const oldIndexMap = new Map();\n                    for (let i = 0; i < instances.length; i++) {\n                        const k = instances[i].__x_for_key;\n                        if (k !== undefined)\n                            oldIndexMap.set(k, i);\n                    }\n                    const seq = new Array(newNodes.length);\n                    for (let i = 0; i < newNodes.length; i++) {\n                        const k = newNodes[i].__x_for_key;\n                        const oldIdx = oldIndexMap.has(k) ? oldIndexMap.get(k) : -1;\n                        seq[i] = oldIdx;\n                    }\n                    const { lisMask: lis } = this._computeLISMask(seq);\n                    const tailAnchor = instances.length ? (instances[instances.length - 1].nextSibling) : placeholder.nextSibling;\n                    let anchor = null;\n                    for (let i = newNodes.length - 1; i >= 0; i--) {\n                        const node = newNodes[i];\n                        const ref = anchor ?? tailAnchor;\n                        if (seq[i] === -1) {\n                            parent.insertBefore(node, ref);\n                        }\n                        else if (!lis[i]) {\n                            parent.insertBefore(node, ref);\n                        }\n                        anchor = node;\n                    }\n                }\n                instances.length = 0;\n                for (let i = 0; i < newNodes.length; i++)\n                    instances.push(newNodes[i]);\n            };\n            const dir = { type: 'for', expression };\n            const effect = self._createEffect(update, dir);\n            dir.update = effect;\n            self._addDirective(placeholder, dir);\n        }\n        _resolveNodeByPath(root, path) {\n            let node = root;\n            for (let i = 0; i < path.length; i++) {\n                let idx = 0;\n                let child = node.firstElementChild;\n                while (child && idx < path[i]) {\n                    child = child.nextElementSibling;\n                    idx++;\n                }\n                node = child || node;\n            }\n            return node;\n        }\n        _computeLISMask(seq) {\n            const predecessors = new Array(seq.length);\n            const tails = [];\n            const tailIdx = [];\n            for (let i = 0; i < seq.length; i++) {\n                const v = seq[i];\n                if (v < 0) {\n                    predecessors[i] = -1;\n                    continue;\n                }\n                let lo = 0, hi = tails.length;\n                while (lo < hi) {\n                    const mid = (lo + hi) >> 1;\n                    if (seq[tails[mid]] < v)\n                        lo = mid + 1;\n                    else\n                        hi = mid;\n                }\n                if (lo === tails.length) {\n                    tails.push(i);\n                }\n                else {\n                    tails[lo] = i;\n                }\n                predecessors[i] = lo > 0 ? tails[lo - 1] : -1;\n                tailIdx[lo] = i;\n            }\n            const lisLen = tails.length;\n            const lis = new Array(seq.length).fill(false);\n            let k = lisLen ? tails[lisLen - 1] : -1;\n            while (k >= 0) {\n                lis[k] = true;\n                k = predecessors[k];\n            }\n            return { lisMask: lis, lisLen };\n        }\n        _render() {\n            const self = this;\n            for (const directives of self._directives.values()) {\n                for (const dr of directives) {\n                    if (XTOOL_ENABLE_STATIC_DIRECTIVES && dr._static)\n                        continue;\n                    if (dr.update) {\n                        try {\n                            dr.update();\n                        }\n                        catch (error) {\n                            if (!(error instanceof ReferenceError)) { }\n                        }\n                    }\n                }\n            }\n        }\n    }\n    ReactiveComponent._BA = {\n        itemscope: 1, formnovalidate: 1, novalidate: 1, default: 1, readonly: 1\n    };\n    const xTool = new XToolFramework();\n    return xTool;\n}();\nif (typeof window !== 'undefined') {\n    const w = window;\n    w.XTool = XToolFramework;\n    w.FyneJS = XToolFramework;\n}\n//# sourceMappingURL=x-tool.js.map"],"mappings":"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","ignoreList":[]}
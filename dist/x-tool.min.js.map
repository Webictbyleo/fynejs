{"version":3,"names":["stripTypes","caseKebabToCamel","silentError","makeReactive","makeComputed","isComputedRef","isReactive","getReactiveControl","setReactiveControl","unwrapReactive","Router","ARRAY_ISARRAY","Array","isArray","WkMap","WeakMap","quMct","queueMicrotask","FT_EXT_DIRS","__FEAT_EXT_DIRECTIVES__","XToolFramework","_se","_tr","s","trim","_Afrom","from","_AisArr","_Okeys","Object","keys","STR_STYLE","STR_DISPLAY","STR_NONE","STR_TAGNAME","STR_TEMPLATE","STR_LENGTH","STR_SOURCE","STR_READONLY","XTOOL_ENABLE_STATIC_DIRECTIVES","d","document","STR_CONTENTS","EV_DELEGATED","head","getElementById","style","createElement","id","textContent","appendChild","PFX","attrCache","Map","attrName","name","cached","get","value","set","ReactiveComponent","attachToParent","parent","this","_parent","_addChild","_id","framework","_framework","element","_element","el","isBound","_isBound","v","isMounted","_isMounted","isDestroyed","_isDestroyed","_setActiveEffect","effect","_activeEffect","_bridgeUtilReactive","prop","obj","control","prevDep","depTracker","prevBase","baseChangeListener","trackerId","k","_isInComputedEvaluation","_computedKeyStack","length","current","_computedDeps","Set","add","oldVal","newVal","_onDataChange","_abortInvokerResources","byKind","_invokerResources","values","cleanup","clear","_cancelUserResources","_resolveBindingMeta","attributeName","elAny","propName","camel","replace","_","c","toUpperCase","toLowerCase","isBooleanProp","hasNonFunctionProp","isKnownBooleanAttr","_BA","_applyGenericBinding","meta","boolVal","setAttribute","removeAttribute","normalized","parts","push","join","String","getAttribute","_scanDirectiveAttrs","opts","prefixDash","prefixColon","namesOut","hasTextOrHtml","forName","names","getAttributeNames","i","startsWith","skipRootFor","setFrozen","on","_isFrozen","_sealedBeforeFreeze","_isSealed","_scheduleRender","_setSealed","_addDirective","directive","existing","_directives","constructor","def","initialScopes","_propUpdateActive","_runningPropEffect","_initialContextScopes","_beforeMountCalled","_children","_computed","_propEffects","_computedCache","_computedRefControls","_isInMethodExecution","_allEffects","_hasComputed","_cleanupFunctions","_directiveAbort","AbortController","_targetIds","_targetSeq","_signalHandlers","_isMutationEnabled","_mutateDirty","_effectsToRun","_currentInvoker","_loopScopes","_expressionCache","_propertyDependencies","_renderScheduled","_nextTickQueue","_changeFrameId","_renderFrameId","_initialClassSets","_rawData","_propParent","_callLifecycleHook","hookName","hook","_lifecycle","_safeExecute","_runWithGlobalInterception","_xInitExpr","expr","isConnected","runner","trimmed","arrow","_extractArrowFunction","ctx","_createMethodContext","fn","_compileArrowForEvent","paramsList","body","isBlock","args","out","call","_createContextProxy","undefined","slice","_addCleanupFunction","result","_createEvaluator","indexOf","wrapped","delete","_originalMethods","methods","_bindComputed","computed","propEffects","_bindPropEffects","mounted","unmounted","destroyed","updated","beforeMount","beforeUnmount","beforeDestroy","setup","_cloneData","data","_data","_createReactiveData","_methods","_bindMethods","seen","has","arr","Date","getTime","RegExp","source","flags","m","forEach","st","proto","getPrototypeOf","prototype","create","key","callBeforeMount","_property","self","cancelAnimationFrame","effectsToRun","directDeps","size","queue","visited","affectedComputed","queueIdx","base","compKey","baseDeps","entries","compEffects","ctrl","requestAnimationFrame","_bindFunctionMap","src","kind","original","prev","prevInv","newValue","oldValue","prevFlag","_getComputedValue","_trackDependency","getter","pop","e","propKey","activeEff","deps","includes","stackLen","_render","q","splice","fallback","error","bindToElement","completeBinding","getContext","includeComputed","_applyAsyncTemplateResolved","_parseDirectives","_getComponentByElement","_registerElement","child","_removeChild","index","_setXInitExpr","test","wrapper","Function","thisArg","apply","destroy","directives","type","customDirective","unbind","abort","_runCleanupCallbacks","_propEffect","idx","_unregisterElement","_clearComponentRefs","_deepReactiveCache","_unregisterComponent","_onSignal","handler","_offSignal","_emitSignal","payload","evt","_stopped","stopPropagation","cur","h","_initReactiveProps","evalFn","lastPropValues","isFirstRun","update","$props","autoMerge","_autoMergeProps","eff","_listen","event","options","signal","addEventListener","capture","merged","_targetKey","target","toString","processElement","isRoot","hasAttribute","isComponentTag","directiveNames","_bindDirective","attr","_bindTextInterpolationsIn","_walkElements","nodes","childNodes","node","nodeType","Node","TEXT_NODE","textNode","raw","nodeValue","__x_ti_bound","segs","charCodeAt","run","start","close","text","repeat","code","nextEsc","nextOpen","end","some","literalOut","map","evaluators","_createElementEvaluator","ei","dirInfo","expression","_createEffect","processor","firstElementChild","next","nextElementSibling","directiveName","isAtEvent","isShortBind","_bindAttributeDirective","modifiers","split","filter","Boolean","reduce","acc","_bindTransitionDirective","_bindSimpleDirective","_bindRefDirective","_bindIfDirective","_bindForDirective","_bindModelDirective","prefix","rest","suffix","mods","_getCustomDirective","_bindCustomDirective","_bindEventDirective","part","enter","leave","_bindIntersectDirective","refName","_registerComponentRef","dir","_getSharedRef","ref","_getComponentRefs","phase","runExpr","_compileHandler","once","rootMargin","onEnter","cb","entry","info","onLeave","unobserve","_ioObserve","updateFn","directiveRef","_static","found","config","__x_transition","val","toggle","after","exprStr","afterEnterRunner","afterLeaveRunner","afterRunner","_applyShowWithTransition","show","originalDisplay","onDone","setProperty","removeProperty","cfg","imp","__x_t","cancel","duration","easing","cls","classList","rm","remove","effectiveMs","fallbackMs","cs","window","getComputedStyle","parseTimes","x","endsWith","parseFloat","n","isNaN","maxT","durations","delays","Math","max","t","sumMax","transitionDuration","transitionDelay","aDur","animationDuration","aDel","animationDelay","iters","animationIterationCount","nA","maxA","dl","it","finishers","waitEnd","done","ended","off","onEnd","to","setTimeout","removeEventListener","clearTimeout","invokeAfter","msUsed","startClassBased","A","F","enterFrom","leaveFrom","T","enterTo","leaveTo","offsetWidth","ms","startStyleFade","prevTransition","transition","prevOpacity","opacity","_bindTemplateShowDirective","evaluator","_prevShown","isDirty","innerHTML","template","content","cloneNode","parentNode","insertBefore","removeChild","_discoverNestedNamed","property","isCheckbox","isNumeric","isMultiSelect","tagName","multiple","getValueEvaluator","setValueEvaluator","checkboxValue","loopScope","_collectLoopScope","inferCheckboxValue","member","checked","sel","selected","setInputValue","eventType","currentData","getInputValue","currentVal","$value","placeholder","createComment","__x_if_anchorParent","parentElement","branches","makeActualElement","isTemplate","first","firstOD","firstEval","__x_tool_bound","originalNodes","sib","isElse","isElseIf","branch","od","active","orig","mountBranch","b","anchorParent","parentScope","__x_scope","__x_if_current","nextSibling","unmountBranch","eventName","passive","onlySelf","shouldPrevent","prevent","shouldStop","stop","isOutside","outside","isWindow","deferExec","defer","keyAliasMap","esc","escape","space","tab","backspace","del","arrowup","arrowdown","arrowleft","arrowright","home","pageup","pagedown","comboRequirements","alt","shift","buttonMap","left","middle","right","touchSingle","single","touchMulti","multi","modifierKeys","allowedKeys","aliases","allowedButtons","btn","needKeyCheck","needButtonCheck","needTouchCheck","passesFilters","path","composedPath","tgt","contains","TouchEvent","tCount","touches","MouseEvent","button","KeyboardEvent","ctrlKey","altKey","shiftKey","metaKey","ev","createEventHandler","preventDefault","canDelegate","_getConfig","delegate","ownerDocument","remover","_registerDelegated","comp","isStatement","JSON","stringify","compiled","match","params","p","mapArgs","thisCtx","compiledArrow","executor","_assertMutable","parentKey","method","Error","_wrapData","isArr","isSet","isMap","makeCollectionWrapper","beforeLen","beforeFirst","beforeLast","before","existed","proxy","Proxy","receiver","isCollection","Symbol","iterator","Reflect","bind","ownKeys","had","defineProperty","configurable","enumerable","writable","deleteProperty","ok","pc","_includeComputed","specials","$log","$destroy","$forceUpdate","$addCleanupFunction","Signals","emit","connect","disconnect","$nextTick","Promise","resolve","$el","$id","$refs","_t","$ref","$isMounted","$isDestroyed","$isSealed","$isFrozen","$parent","$children","$seal","$mutate","prevMethod","_target","propStr","targetElement","component","mergedScope","scopes","gWindow","gDocument","sandbox","sandboxExpressions","allow","allowGlobals","ensureInvoker","registerResource","inv","wrapTarget","optSig","querySelector","querySelectorAll","doc","win","defaultView","wrapObserverCtor","Orig","observerArgs","observe","inst","$target","$event","_routerEnabled","location","_navigate","href","setInterval","clearInterval","MutationObserver","ResizeObserver","IntersectionObserver","hasOwnProperty","_name","directiveInfo","isSvg","namespaceURI","baseSet","oc","className","finalCls","tokens","finalStr","classState","tk","finalClasses","baseStr","cssText","cssProp","scope","assign","_updateElementDirectives","root","force","Element","_updateElementDirectivesForVar","varName","re","_cleanupElementSubtree","toDelete","itemVar","indexVar","listCode","keyAttrName","keyExpr","templateToClone","contextAnchor","listEval","keyEval","BP_FOR","BP_KEY","BP_TEXT","BP_HTML","BP_DATA","hydrateFromBlueprint","cloneRoot","bp","instr","_resolveNodeByPath","j","dn","blueprint","walk","isRootEl","scan","dnames","concat","buildBlueprint","instances","createScope","item","idxOrKey","objIds","objSeq","keyFor","explicit","o","extractId","evalKeyExpr","setNestedScopes","initScope","firstEl","hasData","_bindInlineComponent","norm","list","tag","keysArr","oldByObjKey","oldPrimQueues","__x_for_key","ps","__x_primSig","newNodes","nodeKey","explicitKey","existingScope","prevIdxRef","__x_idxRef","prevItemRef","__x_itemRef","needsUpdate","indexChanged","clone","sig","oldIndexMap","seq","oldIdx","lisMask","lis","_computeLISMask","tailAnchor","anchor","_processPending","lisLen","predecessors","tails","tailIdx","lo","hi","mid","fill","dr","ReferenceError","itemscope","formnovalidate","novalidate","default","readonly","_components","_byEl","_pending","_config","_customDirectives","_currentArrayInterceptorComp","_namedComponentDefs","_delegated","_delegatedRootBound","_refsRegistry","_refCleanupRegistry","_propExpressions","compRefs","refSet","_runRefCleanup","registerComponent","definition","_getRegisteredComponentDef","_preDiscoveryTasks","init","container","debug","staticDirectives","router","enabled","transitionName","autoMergeProps","_hpf","async","_applyPrefixInitialCSS","allSettled","_autoDiscoverComponents","_ensureRootObserver","_ensureDelegation","_installRouting","readyState","_inflightComponentLoads","_lazyComponentSources","loadComponents","sources","items","mode","tasks","_fetchAndEvalComponent","catch","then","inferredName","status","results","settled","failed","r","createComponent","_generateComponentId","dataAttr","_bindElementAsComponent","componentElements","reusable","_instantiateNamedComponent","components","lastComponent","remaining","ready","containerEl","maybe","parentForEval","dataExpression","parentCtx","makeCtx","evalCtx","_parseDataExpression","desc","getOwnPropertyDescriptors","plainData","dsc","hasOwnMethods","methodsObj","detectedMethods","lifecycleKeys","lifecycle","lk","mergedMethods","initExpr","_finalizeComponentMount","xInitExpr","now","random","substring","parentHint","hosts","host","componentId","_log","install","navigate","url","retries","baseDelay","maxDelay","urlObj","URL","baseURI","isTypeScript","pathname","isHTMLComponent","html","strings","str","inner","innerCtrl","refCtrl","changeListeners","oldSnap","newSnap","l","getOwnPropertyDescriptor","resolveFn","rejectFn","resolved","attemptIndex","timer","onlineListener","computeDelay","min","pow","clearResources","attempt","currentN","fetch","cache","res","statusText","scriptContent","templateHTML","hasSetup","parsed","DOMParser","parseFromString","sc","tplEl","lifecycles","onMounted","onBeforeMount","onUnmounted","onBeforeUnmount","expose","watch","readVal","srcs","ctrls","listeners","oldVals","scheduled","fire","newVals","oldV","listener","newV","exec","dataObj","computedObj","lifecycleDef","err","isOnline","navigator","onLine","msg","message","networkLike","TypeError","delay","reject","finally","_rootObserver","records","addedNodes","removedNodes","stack","_onComponentSourceChanged","ro","childList","subtree","attributes","attributeFilter","_ensureIO","_ioObservers","_ioRegistry","io","reg","isIntersecting","visible","a","parentComp","par","evaluated","lazy","promise","props","dynamicPropObj","rawPropExpression","propExpr","propPrefix","modifierPropExpressions","resolvePropName","lower","tryMatch","ctxProxy","existingDynamic","modifierKeysToAppend","closeIndex","lastIndexOf","needsComma","appended","allKeys","Initialscopes","initDef","baseData","makeData","compDef","originalChildren","replaceChildren","applyTemplate","tpl","slots","slotEl","matched","replaceWith","tplVal","append","nested","cancelBubble","captureEvents","bubbleEvents","w","XTool","FyneJS"],"sourceRoot":"./dist","sources":["dist/x-tool.js"],"sourcesContent":["import stripTypes from './src/strip-ts';\nimport { caseKebabToCamel, silentError, makeReactive, makeComputed, isComputedRef, isReactive, getReactiveControl, setReactiveControl, unwrapReactive } from './src/util';\nimport { Router } from './src/router';\nconst ARRAY_ISARRAY = Array.isArray;\nconst WkMap = WeakMap;\nconst quMct = queueMicrotask;\nconst FT_C = true;\nconst FT_TI = typeof __FEAT_TEXT_INTERP__ === 'boolean' ? __FEAT_TEXT_INTERP__ : true;\nconst _FT_DR = typeof __FEAT_DEEP_REACTIVE__ === 'boolean' ? __FEAT_DEEP_REACTIVE__ : true;\nconst FT_IFB = typeof __FEAT_IF_BRANCHES__ === 'boolean' ? __FEAT_IF_BRANCHES__ : true;\nconst FT_RT = typeof __FEAT_ROUTER__ === 'boolean' ? __FEAT_ROUTER__ : true;\nconst FT_TS = typeof __FEAT_TS__ === 'boolean' ? __FEAT_TS__ : true;\nconst FT_EXT_DIRS = typeof __FEAT_EXT_DIRECTIVES__ === 'boolean' ? __FEAT_EXT_DIRECTIVES__ : true;\nconst XToolFramework = function () {\n    const _se = silentError;\n    const _tr = (s) => (s || '').trim();\n    const _Afrom = Array.from;\n    const _AisArr = ARRAY_ISARRAY;\n    const _Okeys = Object.keys;\n    const STR_STYLE = 'style';\n    const STR_DISPLAY = 'display';\n    const STR_NONE = 'none';\n    const STR_TAGNAME = 'tagName';\n    const STR_TEMPLATE = 'TEMPLATE';\n    const STR_LENGTH = 'length';\n    const STR_SOURCE = 'source';\n    const STR_READONLY = 'readonly';\n    let XTOOL_ENABLE_STATIC_DIRECTIVES = true;\n    const d = (typeof document !== 'undefined' ? document : null);\n    const STR_CONTENTS = 'contents';\n    const EV_CLICK = 'click', EV_INPUT = 'input', EV_CHANGE = 'change', EV_KEYDOWN = 'keydown', EV_KEYUP = 'keyup';\n    const EV_DELEGATED = [EV_CLICK, EV_INPUT, EV_CHANGE, EV_KEYDOWN, EV_KEYUP];\n    const LS_PENDING = 0, LS_LOADING = 1, LS_LOADED = 2, LS_ERROR = 3;\n    try {\n        if (d && d.head && !d.getElementById('x-tool-initial-css')) {\n            const style = d.createElement(STR_STYLE);\n            style.id = 'x-tool-initial-css';\n            style.textContent = '[x-show],[x-if],[x-else],[x-else-if],[x\\\\:show],[x\\\\:if],[x\\\\:else],[x\\\\:else-if]{display:none;}';\n            d.head.appendChild(style);\n        }\n    }\n    catch { }\n    let PFX = 'x';\n    let attrCache = new Map();\n    const attrName = (name) => {\n        const cached = attrCache.get(name);\n        if (cached)\n            return cached;\n        const value = `${PFX}-${name}`;\n        attrCache.set(name, value);\n        return value;\n    };\n    class XToolFramework {\n        constructor() {\n            this._components = new Map();\n            this._byEl = new WkMap();\n            this._pending = [];\n            this._config = {};\n            this._customDirectives = new Map();\n            this._autoMergeProps = false;\n            this._currentArrayInterceptorComp = null;\n            this._namedComponentDefs = new Map();\n            this._delegated = new WkMap();\n            this._delegatedRootBound = false;\n            this._refsRegistry = new WkMap();\n            this._refCleanupRegistry = new WkMap();\n            this._propExpressions = new WkMap();\n            this._getComponentRefs = (comp, refName) => {\n                const compRefs = this._refsRegistry.get(comp);\n                return compRefs?.get(refName);\n            };\n            this._registerComponentRef = (comp, refName, el) => {\n                if (!FT_EXT_DIRS)\n                    return;\n                let compRefs = this._refsRegistry.get(comp);\n                if (!compRefs) {\n                    compRefs = new Map();\n                    this._refsRegistry.set(comp, compRefs);\n                }\n                let refSet = compRefs.get(refName);\n                if (!refSet) {\n                    refSet = new Set();\n                    compRefs.set(refName, refSet);\n                }\n                if (refSet.has(el))\n                    return;\n                refSet.add(el);\n                if (el instanceof Element === false)\n                    return;\n                this._refCleanupRegistry.set(el, () => {\n                    refSet.delete(el);\n                    if (refSet.size === 0) {\n                        compRefs.delete(refName);\n                    }\n                    if (compRefs.size === 0) {\n                        this._refsRegistry.delete(comp);\n                    }\n                });\n            };\n            this._runRefCleanup = (el) => {\n                const cleanup = this._refCleanupRegistry.get(el);\n                if (cleanup) {\n                    cleanup();\n                    this._refCleanupRegistry.delete(el);\n                }\n            };\n            this._clearComponentRefs = (comp) => {\n                this._refsRegistry.delete(comp);\n            };\n            this.directive = (name, directive) => {\n                if (name.startsWith(PFX + '-')) {\n                    throw new Error(`Custom directive names should not start with \"${PFX}-\". Use: XTool.directive(\"my-directive\", ...)`);\n                }\n                this._customDirectives.set(name, directive);\n                return this;\n            };\n            this.registerComponent = (definition) => {\n                if (!definition || !definition.name)\n                    throw new Error('registerComponent requires a name');\n                const name = definition.name.toLowerCase();\n                if (this._namedComponentDefs.has(name))\n                    return this;\n                this._namedComponentDefs.set(name, definition);\n                return this;\n            };\n            this._getRegisteredComponentDef = (name) => this._namedComponentDefs.get(name.toLowerCase());\n            this._getCustomDirective = (name) => this._customDirectives.get(name);\n            this._getConfig = () => this._config;\n            this._preDiscoveryTasks = [];\n            this.init = (config = {}) => {\n                const base = { container: 'body', debug: false, staticDirectives: true, router: { enabled: false, transitionName: 'route' } };\n                this._config = { ...base, ...config, router: { ...base.router, ...(config.router || {}) } };\n                if (typeof this._config.staticDirectives === 'boolean') {\n                    XTOOL_ENABLE_STATIC_DIRECTIVES = this._config.staticDirectives;\n                }\n                this._autoMergeProps = this._config.autoMergeProps === true;\n                const _hpf = this._config.prefix;\n                if (_hpf && typeof _hpf === 'string' && _hpf[STR_LENGTH] > 0) {\n                    PFX = _hpf;\n                }\n                else {\n                    PFX = 'x';\n                }\n                attrCache.clear();\n                const start = async () => {\n                    this._applyPrefixInitialCSS();\n                    if (this._preDiscoveryTasks.length) {\n                        _se(async () => await Promise.allSettled(this._preDiscoveryTasks));\n                    }\n                    this._autoDiscoverComponents();\n                    const c = d?.querySelector(this._config.container);\n                    if (c) {\n                        this._ensureRootObserver(c);\n                        if (this._config.delegate)\n                            this._ensureDelegation(c);\n                        if (FT_RT && this._routerEnabled())\n                            this._installRouting(c);\n                    }\n                };\n                if (d && d.readyState === 'loading') {\n                    d.addEventListener('DOMContentLoaded', () => { void start(); });\n                }\n                else if (!d || d.readyState === 'complete' || d.readyState === 'interactive') {\n                    void start();\n                }\n                return this;\n            };\n            this._inflightComponentLoads = new Map();\n            this._lazyComponentSources = new Map();\n            this.loadComponents = (sources) => {\n                const items = sources.map(s => typeof s === 'string' ? { path: s, mode: 'preload', name: undefined } : { path: s.path, mode: (s.mode || 'preload'), name: s.name });\n                const tasks = [];\n                for (const it of items) {\n                    if (it.mode === 'defer') {\n                        const p = this._fetchAndEvalComponent(it.path).catch(() => { throw new Error('load failed'); });\n                        this._preDiscoveryTasks.push(p);\n                        tasks.push(p.then(() => { }));\n                    }\n                    else if (it.mode === 'lazy') {\n                        const inferredName = (it.name || it.path.split('/').pop() || '').replace(/\\.(mjs|js|ts|html)(\\?.*)?$/i, '').toLowerCase();\n                        if (inferredName && !this._lazyComponentSources.has(inferredName)) {\n                            this._lazyComponentSources.set(inferredName, { path: it.path, status: LS_PENDING });\n                        }\n                    }\n                    else {\n                        const p = this._fetchAndEvalComponent(it.path).catch(() => { throw new Error('load failed'); });\n                        tasks.push(p);\n                    }\n                }\n                return Promise.allSettled(tasks).then(results => {\n                    _se(() => this._autoDiscoverComponents());\n                    const settled = results.length;\n                    const failed = results.filter(r => r.status === 'rejected').length;\n                    return { settled, failed };\n                });\n            };\n            this.createComponent = (definition, initialScopes) => {\n                const component = new ReactiveComponent(this._generateComponentId(), definition, this, initialScopes);\n                this._components.set(component.id, component);\n                component.callBeforeMount();\n                return component;\n            };\n            this._autoDiscoverComponents = () => {\n                const container = d?.querySelector(this._config.container);\n                if (!container)\n                    return;\n                const dataAttr = attrName('data');\n                if (container.hasAttribute(dataAttr) && !this._getComponentByElement(container)) {\n                    this._bindElementAsComponent(container, undefined);\n                }\n                const componentElements = container.querySelectorAll(`[${dataAttr}]`);\n                for (const element of componentElements) {\n                    if (!this._getComponentByElement(element))\n                        this._bindElementAsComponent(element);\n                }\n                const reusable = container.querySelectorAll('component[source]');\n                for (const el of reusable) {\n                    if (!this._getComponentByElement(el))\n                        this._instantiateNamedComponent(el);\n                }\n                this._processPending();\n                if (componentElements[STR_LENGTH] === 0 && !this._getComponentByElement(container)) {\n                    const components = _Afrom(this._components.values());\n                    const lastComponent = components[components[STR_LENGTH] - 1];\n                    if (lastComponent && !lastComponent.isBound) {\n                        lastComponent.bindToElement(container);\n                    }\n                }\n            };\n            this._processPending = () => {\n                if (!this._pending[STR_LENGTH])\n                    return;\n                const remaining = [];\n                const ready = [];\n                const containerEl = (this._config.container ? d?.querySelector(this._config.container) : null);\n                for (const p of this._pending) {\n                    if (!p.el.isConnected) {\n                        remaining.push(p);\n                        continue;\n                    }\n                    let cur = p.el.parentElement;\n                    let parent;\n                    while (cur && !parent) {\n                        const maybe = this._getComponentByElement(cur);\n                        if (maybe)\n                            parent = maybe;\n                        else\n                            cur = cur.parentElement;\n                    }\n                    if (parent) {\n                        p.comp.attachToParent(parent);\n                        ready.push(p.comp);\n                    }\n                    else if (containerEl && (containerEl === p.el || containerEl.contains(p.el))) {\n                        ready.push(p.comp);\n                    }\n                    else {\n                        remaining.push(p);\n                    }\n                }\n                for (const c of ready)\n                    c.completeBinding();\n                this._pending = remaining;\n            };\n            this._bindInlineComponent = (element, parentForEval) => {\n                this._bindElementAsComponent(element, parentForEval);\n            };\n            this._bindElementAsComponent = (element, parentForEval) => {\n                const dataExpression = element.getAttribute(attrName('data'));\n                let data = {};\n                if (dataExpression) {\n                    element.removeAttribute(attrName('data'));\n                    try {\n                        if (parentForEval) {\n                            let parentCtx = {};\n                            const makeCtx = parentForEval._createContextProxy || parentForEval._createMethodContext;\n                            if (typeof makeCtx === 'function') {\n                                parentCtx = makeCtx.call(parentForEval, undefined, element);\n                            }\n                            const scope = element.__x_scope;\n                            const evalCtx = {};\n                            if (scope && typeof scope === 'object')\n                                Object.assign(evalCtx, scope);\n                            if (parentCtx && typeof parentCtx === 'object')\n                                Object.assign(evalCtx, parentCtx);\n                            const evalFn = new Function('ctx', `with(ctx){ return (${dataExpression}) }`);\n                            data = evalFn(evalCtx);\n                        }\n                        else {\n                            data = this._parseDataExpression(dataExpression);\n                        }\n                        const desc = Object.getOwnPropertyDescriptors(data);\n                        const computed = {};\n                        const plainData = {};\n                        for (const key in desc) {\n                            const dsc = desc[key];\n                            if (typeof dsc.get === 'function') {\n                                computed[key] = dsc.get;\n                            }\n                            else if ('value' in dsc) {\n                                plainData[key] = dsc.value;\n                            }\n                        }\n                        const hasOwnMethods = plainData.methods || data.methods;\n                        const methodsObj = data.methods || {};\n                        const detectedMethods = {};\n                        for (const k of Object.keys(plainData)) {\n                            const v = plainData[k];\n                            if (typeof v === 'function' && k !== 'methods') {\n                                detectedMethods[k] = v;\n                            }\n                        }\n                        for (const k of Object.keys(detectedMethods))\n                            delete plainData[k];\n                        const lifecycleKeys = ['mounted', 'unmounted', 'beforeMount', 'beforeUnmount', 'updated', 'destroyed', 'beforeDestroy', 'setup'];\n                        const lifecycle = {};\n                        for (const lk of lifecycleKeys) {\n                            if (detectedMethods[lk]) {\n                                lifecycle[lk] = detectedMethods[lk];\n                                delete detectedMethods[lk];\n                            }\n                        }\n                        const mergedMethods = { ...methodsObj, ...detectedMethods };\n                        const def = (hasOwnMethods || Object.keys(detectedMethods).length)\n                            ? { methods: mergedMethods, data: plainData }\n                            : { data: plainData };\n                        for (const lk in lifecycle)\n                            def[lk] = lifecycle[lk];\n                        if (_Okeys(computed).length)\n                            def.computed = computed;\n                        if (parentForEval) {\n                            def.data.$parent = parentForEval;\n                        }\n                        data = def;\n                    }\n                    catch (e) {\n                    }\n                }\n                const comp = this.createComponent(data);\n                const initExpr = element.getAttribute(attrName('init')) || undefined;\n                if (initExpr)\n                    element.removeAttribute(attrName('init'));\n                this._finalizeComponentMount(element, comp, { callBeforeMount: true, xInitExpr: initExpr });\n            };\n            this._generateComponentId = () => {\n                const now = Date.now();\n                const random = Math.random().toString(36).substring(2, 15);\n                const counter = (this._components.size + 1).toString(36);\n                return `component_${now}_${counter}_${random}`;\n            };\n            this._discoverNestedNamed = (root, parentHint) => {\n                try {\n                    const hosts = [];\n                    if (root[STR_TAGNAME] === 'COMPONENT' && root.hasAttribute('source'))\n                        hosts.push(root);\n                    const found = root.querySelectorAll('component[source]');\n                    for (const el of found) {\n                        hosts.push(el);\n                    }\n                    for (const host of hosts) {\n                        if (!this._getComponentByElement(host)) {\n                            this._instantiateNamedComponent(host, parentHint);\n                        }\n                    }\n                }\n                catch { }\n            };\n            this._parseDataExpression = (expression) => {\n                return _se(() => new Function('return ' + expression.trim())(), {});\n            };\n            this._unregisterComponent = (componentId) => { this._components.delete(componentId); };\n            this._log = (..._args) => { };\n            this._registerElement = (element, component) => {\n                this._byEl.set(element, component);\n            };\n            this._unregisterElement = (element) => { this._byEl.delete(element); };\n        }\n        _routerEnabled() { const c = this._config; return !!(c.router?.enabled); }\n        _installRouting(root) {\n            if (!FT_RT)\n                return;\n            const { install, navigate } = Router(this._config, this);\n            install(root);\n            this.navigate = navigate;\n        }\n        async _navigate(url, push, source = 'program') {\n            if (!this.navigate)\n                return;\n            return this.navigate(url, push, source);\n        }\n        _fetchAndEvalComponent(path, retries = 2, baseDelay = 300, maxDelay = 30000) {\n            const existing = this._inflightComponentLoads.get(path);\n            if (existing)\n                return existing;\n            const self = this;\n            const urlObj = new URL(path, d?.baseURI || location.href);\n            const isTypeScript = /\\.ts?$/.test(urlObj.pathname);\n            if (isTypeScript && !FT_TS)\n                throw new Error(`TypeScript component loading is not enabled in tiny builds. Loading failed for: ${path} failed.`);\n            const isHTMLComponent = /\\.html?$/.test(urlObj.pathname);\n            const html = (strings, ...values) => strings.reduce((acc, str, i) => acc + str + (i < values.length ? values[i] : ''), '') + `\\n`;\n            const data = (init) => {\n                try {\n                    if (isReactive(init) || isComputedRef(init))\n                        return init;\n                }\n                catch { }\n                if (!init || typeof init !== 'object')\n                    return makeReactive({ value: init });\n                const inner = makeReactive(init);\n                const ref = makeReactive({ value: inner });\n                try {\n                    const innerCtrl = getReactiveControl(inner);\n                    const refCtrl = getReactiveControl(ref);\n                    if (innerCtrl && refCtrl) {\n                        if (!innerCtrl.changeListeners)\n                            innerCtrl.changeListeners = [];\n                        innerCtrl.changeListeners.push((_old, _new) => {\n                            if (Array.isArray(refCtrl.changeListeners)) {\n                                const oldSnap = unwrapReactive(inner);\n                                const newSnap = unwrapReactive(inner);\n                                for (const l of refCtrl.changeListeners) {\n                                    try {\n                                        l(oldSnap, newSnap);\n                                    }\n                                    catch { }\n                                }\n                            }\n                        });\n                    }\n                }\n                catch { }\n                const proxy = new Proxy(ref, {\n                    get: (r, k) => (k === 'value' ? r.value : r.value?.[k]),\n                    set: (r, k, v) => { try {\n                        if (r.value)\n                            r.value[k] = v;\n                        return true;\n                    }\n                    catch {\n                        return false;\n                    } },\n                    has: (r, k) => (k === 'value') || (r.value ? (k in r.value) : false),\n                    ownKeys: (r) => (r.value ? Reflect.ownKeys(r.value) : []),\n                    getOwnPropertyDescriptor: (r, k) => {\n                        if (k === 'value')\n                            return { configurable: true, enumerable: true, value: r.value, writable: true };\n                        const val = r.value;\n                        return val ? (Object.getOwnPropertyDescriptor(val, k) || { configurable: true, enumerable: true, value: val[k], writable: true }) : undefined;\n                    }\n                });\n                try {\n                    const ctrl = getReactiveControl(ref);\n                    if (ctrl)\n                        setReactiveControl(proxy, ctrl);\n                }\n                catch { }\n                return proxy;\n            };\n            const computed = (getter) => makeComputed(getter);\n            let resolved = false;\n            let attemptIndex = 0;\n            let timer = null;\n            let onlineListener = null;\n            let resolveFn;\n            let rejectFn;\n            const computeDelay = (n) => Math.min(maxDelay, (baseDelay * Math.pow(2, n)) * (0.75 + Math.random() * 0.5));\n            const clearResources = () => {\n                if (timer != null) {\n                    clearTimeout(timer);\n                    timer = null;\n                }\n                if (onlineListener) {\n                    window.removeEventListener('online', onlineListener);\n                    onlineListener = null;\n                }\n            };\n            const attempt = () => {\n                const currentN = attemptIndex++;\n                fetch(path, { cache: 'no-cache' }).then(res => {\n                    if (!res.ok)\n                        throw new Error(res.status + ' ' + res.statusText);\n                    return res.text();\n                }).then(code => {\n                    if (resolved)\n                        return;\n                    if (FT_TS && isTypeScript)\n                        code = stripTypes(code);\n                    if (!isHTMLComponent) {\n                        const wrapped = code + `\\n//# sourceURL=${path}`;\n                        try {\n                            new Function('XTool', 'html', wrapped)(self, html);\n                        }\n                        catch (err) {\n                            console.error(`Error evaluating component script at ${path}:`, err);\n                        }\n                    }\n                    else {\n                        let scriptContent = '';\n                        let templateHTML = '';\n                        let hasSetup = false;\n                        try {\n                            const parser = new DOMParser();\n                            const parsed = parser.parseFromString(code, 'text/html');\n                            const scripts = parsed.querySelectorAll('script');\n                            scripts.forEach(sc => {\n                                if (sc.hasAttribute('setup'))\n                                    hasSetup = true;\n                                scriptContent += (sc.textContent || '') + '\\n';\n                                sc.remove();\n                            });\n                            const tplEl = parsed.querySelector('template');\n                            if (tplEl)\n                                templateHTML = (tplEl.innerHTML || '').trim();\n                            else\n                                templateHTML = (parsed.body ? parsed.body.innerHTML : '').trim();\n                        }\n                        catch (e) {\n                            console.error('HTML component parse failed, falling back to raw processing:', e);\n                            templateHTML = code;\n                        }\n                        try {\n                            const ctx = {};\n                            const lifecycles = {\n                                onMounted: [],\n                                onBeforeMount: [],\n                                onUnmounted: [],\n                                onBeforeUnmount: []\n                            };\n                            const expose = (obj) => { if (obj && typeof obj === 'object')\n                                Object.assign(ctx, obj); };\n                            const onMounted = (fn) => { if (typeof fn === 'function')\n                                lifecycles.onMounted.push(fn); };\n                            const onBeforeMount = (fn) => { if (typeof fn === 'function')\n                                lifecycles.onBeforeMount.push(fn); };\n                            const onUnmounted = (fn) => { if (typeof fn === 'function')\n                                lifecycles.onUnmounted.push(fn); };\n                            const onBeforeUnmount = (fn) => { if (typeof fn === 'function')\n                                lifecycles.onBeforeUnmount.push(fn); };\n                            const watch = (source, cb) => {\n                                if (!source || typeof cb !== 'function')\n                                    return () => { };\n                                const readVal = (s) => {\n                                    if (isComputedRef(s))\n                                        return undefined;\n                                    if (isReactive(s)) {\n                                        try {\n                                            if ('value' in s)\n                                                return s.value;\n                                        }\n                                        catch { }\n                                        return unwrapReactive(s);\n                                    }\n                                    return s;\n                                };\n                                if (Array.isArray(source)) {\n                                    const srcs = source.filter((s) => !!s && !isComputedRef(s));\n                                    const ctrls = srcs.map((s) => isReactive(s) ? getReactiveControl(s) : undefined);\n                                    const listeners = [];\n                                    let oldVals = srcs.map(readVal);\n                                    let scheduled = false;\n                                    const fire = () => {\n                                        if (scheduled)\n                                            return;\n                                        scheduled = true;\n                                        Promise.resolve().then(() => {\n                                            scheduled = false;\n                                            const newVals = srcs.map(readVal);\n                                            try {\n                                                cb(newVals, oldVals);\n                                            }\n                                            catch (e) {\n                                                console.error(e);\n                                            }\n                                            oldVals = newVals;\n                                        });\n                                    };\n                                    for (let i = 0; i < ctrls.length; i++) {\n                                        const c = ctrls[i];\n                                        if (!c)\n                                            continue;\n                                        if (!c.changeListeners)\n                                            c.changeListeners = [];\n                                        const l = (_o, _n) => fire();\n                                        c.changeListeners.push(l);\n                                        listeners.push(l);\n                                    }\n                                    const stop = () => {\n                                        for (let i = 0; i < ctrls.length; i++) {\n                                            const c = ctrls[i];\n                                            const l = listeners[i];\n                                            if (!c || !l || !c.changeListeners)\n                                                continue;\n                                            const idx = c.changeListeners.indexOf(l);\n                                            if (idx >= 0)\n                                                c.changeListeners.splice(idx, 1);\n                                        }\n                                    };\n                                    lifecycles.onBeforeUnmount.push(stop);\n                                    return stop;\n                                }\n                                if (isComputedRef(source)) {\n                                    return () => { };\n                                }\n                                if (isReactive(source)) {\n                                    const ctrl = getReactiveControl(source);\n                                    if (!ctrl)\n                                        return () => { };\n                                    if (!ctrl.changeListeners)\n                                        ctrl.changeListeners = [];\n                                    let oldV = readVal(source);\n                                    const listener = (_old, _new) => {\n                                        const newV = readVal(source);\n                                        try {\n                                            cb(newV, oldV);\n                                        }\n                                        catch (e) {\n                                            console.error(e);\n                                        }\n                                        oldV = newV;\n                                    };\n                                    ctrl.changeListeners.push(listener);\n                                    const stop = () => {\n                                        const arr = ctrl.changeListeners;\n                                        if (!arr)\n                                            return;\n                                        const idx = arr.indexOf(listener);\n                                        if (idx >= 0)\n                                            arr.splice(idx, 1);\n                                    };\n                                    lifecycles.onBeforeUnmount.push(stop);\n                                    return stop;\n                                }\n                                return () => { };\n                            };\n                            const exec = new Function('XTool', 'data', 'computed', 'watch', 'html', 'template', 'expose', 'onMounted', 'onBeforeMount', 'onUnmounted', 'onBeforeUnmount', scriptContent + `\\n//# sourceURL=${path}`);\n                            if (hasSetup)\n                                exec.call(ctx, self, data, computed, watch, html, templateHTML, expose, onMounted, onBeforeMount, onUnmounted, onBeforeUnmount);\n                            else\n                                exec(self, data, computed, watch, html, templateHTML, expose, onMounted, onBeforeMount, onUnmounted, onBeforeUnmount);\n                            const inferredName = (path.split('/').pop() || '').replace(/\\.(mjs|js|ts|html)(\\?.*)?$/i, '').toLowerCase();\n                            const name = typeof ctx.name === 'string' && ctx.name.trim() ? ctx.name.trim() : inferredName;\n                            const dataObj = {};\n                            const methodsObj = {};\n                            const computedObj = {};\n                            for (const k of Object.keys(ctx)) {\n                                if (k === 'name')\n                                    continue;\n                                const v = ctx[k];\n                                if (typeof v === 'function') {\n                                    methodsObj[k] = v;\n                                }\n                                else if (isComputedRef(v) && FT_C) {\n                                    computedObj[k] = v;\n                                }\n                                else {\n                                    dataObj[k] = isReactive(v) && _FT_DR ? v : makeReactive(v);\n                                }\n                            }\n                            const lifecycleDef = {};\n                            if (lifecycles.onMounted.length) {\n                                lifecycleDef.mounted = function () { for (let i = 0; i < lifecycles.onMounted.length; i++) {\n                                    try {\n                                        lifecycles.onMounted[i].call(this);\n                                    }\n                                    catch (e) {\n                                        console.error(e);\n                                    }\n                                } };\n                            }\n                            if (lifecycles.onBeforeMount.length) {\n                                lifecycleDef.beforeMount = function () { for (let i = 0; i < lifecycles.onBeforeMount.length; i++) {\n                                    try {\n                                        lifecycles.onBeforeMount[i].call(this);\n                                    }\n                                    catch (e) {\n                                        console.error(e);\n                                    }\n                                } };\n                            }\n                            if (lifecycles.onUnmounted.length) {\n                                lifecycleDef.unmounted = function () { for (let i = 0; i < lifecycles.onUnmounted.length; i++) {\n                                    try {\n                                        lifecycles.onUnmounted[i].call(this);\n                                    }\n                                    catch (e) {\n                                        console.error(e);\n                                    }\n                                } };\n                            }\n                            if (lifecycles.onBeforeUnmount.length) {\n                                lifecycleDef.beforeUnmount = function () { for (let i = 0; i < lifecycles.onBeforeUnmount.length; i++) {\n                                    try {\n                                        lifecycles.onBeforeUnmount[i].call(this);\n                                    }\n                                    catch (e) {\n                                        console.error(e);\n                                    }\n                                } };\n                            }\n                            try {\n                                self.registerComponent({ name, template: templateHTML, data: dataObj, methods: methodsObj, computed: computedObj, ...lifecycleDef });\n                            }\n                            catch (e) {\n                                console.error('Auto HTML component registration failed:', e);\n                            }\n                        }\n                        catch (err) {\n                            console.error(`Error evaluating HTML component at ${path}:`, err);\n                        }\n                    }\n                    resolved = true;\n                    clearResources();\n                    resolveFn();\n                }).catch(err => {\n                    if (resolved)\n                        return;\n                    const isOnline = (typeof navigator === 'undefined') ? true : navigator.onLine;\n                    const msg = (err && (err.message || '')) + '';\n                    const networkLike = err instanceof TypeError || /Failed to fetch|NetworkError|load failed/i.test(msg);\n                    if (!isOnline || networkLike) {\n                        if (!onlineListener) {\n                            onlineListener = () => {\n                                if (resolved)\n                                    return;\n                                if (timer != null) {\n                                    clearTimeout(timer);\n                                    timer = null;\n                                }\n                                attempt();\n                            };\n                            window.addEventListener('online', onlineListener);\n                        }\n                        const delay = computeDelay(currentN);\n                        timer = window.setTimeout(() => attempt(), delay);\n                        return;\n                    }\n                    if (currentN >= retries) {\n                        clearResources();\n                        rejectFn(err);\n                        return;\n                    }\n                    const delay = computeDelay(currentN);\n                    timer = window.setTimeout(() => attempt(), delay);\n                });\n            };\n            const p = new Promise((resolve, reject) => {\n                resolveFn = resolve;\n                rejectFn = reject;\n                attempt();\n            }).finally(() => { this._inflightComponentLoads.delete(path); clearResources(); });\n            this._inflightComponentLoads.set(path, p);\n            return p;\n        }\n        _applyPrefixInitialCSS() {\n            if (!d)\n                return;\n            if (PFX === 'x')\n                return;\n            const id = `x-tool-initial-css-${PFX}`;\n            if (d.head && !d.getElementById(id)) {\n                const style = d.createElement(STR_STYLE);\n                style.id = id;\n                style.textContent = `[${PFX}-show],[${PFX}-if],[${PFX}-else],[${PFX}-else-if],[${PFX}\\\\:show],[${PFX}\\\\:if],[${PFX}\\\\:else],[${PFX}\\\\:else-if]{display:none;}`;\n                d.head.appendChild(style);\n            }\n        }\n        _ensureRootObserver(container) {\n            if (this._rootObserver || typeof MutationObserver === 'undefined')\n                return;\n            this._rootObserver = new MutationObserver(records => {\n                for (const r of records) {\n                    if (r.type === 'childList') {\n                        for (let i = 0; i < r.addedNodes.length; i++) {\n                            const n = r.addedNodes[i];\n                            if (n.nodeType !== 1)\n                                continue;\n                            const el = n;\n                            if (el[STR_TAGNAME] === 'COMPONENT') {\n                                const src = el.getAttribute(STR_SOURCE);\n                                if (src && !this._getComponentByElement(el))\n                                    this._instantiateNamedComponent(el);\n                            }\n                        }\n                        for (let i = 0; i < r.removedNodes.length; i++) {\n                            const n = r.removedNodes[i];\n                            if (n.nodeType !== 1)\n                                continue;\n                            const el = n;\n                            quMct(() => {\n                                if (el.isConnected)\n                                    return;\n                                this._runRefCleanup(el);\n                                const stack = [el];\n                                while (stack.length) {\n                                    const cur = stack.pop();\n                                    const comp = this._getComponentByElement(cur);\n                                    if (comp && !comp.isDestroyed) {\n                                        _se(() => { this._clearComponentRefs(comp); comp.destroy(); });\n                                    }\n                                    let child = cur.firstElementChild;\n                                    while (child) {\n                                        stack.push(child);\n                                        child = child.nextElementSibling;\n                                    }\n                                }\n                            });\n                        }\n                    }\n                    else if (r.type === 'attributes') {\n                        const target = r.target;\n                        if (target && target[STR_TAGNAME] === 'COMPONENT') {\n                            if (r.attributeName === STR_SOURCE) {\n                                this._onComponentSourceChanged(target);\n                            }\n                            else if (r.attributeName === STR_READONLY) {\n                                const comp = this._getComponentByElement(target);\n                                if (comp) {\n                                    _se(() => { const ro = target.hasAttribute(STR_READONLY); comp.setFrozen(!!ro); });\n                                }\n                            }\n                        }\n                    }\n                }\n                this._processPending();\n            });\n            this._rootObserver.observe(container, { childList: true, subtree: true, attributes: true, attributeFilter: [STR_SOURCE, STR_READONLY] });\n        }\n        _ensureIO(rootMargin) {\n            if (!FT_EXT_DIRS)\n                return null;\n            if (typeof IntersectionObserver === 'undefined')\n                return null;\n            if (!this._ioObservers)\n                this._ioObservers = new Map();\n            if (!this._ioRegistry)\n                this._ioRegistry = new WkMap();\n            const key = rootMargin || '0px';\n            let io = this._ioObservers.get(key);\n            if (io)\n                return io;\n            const handle = (entries) => {\n                for (const entry of entries) {\n                    const el = entry.target;\n                    const reg = this._ioRegistry.get(el);\n                    if (!reg)\n                        continue;\n                    const now = !!entry.isIntersecting;\n                    const before = !!reg.visible;\n                    reg.visible = now;\n                    if (now && (!before)) {\n                        const arr = reg.enter || [];\n                        for (let i = 0; i < arr.length; i++) {\n                            _se(() => arr[i].cb(entry, { phase: 'enter', visible: now, before }));\n                        }\n                        if (arr.length)\n                            reg.enter = arr.filter(a => !a.once);\n                    }\n                    else if (!now && before) {\n                        const arr = reg.leave || [];\n                        for (let i = 0; i < arr.length; i++) {\n                            _se(() => arr[i].cb(entry, { phase: 'leave', visible: now, before }));\n                        }\n                        if (arr.length)\n                            reg.leave = arr.filter(a => !a.once);\n                    }\n                }\n            };\n            io = new IntersectionObserver(handle, { root: null, rootMargin: key });\n            this._ioObservers.set(key, io);\n            return io;\n        }\n        _ioObserve(el, rootMargin, onEnter, onLeave) {\n            if (!FT_EXT_DIRS)\n                return () => { };\n            const io = this._ensureIO(rootMargin);\n            if (!io)\n                return () => { };\n            if (!this._ioRegistry)\n                this._ioRegistry = new WkMap();\n            let reg = this._ioRegistry.get(el);\n            if (!reg) {\n                reg = { rootMargin };\n                this._ioRegistry.set(el, reg);\n            }\n            if (onEnter && onEnter.cb) {\n                (reg.enter || (reg.enter = [])).push({ cb: onEnter.cb, once: !!onEnter.once });\n            }\n            if (onLeave && onLeave.cb) {\n                (reg.leave || (reg.leave = [])).push({ cb: onLeave.cb, once: !!onLeave.once });\n            }\n            _se(() => io.observe(el));\n            return () => { _se(() => io.unobserve(el)); };\n        }\n        _onComponentSourceChanged(el) {\n            const src = _tr(el.getAttribute('source'));\n            const existing = this._getComponentByElement(el);\n            if (!src) {\n                if (existing && !existing.isDestroyed) {\n                    _se(() => existing.destroy());\n                }\n                el.innerHTML = '';\n                return;\n            }\n            if (existing && !existing.isDestroyed) {\n                _se(() => existing.destroy());\n            }\n            el.innerHTML = '';\n            this._instantiateNamedComponent(el);\n        }\n        _finalizeComponentMount(el, comp, opts) {\n            comp.element = el;\n            if (opts?.callBeforeMount) {\n                _se(() => comp.callBeforeMount());\n            }\n            this._registerElement(comp.element, comp);\n            this._pending.push({ el, comp });\n            if (opts?.xInitExpr) {\n                comp._setXInitExpr(opts.xInitExpr);\n            }\n        }\n        _instantiateNamedComponent(el, parentHint) {\n            let source = el.getAttribute('source');\n            if (!source)\n                return;\n            let parentComp = parentHint;\n            if (!parentComp) {\n                let par = el.parentElement;\n                while (par && !parentComp) {\n                    const maybe = this._getComponentByElement(par);\n                    if (maybe)\n                        parentComp = maybe;\n                    else\n                        par = par.parentElement;\n                }\n            }\n            let def = this._getRegisteredComponentDef(source);\n            if (!def && parentComp) {\n                try {\n                    const fn = new Function('ctx', 'with(ctx){return (' + source + ')}');\n                    const ctx = parentComp._createContextProxy(undefined, el);\n                    const evaluated = fn.call(parentComp.getContext(true), ctx);\n                    if (typeof evaluated === 'string' && evaluated) {\n                        source = evaluated;\n                        def = this._getRegisteredComponentDef(source);\n                    }\n                }\n                catch { }\n            }\n            if (!def) {\n                const name = source.toLowerCase();\n                const lazy = this._lazyComponentSources?.get(name);\n                if (lazy && lazy.status !== LS_LOADING && lazy.status !== LS_LOADED) {\n                    console.log(`[XTool] Lazy loading component \"${name}\" from path: ${lazy.path}`);\n                    if (lazy.status === LS_PENDING) {\n                        lazy.status = LS_LOADING;\n                        lazy.promise = this._fetchAndEvalComponent(lazy.path)\n                            .then(() => { lazy.status = LS_LOADED; })\n                            .catch(() => { lazy.status = LS_ERROR; });\n                    }\n                    lazy.promise?.then(() => { _se(() => { const again = this._getRegisteredComponentDef(source); if (again)\n                        this._instantiateNamedComponent(el); }); }).finally(() => {\n                        if (lazy.status === LS_LOADED) {\n                            this._lazyComponentSources?.delete(name);\n                        }\n                    });\n                }\n                return;\n            }\n            let props = null;\n            let dynamicPropObj = null;\n            let rawPropExpression = null;\n            if (!props)\n                props = {};\n            const propExpr = this._propExpressions.get(el) || el.getAttribute(attrName('prop'));\n            const propBase = attrName('prop');\n            const propPrefix = propBase + ':';\n            const modifierPropExpressions = {};\n            const resolvePropName = (raw) => {\n                if (!raw)\n                    return raw;\n                const lower = raw.toLowerCase();\n                const tryMatch = (obj) => {\n                    if (!obj)\n                        return null;\n                    for (const k of Object.keys(obj)) {\n                        if (k.toLowerCase() === lower)\n                            return k;\n                    }\n                    return null;\n                };\n                const fromPropEff = tryMatch(def?.propEffects);\n                if (fromPropEff)\n                    return fromPropEff;\n                if (raw.includes('-')) {\n                    return caseKebabToCamel(raw);\n                }\n                return raw;\n            };\n            for (const attr of Array.from(el.attributes)) {\n                const name = attr.name;\n                if (name.startsWith(propPrefix)) {\n                    const rawKey = name.substring(propPrefix.length);\n                    const key = resolvePropName(rawKey);\n                    if (key)\n                        modifierPropExpressions[key] = attr.value;\n                    el.removeAttribute(name);\n                }\n            }\n            if (propExpr) {\n                rawPropExpression = propExpr;\n                if (parentComp) {\n                    try {\n                        const fn = new Function('ctx', 'with(ctx){return (' + propExpr + ')}');\n                        const ctx = parentComp.getContext(true);\n                        const ctxProxy = parentComp._createContextProxy(undefined, el);\n                        dynamicPropObj = fn.call(ctx, ctxProxy);\n                    }\n                    catch (e) {\n                        dynamicPropObj = null;\n                        console.error('Error evaluating x-prop expression with parent context:', `{${def.name}}`, e);\n                    }\n                }\n                else {\n                    try {\n                        dynamicPropObj = new Function('return (' + propExpr + ')')();\n                    }\n                    catch {\n                        dynamicPropObj = null;\n                    }\n                }\n                if (dynamicPropObj && typeof dynamicPropObj === 'object')\n                    for (const k in dynamicPropObj)\n                        if (!(k in props))\n                            props[k] = dynamicPropObj[k];\n                this._propExpressions.set(el, propExpr);\n                el.removeAttribute(attrName('prop'));\n            }\n            if (Object.keys(modifierPropExpressions).length) {\n                const evaluated = {};\n                for (const [k, expr] of Object.entries(modifierPropExpressions)) {\n                    let val;\n                    if (parentComp) {\n                        try {\n                            const fn = new Function('ctx', 'with(ctx){return (' + expr + ')}');\n                            const ctx = parentComp.getContext(true);\n                            const ctxProxy = parentComp._createContextProxy(undefined, el);\n                            val = fn.call(ctx, ctxProxy);\n                        }\n                        catch (e) {\n                            val = undefined;\n                            console.error('[x-prop:' + k + '] Error evaluating expression:', expr, e);\n                        }\n                    }\n                    else {\n                        try {\n                            val = new Function('return (' + expr + ')')();\n                        }\n                        catch {\n                            val = undefined;\n                        }\n                    }\n                    evaluated[k] = val;\n                    if (!(k in props))\n                        props[k] = val;\n                }\n                const existingDynamic = dynamicPropObj ? { ...dynamicPropObj } : {};\n                dynamicPropObj = { ...existingDynamic };\n                for (const k in evaluated)\n                    if (!(k in existingDynamic))\n                        dynamicPropObj[k] = evaluated[k];\n                const modifierKeysToAppend = Object.keys(evaluated).filter(k => !(k in existingDynamic));\n                if (modifierKeysToAppend.length) {\n                    if (rawPropExpression && /}\\s*$/.test(rawPropExpression.trim())) {\n                        const trimmed = rawPropExpression.trim();\n                        const closeIndex = trimmed.lastIndexOf('}');\n                        if (closeIndex > -1) {\n                            const head = trimmed.slice(0, closeIndex);\n                            const needsComma = /{\\s*$/.test(head) ? false : true;\n                            const appended = modifierKeysToAppend.map(k => `${k}: ${modifierPropExpressions[k]}`).join(', ');\n                            rawPropExpression = head + (needsComma ? ', ' : ' ') + appended + '}';\n                        }\n                    }\n                    else {\n                        rawPropExpression = '{ ' + modifierKeysToAppend.map(k => `${k}: ${modifierPropExpressions[k]}`).join(', ') + ' }';\n                    }\n                }\n                else if (!rawPropExpression) {\n                    const allKeys = Object.keys(modifierPropExpressions);\n                    if (allKeys.length)\n                        rawPropExpression = '{ ' + allKeys.map(k => `${k}: ${modifierPropExpressions[k]}`).join(', ') + ' }';\n                }\n            }\n            let Initialscopes = null;\n            el.__x_scope && (Initialscopes = el.__x_scope);\n            let baseData = {};\n            if (def.makeData) {\n                _se(() => { const result = def.makeData(props); if (result)\n                    baseData = result; });\n            }\n            if (def.data) {\n                for (const k in def.data) {\n                    baseData[k] = def.data[k];\n                }\n            }\n            if (dynamicPropObj && typeof dynamicPropObj === 'object') {\n                for (const k in dynamicPropObj) {\n                    baseData[k] = dynamicPropObj[k];\n                }\n            }\n            else {\n                for (const k in props) {\n                    baseData[k] = props[k];\n                }\n            }\n            baseData.$props = props;\n            let initDef;\n            if (typeof def.init === 'function') {\n                try {\n                    const maybe = def.init(props);\n                    initDef = (maybe && typeof maybe === 'object') ? maybe : undefined;\n                }\n                catch {\n                    initDef = undefined;\n                }\n            }\n            const compDef = {\n                name: def.name ?? name,\n                data: baseData,\n                methods: { ...(def.methods || {}), ...(initDef?.methods || {}) },\n                computed: { ...(def.computed || {}), ...(initDef?.computed || {}) },\n                propEffects: { ...(def.propEffects || {}), ...(initDef?.propEffects || {}) },\n                setup: initDef?.setup || def.setup,\n                mounted: initDef?.mounted || def.mounted,\n                unmounted: initDef?.unmounted || def.unmounted,\n                beforeMount: initDef?.beforeMount || def.beforeMount,\n                beforeUnmount: initDef?.beforeUnmount || def.beforeUnmount,\n                updated: initDef?.updated || def.updated,\n                destroyed: initDef?.destroyed || def.destroyed,\n                beforeDestroy: initDef?.beforeDestroy || def.beforeDestroy\n            };\n            const comp = this.createComponent(compDef, Initialscopes);\n            const originalChildren = Array.from(el.childNodes);\n            if (originalChildren.length)\n                el.replaceChildren();\n            if (def.template) {\n                const applyTemplate = (tpl) => {\n                    el.innerHTML = tpl;\n                    const slots = el.querySelectorAll('slot');\n                    if (slots.length) {\n                        for (const slotEl of slots) {\n                            const name = slotEl.getAttribute('name');\n                            const matched = name\n                                ? originalChildren.filter(n => n.nodeType === 1 && n.getAttribute('slot') === name)\n                                : originalChildren.filter(n => n.nodeType !== 1 || !n.hasAttribute('slot'));\n                            if (matched.length)\n                                slotEl.replaceWith(...matched);\n                        }\n                    }\n                };\n                const tplVal = def.template;\n                if (typeof tplVal === 'string') {\n                    applyTemplate(tplVal);\n                }\n                else if (typeof tplVal === 'function') {\n                    try {\n                        const res = tplVal();\n                        if (res && typeof res.then === 'function') {\n                            el.innerHTML = '';\n                            res.then(html => { applyTemplate(html || ''); _se(() => comp._applyAsyncTemplateResolved()); });\n                        }\n                        else {\n                            applyTemplate(String(res || ''));\n                        }\n                    }\n                    catch {\n                        el.innerHTML = '';\n                    }\n                }\n                else if (tplVal && typeof tplVal.then === 'function') {\n                    el.innerHTML = '';\n                    tplVal.then(html => { applyTemplate(html || ''); _se(() => comp._applyAsyncTemplateResolved()); });\n                }\n            }\n            else {\n                if (originalChildren.length)\n                    el.append(...originalChildren);\n            }\n            this._finalizeComponentMount(el, comp, { callBeforeMount: false });\n            try {\n                const nested = el.querySelectorAll(`[${attrName('data')}]`);\n                for (const node of nested) {\n                    if (!this._getComponentByElement(node))\n                        this._bindElementAsComponent(node, comp);\n                }\n            }\n            catch { }\n            _se(() => { this._discoverNestedNamed(el, comp); });\n            if (rawPropExpression && parentComp) {\n                _se(() => comp._initReactiveProps(rawPropExpression, parentComp));\n            }\n            this._processPending();\n        }\n        _getComponentByElement(element) { return this._byEl.get(element); }\n        observe(_element) { }\n        _ensureDelegation(container) {\n            if (this._delegatedRootBound)\n                return;\n            const root = container;\n            const handler = (e) => {\n                let cur = e.target;\n                while (cur && cur !== root.parentElement) {\n                    if (e.cancelBubble)\n                        break;\n                    const map = this._delegated.get(cur);\n                    if (map) {\n                        const list = map.get(e.type);\n                        if (list && list.length) {\n                            for (const h of [...list]) {\n                                try {\n                                    if (h.comp && h.comp.isDestroyed) {\n                                        const i = list.indexOf(h);\n                                        if (i > -1)\n                                            list.splice(i, 1);\n                                        continue;\n                                    }\n                                    if (!h.filter || h.filter(e)) {\n                                        h.run(e);\n                                        if (h.once) {\n                                            const idx = list.indexOf(h);\n                                            if (idx > -1)\n                                                list.splice(idx, 1);\n                                        }\n                                    }\n                                }\n                                catch { }\n                            }\n                        }\n                    }\n                    cur = cur.parentElement;\n                }\n            };\n            const captureEvents = ['keydown', 'keyup'];\n            const bubbleEvents = ['click', 'input', 'change'];\n            for (const ev of captureEvents)\n                root.addEventListener(ev, handler, true);\n            for (const ev of bubbleEvents)\n                root.addEventListener(ev, handler, false);\n            this._delegatedRootBound = true;\n        }\n        _registerDelegated(element, event, entry) {\n            let map = this._delegated.get(element);\n            if (!map) {\n                map = new Map();\n                this._delegated.set(element, map);\n            }\n            let list = map.get(event);\n            if (!list) {\n                list = [];\n                map.set(event, list);\n            }\n            list.push(entry);\n            return () => {\n                try {\n                    const m = this._delegated.get(element);\n                    const l = m?.get(event);\n                    if (!l)\n                        return;\n                    const idx = l.indexOf(entry);\n                    if (idx > -1)\n                        l.splice(idx, 1);\n                }\n                catch { }\n            };\n        }\n    }\n    class ReactiveComponent {\n        attachToParent(parent) {\n            this._parent = parent;\n            parent._addChild(this);\n        }\n        get id() { return this._id; }\n        get framework() { return this._framework; }\n        get element() { return this._element; }\n        set element(el) { this._element = el; }\n        get isBound() { return this._isBound; }\n        set isBound(v) { this._isBound = v; }\n        get isMounted() { return this._isMounted; }\n        set isMounted(v) { this._isMounted = v; }\n        get isDestroyed() { return this._isDestroyed; }\n        set isDestroyed(v) { this._isDestroyed = v; }\n        _setActiveEffect(effect) { this._activeEffect = effect; }\n        _bridgeUtilReactive(prop, obj) {\n            if (!isReactive(obj))\n                return;\n            const control = getReactiveControl(obj);\n            if (!control)\n                return;\n            const prevDep = control.depTracker;\n            const prevBase = control.baseChangeListener;\n            control.trackerId = prop;\n            control.depTracker = (k) => {\n                if (this._isInComputedEvaluation && this._computedKeyStack.length) {\n                    const current = this._computedKeyStack[this._computedKeyStack.length - 1];\n                    let s = this._computedDeps.get(current);\n                    if (!s) {\n                        s = new Set();\n                        this._computedDeps.set(current, s);\n                    }\n                    s.add(prop);\n                }\n                if (prevDep)\n                    prevDep(k);\n            };\n            control.baseChangeListener = (oldVal, newVal) => {\n                if (prevBase)\n                    prevBase(oldVal, newVal);\n                this._onDataChange(prop);\n            };\n            setReactiveControl(obj, control);\n        }\n        _abortInvokerResources() {\n            for (const byKind of this._invokerResources.values()) {\n                for (const cleanup of byKind.values()) {\n                    _se(cleanup);\n                }\n            }\n            this._invokerResources.clear();\n        }\n        _cancelUserResources() {\n            this._abortInvokerResources();\n        }\n        _resolveBindingMeta(element, attributeName) {\n            const elAny = element;\n            let propName = attributeName in elAny ? attributeName : null;\n            if (!propName) {\n                const camel = attributeName.replace(/-([a-z])/g, (_, c) => c.toUpperCase());\n                propName = camel in elAny ? camel : (attributeName.toLowerCase() === 'readonly' && 'readOnly' in elAny ? 'readOnly' : null);\n            }\n            const isBooleanProp = !!(propName && typeof elAny[propName] === 'boolean');\n            const hasNonFunctionProp = !!(propName && typeof elAny[propName] !== 'function');\n            const isKnownBooleanAttr = !!ReactiveComponent._BA[attributeName.toLowerCase()];\n            return { elAny, propName, isBooleanProp, hasNonFunctionProp, isKnownBooleanAttr };\n        }\n        _applyGenericBinding(element, attributeName, value, meta) {\n            const { elAny, propName, isBooleanProp, hasNonFunctionProp, isKnownBooleanAttr } = meta;\n            if ((isBooleanProp && propName) || isKnownBooleanAttr) {\n                const boolVal = !!value;\n                if (propName && isBooleanProp)\n                    elAny[propName] = boolVal;\n                if (boolVal)\n                    element.setAttribute(attributeName, '');\n                else\n                    element.removeAttribute(attributeName);\n                return;\n            }\n            let normalized = null;\n            if (value && typeof value === 'object') {\n                const parts = [];\n                for (const k in value) {\n                    if (value[k])\n                        parts.push(k);\n                }\n                normalized = parts.length ? parts.join(' ') : null;\n            }\n            else if (value !== null && value !== undefined) {\n                normalized = String(value);\n            }\n            if (hasNonFunctionProp && propName) {\n                if (normalized !== null) {\n                    try {\n                        elAny[propName] = normalized;\n                    }\n                    catch {\n                        _se(() => element.setAttribute(attributeName, normalized));\n                    }\n                }\n                else {\n                    element.removeAttribute(attributeName);\n                }\n                return;\n            }\n            if (normalized !== null) {\n                const cur = element.getAttribute(attributeName);\n                if (cur !== normalized)\n                    element.setAttribute(attributeName, normalized);\n            }\n            else {\n                element.removeAttribute(attributeName);\n            }\n        }\n        _scanDirectiveAttrs(el, opts) {\n            const prefixDash = PFX + '-';\n            const prefixColon = PFX + ':';\n            const superColon = ':';\n            const namesOut = [];\n            let hasTextOrHtml = false;\n            let forName = null;\n            const names = el.getAttributeNames();\n            for (let i = 0; i < names.length; i++) {\n                const name = names[i];\n                const isDir = name.startsWith(prefixDash) || name.startsWith(prefixColon) || name.startsWith('@') || (name.startsWith(superColon) && name.length > 1);\n                if (!isDir)\n                    continue;\n                if (opts?.skipRootFor && name === attrName('for'))\n                    continue;\n                namesOut.push(name);\n                if (!hasTextOrHtml && (name === attrName('text') || name === attrName('html')))\n                    hasTextOrHtml = true;\n                if (!forName && name === attrName('for'))\n                    forName = name;\n            }\n            return { names: namesOut, hasTextOrHtml, forName };\n        }\n        setFrozen(on) {\n            if (on === this._isFrozen)\n                return;\n            this._isFrozen = on;\n            if (on) {\n                this._sealedBeforeFreeze = this._isSealed;\n                this._isSealed = true;\n                this._cancelUserResources();\n            }\n            else {\n                if (this._sealedBeforeFreeze !== null) {\n                    this._isSealed = this._sealedBeforeFreeze;\n                }\n                else {\n                    this._isSealed = false;\n                }\n                this._sealedBeforeFreeze = null;\n                this._scheduleRender();\n            }\n        }\n        _setSealed(on) {\n            if (on === this._isSealed)\n                return;\n            this._isSealed = on;\n            if (on) {\n                this._cancelUserResources();\n            }\n        }\n        _addDirective(element, directive) {\n            const existing = this._directives.get(element) || [];\n            existing.push(directive);\n            this._directives.set(element, existing);\n        }\n        constructor(id, def, framework, initialScopes) {\n            this.name = 'ReactiveComponent';\n            this._propUpdateActive = false;\n            this._runningPropEffect = false;\n            this._element = null;\n            this._isBound = false;\n            this._isMounted = false;\n            this._isDestroyed = false;\n            this._initialContextScopes = null;\n            this._beforeMountCalled = false;\n            this._children = [];\n            this._parent = null;\n            this._computed = {};\n            this._propEffects = {};\n            this._computedCache = new Map();\n            this._computedDeps = new Map();\n            this._computedRefControls = new Map();\n            this._computedKeyStack = [];\n            this._isInComputedEvaluation = false;\n            this._isInMethodExecution = false;\n            this._allEffects = new Set();\n            this._hasComputed = false;\n            this._directives = new Map();\n            this._cleanupFunctions = new Set();\n            this._directiveAbort = new AbortController();\n            this._invokerResources = new Map();\n            this._targetIds = new WkMap();\n            this._targetSeq = 0;\n            this._signalHandlers = new Map();\n            this._isSealed = false;\n            this._isFrozen = false;\n            this._sealedBeforeFreeze = null;\n            this._isMutationEnabled = true;\n            this._mutateDirty = false;\n            this._effectsToRun = new Set();\n            this._currentInvoker = null;\n            this._loopScopes = new WkMap();\n            this._expressionCache = new Map();\n            this._propertyDependencies = new Map();\n            this._activeEffect = null;\n            this._renderScheduled = false;\n            this._nextTickQueue = [];\n            this._changeFrameId = null;\n            this._renderFrameId = null;\n            this._initialClassSets = new WkMap();\n            this._rawData = {};\n            this._propParent = null;\n            this._callLifecycleHook = (hookName) => {\n                const hook = this._lifecycle[hookName];\n                if (this._beforeMountCalled && hookName === 'beforeMount') {\n                    return;\n                }\n                if (typeof hook === 'function') {\n                    this._safeExecute(() => this._runWithGlobalInterception(hook, []));\n                    if (hookName === 'beforeMount') {\n                        this._beforeMountCalled = true;\n                    }\n                }\n                if (hookName === 'mounted' && this._xInitExpr) {\n                    const expr = this._xInitExpr;\n                    if (this.isDestroyed || !this.element || !this.element.isConnected)\n                        return;\n                    const runner = () => {\n                        const trimmed = _tr(expr);\n                        const arrow = this._extractArrowFunction(trimmed);\n                        const ctx = this._createMethodContext();\n                        if (arrow) {\n                            const fn = this._compileArrowForEvent(arrow.paramsList, arrow.body, arrow.isBlock);\n                            const args = arrow.paramsList.length ? [this.element] : [];\n                            const out = fn.call(this._createContextProxy(undefined, this.element || undefined), ctx, ...args.slice(0, arrow.paramsList.length));\n                            if (typeof out === 'function')\n                                this._addCleanupFunction(out);\n                            return;\n                        }\n                        const compiled = this._createEvaluator(trimmed, trimmed.indexOf(';') !== -1);\n                        const result = compiled.call(ctx, this._createContextProxy(undefined, this.element || undefined));\n                        if (typeof result === 'function')\n                            this._addCleanupFunction(result);\n                    };\n                    this._safeExecute(() => this._runWithGlobalInterception(runner, []));\n                }\n            };\n            this._addCleanupFunction = (fn) => {\n                if (typeof fn !== 'function')\n                    return undefined;\n                const wrapped = () => {\n                    _se(fn);\n                    this._cleanupFunctions.delete(wrapped);\n                };\n                this._cleanupFunctions.add(wrapped);\n                return () => { this._cleanupFunctions.delete(wrapped); };\n            };\n            if (def.name)\n                this.name = def.name;\n            this._id = id;\n            this._framework = framework;\n            this._initialContextScopes = initialScopes || null;\n            this._originalMethods = def.methods || {};\n            this._computed = this._bindComputed(def.computed || {});\n            this._propEffects = def.propEffects || {};\n            if (this._propEffects && Object.keys(this._propEffects).length) {\n                this._propEffects = this._bindPropEffects();\n            }\n            this._hasComputed = !!(def.computed && Object.keys(def.computed).length);\n            this._lifecycle = {\n                mounted: def.mounted,\n                unmounted: def.unmounted || def.destroyed,\n                updated: def.updated,\n                beforeMount: def.beforeMount,\n                beforeUnmount: def.beforeUnmount || def.beforeDestroy,\n                setup: def.setup\n            };\n            this._rawData = this._cloneData(def.data || {});\n            this._data = this._createReactiveData(this._rawData || {});\n            try {\n                const keys = Object.keys(this._rawData || {});\n                for (let i = 0; i < keys.length; i++) {\n                    const k = keys[i];\n                    const v = this._rawData[k];\n                    if (isReactive(v))\n                        this._bridgeUtilReactive(k, v);\n                }\n            }\n            catch { }\n            this._methods = this._bindMethods();\n        }\n        _cloneData(value, seen) {\n            if (value === null || typeof value !== 'object')\n                return value;\n            if (isReactive(value))\n                return value;\n            const s = seen || new WeakMap();\n            if (s.has(value))\n                return s.get(value);\n            if (ARRAY_ISARRAY(value)) {\n                const arr = [];\n                s.set(value, arr);\n                for (let i = 0; i < value.length; i++)\n                    arr[i] = this._cloneData(value[i], s);\n                return arr;\n            }\n            if (value instanceof Date)\n                return new Date(value.getTime());\n            if (value instanceof RegExp)\n                return new RegExp(value.source, value.flags);\n            if (typeof Map !== 'undefined' && value instanceof Map) {\n                const m = new Map();\n                s.set(value, m);\n                value.forEach((v, k) => { m.set(this._cloneData(k, s), this._cloneData(v, s)); });\n                return m;\n            }\n            if (typeof Set !== 'undefined' && value instanceof Set) {\n                const st = new Set();\n                s.set(value, st);\n                value.forEach(v => st.add(this._cloneData(v, s)));\n                return st;\n            }\n            const proto = Object.getPrototypeOf(value);\n            if (proto === Object.prototype || proto === null) {\n                const out = Object.create(proto);\n                s.set(value, out);\n                for (const key of Object.keys(value)) {\n                    out[key] = this._cloneData(value[key], s);\n                }\n                return out;\n            }\n            return value;\n        }\n        callBeforeMount() {\n            if (!this._beforeMountCalled) {\n                this._callLifecycleHook('beforeMount');\n                this._beforeMountCalled = true;\n            }\n        }\n        _onDataChange(_property) {\n            if (!this.isBound)\n                return;\n            const self = this;\n            if (self._changeFrameId != null) {\n                _se(() => cancelAnimationFrame(self._changeFrameId));\n                self._changeFrameId = null;\n            }\n            if (this._isMutationEnabled === false) {\n                this._mutateDirty = true;\n                return;\n            }\n            const effectsToRun = self._effectsToRun;\n            const directDeps = self._propertyDependencies.get(_property);\n            if (directDeps) {\n                for (let i = 0; i < directDeps.length; i++)\n                    effectsToRun.add(directDeps[i]);\n            }\n            if (FT_C && self._computedDeps.size) {\n                const queue = [_property];\n                const visited = new Set();\n                const affectedComputed = new Set();\n                let queueIdx = 0;\n                while (queueIdx < queue.length) {\n                    const base = queue[queueIdx++];\n                    if (visited.has(base))\n                        continue;\n                    visited.add(base);\n                    for (const [compKey, baseDeps] of self._computedDeps.entries()) {\n                        if (baseDeps.has(base) && !affectedComputed.has(compKey)) {\n                            affectedComputed.add(compKey);\n                            queue.push(compKey);\n                        }\n                    }\n                }\n                for (const compKey of affectedComputed) {\n                    const compEffects = self._propertyDependencies.get(compKey);\n                    if (compEffects) {\n                        for (let i = 0; i < compEffects.length; i++)\n                            effectsToRun.add(compEffects[i]);\n                    }\n                    const ctrl = self._computedRefControls.get(compKey);\n                    if (ctrl && typeof ctrl.depTracker === 'function') {\n                        try {\n                            ctrl.depTracker(compKey);\n                        }\n                        catch { }\n                    }\n                    self._computedCache.delete(compKey);\n                }\n            }\n            self._changeFrameId = requestAnimationFrame(() => {\n                if (FT_C)\n                    self._computedCache.clear();\n                self._changeFrameId = null;\n                if (self.isDestroyed || self._isSealed)\n                    return;\n                for (const effect of effectsToRun)\n                    self._safeExecute(effect);\n                effectsToRun.clear();\n                if (!directDeps?.length && (self._hasComputed || !XTOOL_ENABLE_STATIC_DIRECTIVES)) {\n                    self._scheduleRender();\n                }\n                self._callLifecycleHook('updated');\n            });\n        }\n        _bindMethods() {\n            return this._bindFunctionMap(this._originalMethods, 'methods');\n        }\n        _bindComputed(src) {\n            return this._bindFunctionMap(src, 'computed');\n        }\n        _bindPropEffects() {\n            return this._bindFunctionMap(this._propEffects || {}, 'prop');\n        }\n        _bindFunctionMap(src, kind) {\n            const out = {};\n            for (const key in (src || {})) {\n                const original = src[key];\n                if (kind === 'computed') {\n                    if (isComputedRef(original)) {\n                        const ctrl = getReactiveControl(original);\n                        if (ctrl)\n                            this._computedRefControls.set(key, ctrl);\n                        out[key] = (() => {\n                            return original.value;\n                        });\n                    }\n                    else {\n                        out[key] = () => {\n                            const ctx = this._createMethodContext();\n                            return original.call(ctx);\n                        };\n                    }\n                }\n                else if (kind === 'methods') {\n                    out[key] = (...args) => {\n                        const prev = this._isInMethodExecution;\n                        const prevInv = this._currentInvoker;\n                        this._isInMethodExecution = true;\n                        this._currentInvoker = key;\n                        try {\n                            return this._safeExecute(() => this._runWithGlobalInterception(original, args));\n                        }\n                        finally {\n                            this._isInMethodExecution = prev;\n                            this._currentInvoker = prevInv;\n                        }\n                    };\n                }\n                else {\n                    out[key] = (newValue, oldValue) => {\n                        const prevInv = this._currentInvoker;\n                        const prevFlag = this._runningPropEffect;\n                        this._currentInvoker = `prop:${key}`;\n                        this._runningPropEffect = true;\n                        try {\n                            return this._safeExecute(() => this._runWithGlobalInterception(original, [newValue, oldValue]));\n                        }\n                        finally {\n                            this._runningPropEffect = prevFlag;\n                            this._currentInvoker = prevInv;\n                        }\n                    };\n                }\n            }\n            return out;\n        }\n        _getComputedValue(key) {\n            if (!FT_C)\n                return undefined;\n            this._trackDependency(key);\n            if (this._computedCache.has(key))\n                return this._computedCache.get(key);\n            this._isInComputedEvaluation = true;\n            this._computedKeyStack.push(key);\n            this._computedDeps.set(key, new Set());\n            try {\n                const getter = this._computed[key];\n                const value = typeof getter === 'function' ? getter() : undefined;\n                this._computedKeyStack.pop();\n                this._isInComputedEvaluation = this._computedKeyStack.length > 0;\n                this._computedCache.set(key, value);\n                return value;\n            }\n            catch (e) {\n                this._computedKeyStack.pop();\n                this._isInComputedEvaluation = this._computedKeyStack.length > 0;\n                return undefined;\n            }\n        }\n        _trackDependency(propKey) {\n            const activeEff = this._activeEffect;\n            if (!activeEff)\n                return;\n            let deps = this._propertyDependencies.get(propKey);\n            if (!deps) {\n                deps = [];\n                this._propertyDependencies.set(propKey, deps);\n            }\n            if (!deps.includes(activeEff))\n                deps.push(activeEff);\n            const stackLen = this._computedKeyStack.length;\n            if (this._isInComputedEvaluation && stackLen) {\n                const current = this._computedKeyStack[stackLen - 1];\n                let s = this._computedDeps.get(current);\n                if (!s) {\n                    s = new Set();\n                    this._computedDeps.set(current, s);\n                }\n                s.add(propKey);\n            }\n            if (!deps.includes(activeEff))\n                deps.push(activeEff);\n        }\n        _scheduleRender() {\n            if (this._isSealed || this._isFrozen || this._isDestroyed || this._renderScheduled)\n                return;\n            this._renderScheduled = true;\n            requestAnimationFrame(() => {\n                this._renderFrameId = null;\n                this._renderScheduled = false;\n                if (this._isDestroyed || this._isSealed) {\n                    if (this._nextTickQueue?.length)\n                        this._nextTickQueue.length = 0;\n                    return;\n                }\n                this._render();\n                if (this._nextTickQueue?.length) {\n                    const q = this._nextTickQueue.splice(0);\n                    for (const fn of q) {\n                        _se(fn);\n                    }\n                }\n            });\n        }\n        _safeExecute(fn, fallback) {\n            try {\n                return fn();\n            }\n            catch (error) {\n                console.error(error);\n                return fallback;\n            }\n        }\n        bindToElement(element) {\n            if (this._isBound)\n                return;\n            this._element = element;\n            if (!this._beforeMountCalled) {\n                this.callBeforeMount();\n            }\n            this.completeBinding();\n        }\n        getContext(includeComputed = true) {\n            return this._createMethodContext(includeComputed);\n        }\n        _applyAsyncTemplateResolved() {\n            if (!this._element)\n                return;\n            _se(() => this._parseDirectives(this._element));\n            this._scheduleRender();\n        }\n        completeBinding() {\n            if (this._isBound || !this._element)\n                return;\n            if (!this._framework._getComponentByElement(this._element))\n                this._framework._registerElement(this._element, this);\n            this._isBound = true;\n            this._isMounted = true;\n            this._parseDirectives(this._element);\n            if (this._lifecycle.setup) {\n                this._safeExecute(() => this._runWithGlobalInterception(this._lifecycle.setup, []));\n            }\n            this._render();\n            this._callLifecycleHook('mounted');\n        }\n        _addChild(child) {\n            if (!this._children.includes(child)) {\n                this._children.push(child);\n            }\n        }\n        _removeChild(child) {\n            const index = this._children.indexOf(child);\n            if (index > -1) {\n                this._children.splice(index, 1);\n            }\n        }\n        _setXInitExpr(expr) { this._xInitExpr = expr || undefined; }\n        _runWithGlobalInterception(fn, args) {\n            try {\n                const src = String(fn);\n                if (!/\\[native code\\]/.test(src)) {\n                    let body = src.trim();\n                    if (!/^function[\\s\\(]/.test(body) && !/^[\\w\\$_][\\w\\d\\$_]*\\s*=>/.test(body) && !/^\\(.*?\\)\\s*=>/.test(body)) {\n                        body = 'function ' + body;\n                    }\n                    const trySrc = 'with(ctx){ const f = (' + body + '); return f.apply(thisArg, argsArray); }';\n                    const wrapper = new Function('thisArg', 'argsArray', 'ctx', trySrc);\n                    const thisArg = this._createMethodContext();\n                    return wrapper.call(thisArg, thisArg, args, this._createContextProxy(undefined, undefined));\n                }\n            }\n            catch {\n            }\n            const thisArg = this._createMethodContext();\n            if (typeof fn !== 'function') {\n                console.log('Attempted to call a non-function:', fn);\n                return;\n            }\n            return fn.apply(thisArg, args);\n        }\n        destroy() {\n            const self = this;\n            if (self._isDestroyed)\n                return;\n            self._callLifecycleHook('beforeUnmount');\n            for (const child of self._children) {\n                if (!child.isDestroyed)\n                    child.destroy();\n            }\n            if (self._parent) {\n                self._parent._removeChild(self);\n            }\n            for (const [element, directives] of self._directives) {\n                for (const directive of directives) {\n                    if (directive.type === 'custom' && directive.customDirective?.unbind) {\n                        _se(() => directive.customDirective.unbind(element, self));\n                    }\n                }\n            }\n            self._directives.clear();\n            _se(() => self._directiveAbort.abort());\n            self._directiveAbort = new AbortController();\n            self._abortInvokerResources();\n            self._runCleanupCallbacks();\n            self._computedCache.clear();\n            self._expressionCache.clear();\n            self._propertyDependencies.clear();\n            if (self._propParent && self._propEffect) {\n                for (const deps of self._propParent._propertyDependencies.values()) {\n                    const idx = deps.indexOf(self._propEffect);\n                    if (idx > -1)\n                        deps.splice(idx, 1);\n                }\n            }\n            if (self._element)\n                self._framework._unregisterElement(self._element);\n            self._framework._clearComponentRefs(self);\n            if (self._changeFrameId != null) {\n                _se(() => cancelAnimationFrame(self._changeFrameId));\n                self._changeFrameId = null;\n            }\n            if (self._renderFrameId != null) {\n                _se(() => cancelAnimationFrame(self._renderFrameId));\n                self._renderFrameId = null;\n            }\n            self._callLifecycleHook('unmounted');\n            self._isDestroyed = true;\n            self._isMounted = false;\n            self._isBound = false;\n            self._children = [];\n            self._parent = null;\n            self._deepReactiveCache = new WkMap;\n            self._effectsToRun.clear();\n            self._element = null;\n            quMct(() => self._framework._unregisterComponent(self._id));\n            self._data = {};\n            self._rawData = {};\n            self._methods = {};\n            self._computed = {};\n            self._propEffects = {};\n            self._activeEffect = null;\n            self._signalHandlers.clear();\n        }\n        _onSignal(name, handler) {\n            let set = this._signalHandlers.get(name);\n            if (!set) {\n                set = new Set();\n                this._signalHandlers.set(name, set);\n            }\n            set.add(handler);\n        }\n        _offSignal(name, handler) {\n            const set = this._signalHandlers.get(name);\n            if (set) {\n                set.delete(handler);\n                if (set.size === 0)\n                    this._signalHandlers.delete(name);\n            }\n        }\n        _emitSignal(name, payload) {\n            const evt = { name, payload, _stopped: false, stopPropagation() { this._stopped = true; } };\n            let cur = this;\n            while (cur) {\n                const set = cur._signalHandlers.get(name);\n                if (set && set.size) {\n                    for (const h of Array.from(set)) {\n                        try {\n                            h.call(cur._createMethodContext(true), evt);\n                        }\n                        catch { }\n                        if (evt._stopped)\n                            return;\n                    }\n                }\n                cur = cur._parent;\n            }\n        }\n        _initReactiveProps(expr, parent) {\n            if (!expr || !parent)\n                return;\n            this._propParent = parent;\n            const el = this._element;\n            let evalFn;\n            try {\n                evalFn = new Function('ctx', 'with(ctx){return (' + expr + ')}');\n            }\n            catch {\n                return;\n            }\n            const lastPropValues = {};\n            let isFirstRun = true;\n            const update = () => {\n                parent._setActiveEffect(update);\n                let obj;\n                try {\n                    const ctx = parent._createContextProxy(undefined, el);\n                    obj = evalFn.call(parent.getContext(true), ctx);\n                }\n                catch {\n                    obj = null;\n                }\n                parent._setActiveEffect(null);\n                if (obj && typeof obj === 'object') {\n                    this._data.$props = this._data.$props || {};\n                    const autoMerge = this._framework._autoMergeProps;\n                    for (const k in obj) {\n                        const v = obj[k];\n                        const oldValue = lastPropValues[k];\n                        this._data.$props[k] = v;\n                        const hasChanged = isFirstRun || lastPropValues[k] !== v;\n                        if (!hasChanged)\n                            continue;\n                        lastPropValues[k] = v;\n                        const eff = this._propEffects[k];\n                        if (eff && !this._isSealed) {\n                            const prevFlag = this._runningPropEffect;\n                            this._runningPropEffect = true;\n                            try {\n                                eff(v, oldValue);\n                            }\n                            finally {\n                                this._runningPropEffect = prevFlag;\n                            }\n                        }\n                        else if (autoMerge) {\n                            this._propUpdateActive = true;\n                            this._data[k] = v;\n                            this._propUpdateActive = false;\n                        }\n                        else {\n                            this._onDataChange('$props');\n                        }\n                    }\n                    isFirstRun = false;\n                }\n            };\n            this._propEffect = update;\n            update();\n        }\n        _runCleanupCallbacks() {\n            for (const fn of this._cleanupFunctions) {\n                _se(fn);\n            }\n            this._cleanupFunctions.clear();\n        }\n        _listen(element, event, handler, options) {\n            const signal = this._directiveAbort.signal;\n            if (typeof options === 'boolean') {\n                element.addEventListener(event, handler, { capture: options, signal });\n            }\n            else if (options) {\n                const merged = options.signal && options.signal !== signal\n                    ? options\n                    : { ...options, signal };\n                element.addEventListener(event, handler, merged);\n            }\n            else {\n                element.addEventListener(event, handler, { signal });\n            }\n        }\n        _targetKey(target) {\n            let id = this._targetIds.get(target);\n            if (!id) {\n                id = (++this._targetSeq).toString(36);\n                this._targetIds.set(target, id);\n            }\n            return id;\n        }\n        _parseDirectives(element) {\n            const self = this;\n            let processedElements = 0;\n            const processElement = (el, isRoot = false) => {\n                if (!isRoot && (el.hasAttribute(attrName('data')) || this._framework._getComponentByElement(el))) {\n                    return false;\n                }\n                const isComponentTag = el[STR_TAGNAME] === 'COMPONENT';\n                const { names: directiveNames, hasTextOrHtml, forName } = self._scanDirectiveAttrs(el);\n                if (directiveNames.length > 0) {\n                    processedElements++;\n                    if (forName) {\n                        self._bindDirective(el, forName, el.getAttribute(forName) || '');\n                        return false;\n                    }\n                    for (const attr of directiveNames) {\n                        self._bindDirective(el, attr, el.getAttribute(attr) || '');\n                    }\n                }\n                if (FT_TI && !hasTextOrHtml)\n                    self._bindTextInterpolationsIn(el);\n                return isRoot || !isComponentTag;\n            };\n            processElement(element, true);\n            self._walkElements(element, processElement);\n        }\n        _bindTextInterpolationsIn(el) {\n            if (!FT_EXT_DIRS)\n                return;\n            const nodes = Array.from(el.childNodes);\n            for (const node of nodes) {\n                if (node.nodeType !== Node.TEXT_NODE)\n                    continue;\n                const textNode = node;\n                const raw = textNode.nodeValue || '';\n                if (textNode.__x_ti_bound || raw.indexOf('{{') === -1)\n                    continue;\n                const segs = [];\n                let i = 0;\n                while (i < raw.length) {\n                    const ch = raw.charCodeAt(i);\n                    if (ch === 92) {\n                        let run = 0;\n                        const start = i;\n                        while (i < raw.length && raw.charCodeAt(i) === 92) {\n                            run++;\n                            i++;\n                        }\n                        if (raw.startsWith('{{', i)) {\n                            const close = raw.indexOf('}}', i + 2);\n                            if (close === -1) {\n                                segs.push({ type: 'lit', text: raw.slice(start) });\n                                break;\n                            }\n                            if (run > 1)\n                                segs.push({ type: 'lit', text: '\\\\'.repeat(run - 1) });\n                            segs.push({ type: 'lit', text: raw.slice(i, close + 2) });\n                            i = close + 2;\n                            continue;\n                        }\n                        segs.push({ type: 'lit', text: raw.slice(start, i) });\n                        continue;\n                    }\n                    if (raw.startsWith('{{', i)) {\n                        const close = raw.indexOf('}}', i + 2);\n                        if (close === -1) {\n                            segs.push({ type: 'lit', text: raw.slice(i) });\n                            break;\n                        }\n                        const expr = raw.slice(i + 2, close).trim();\n                        if (expr.length === 0)\n                            segs.push({ type: 'lit', text: '{{}}' });\n                        else\n                            segs.push({ type: 'expr', code: expr });\n                        i = close + 2;\n                        continue;\n                    }\n                    const nextEsc = raw.indexOf('\\\\', i);\n                    const nextOpen = raw.indexOf('{{', i);\n                    let end = raw.length;\n                    if (nextEsc !== -1 && nextEsc < end)\n                        end = nextEsc;\n                    if (nextOpen !== -1 && nextOpen < end)\n                        end = nextOpen;\n                    segs.push({ type: 'lit', text: raw.slice(i, end) });\n                    i = end;\n                }\n                const hasExpr = segs.some(s => s.type === 'expr');\n                if (!hasExpr) {\n                    textNode.__x_ti_bound = true;\n                    const literalOut = segs.map(s => s.text || '').join('');\n                    if (textNode.textContent !== literalOut)\n                        textNode.textContent = literalOut;\n                    continue;\n                }\n                const evaluators = [];\n                for (const s of segs)\n                    if (s.type === 'expr')\n                        evaluators.push(this._createElementEvaluator(s.code, el));\n                textNode.__x_ti_bound = true;\n                const update = () => {\n                    let out = '';\n                    let ei = 0;\n                    for (const s of segs) {\n                        if (s.type === 'lit')\n                            out += s.text;\n                        else {\n                            const v = evaluators[ei++]();\n                            out += (v == null ? '' : String(v));\n                        }\n                    }\n                    if (textNode.textContent !== out)\n                        textNode.textContent = out;\n                };\n                const dirInfo = { type: 'text-interpolation', expression: raw, update: undefined };\n                this._addDirective(el, dirInfo);\n                const effect = this._createEffect(update, dirInfo);\n                dirInfo.update = effect;\n            }\n        }\n        _walkElements(parent, processor) {\n            let child = parent.firstElementChild;\n            while (child) {\n                const next = child.nextElementSibling;\n                if (processor(child))\n                    this._walkElements(child, processor);\n                child = next;\n            }\n        }\n        _bindDirective(element, directiveName, expression) {\n            const self = this;\n            const isAtEvent = directiveName.startsWith('@');\n            const isShortBind = directiveName.startsWith(PFX + ':');\n            const isSuperShortBind = directiveName.startsWith(':');\n            if (isSuperShortBind) {\n                const attr = directiveName.slice(1);\n                if (attr) {\n                    element.removeAttribute(directiveName);\n                    return self._bindAttributeDirective(element, attr, expression);\n                }\n            }\n            const type = isAtEvent ? ('on:' + directiveName.slice(1)) : directiveName.slice(PFX.length + 1);\n            if (!isAtEvent && (isShortBind || type === 'class' || type === STR_STYLE)) {\n                element.removeAttribute(directiveName);\n                return self._bindAttributeDirective(element, type, expression);\n            }\n            if (FT_EXT_DIRS && !isAtEvent && (type === 'transition' || type.startsWith('transition.'))) {\n                let modifiers;\n                if (type.startsWith('transition.')) {\n                    const modList = type.slice('transition.'.length).split('.').filter(Boolean);\n                    modifiers = modList.reduce((acc, m) => { acc[m] = true; return acc; }, {});\n                }\n                element.removeAttribute(directiveName);\n                return self._bindTransitionDirective(element, expression, undefined, modifiers);\n            }\n            if (!isAtEvent && (type === 'text' || type === 'html' || type === 'show')) {\n                return self._bindSimpleDirective(element, expression, type, directiveName);\n            }\n            if (!isAtEvent && type === 'ref') {\n                element.removeAttribute(directiveName);\n                return self._bindRefDirective(element, expression);\n            }\n            const handled = (!isAtEvent && type === 'model') ? (element.removeAttribute(directiveName), self._bindModelDirective(element, expression), true)\n                : type === 'if' ? (element.removeAttribute(directiveName), self._bindIfDirective(element, expression), true)\n                    : type === 'for' ? (element.removeAttribute(directiveName), self._bindForDirective(element, expression), true)\n                        : false;\n            if (handled)\n                return;\n            if (isAtEvent || type.indexOf(':') > -1) {\n                const [prefix, rest] = type.split(':', 2);\n                const [suffix, ...mods] = rest.split('.');\n                const modifiers = mods.reduce((acc, m) => { if (m)\n                    acc[m] = true; return acc; }, {});\n                if (!isAtEvent && element[STR_TAGNAME] === 'COMPONENT' && prefix === 'prop') {\n                    return;\n                }\n                if (prefix === 'on') {\n                    element.removeAttribute(directiveName);\n                    const customDirective = self.framework._getCustomDirective(suffix);\n                    return customDirective\n                        ? self._bindCustomDirective(element, suffix, expression, customDirective, modifiers)\n                        : self._bindEventDirective(element, suffix, expression, modifiers);\n                }\n                if (prefix === 'transition' && FT_EXT_DIRS) {\n                    element.removeAttribute(directiveName);\n                    const map = {\n                        'enter': 'enter', 'enter-from': 'enterFrom', 'enter-to': 'enterTo',\n                        'leave': 'leave', 'leave-from': 'leaveFrom', 'leave-to': 'leaveTo',\n                        'enter-start': 'enterFrom', 'enter-end': 'enterTo',\n                        'leave-start': 'leaveFrom', 'leave-end': 'leaveTo',\n                    };\n                    const part = map[suffix] || 'toggle';\n                    return self._bindTransitionDirective(element, expression, part, modifiers);\n                }\n                if (prefix === 'intersect' && FT_EXT_DIRS) {\n                    element.removeAttribute(directiveName);\n                    return self._bindIntersectDirective(element, expression, modifiers, suffix);\n                }\n                element.removeAttribute(directiveName);\n                return self._bindAttributeDirective(element, suffix, expression);\n            }\n        }\n        _bindRefDirective(element, expression) {\n            if (!FT_EXT_DIRS)\n                return;\n            const refName = _tr(expression);\n            if (!refName)\n                return;\n            const self = this;\n            self.framework._registerComponentRef(self, refName, element);\n            const dir = { type: 'ref', expression };\n            this._addDirective(element, dir);\n        }\n        _getSharedRef(refName) {\n            if (!refName || !FT_EXT_DIRS)\n                return undefined;\n            let ref = this.framework._getComponentRefs(this, refName);\n            if (!ref && this._parent) {\n                let parent = this._parent;\n                while (parent) {\n                    ref = parent.framework._getComponentRefs(parent, refName);\n                    if (ref || !parent._parent)\n                        break;\n                    parent = parent._parent;\n                }\n            }\n            if (ref) {\n                if (ref.size > 1) {\n                    const arr = [];\n                    ref.forEach((el) => arr.push(el));\n                    return arr;\n                }\n                else {\n                    return ref.values().next().value;\n                }\n            }\n        }\n        _bindIntersectDirective(element, expression, modifiers, phase) {\n            if (!FT_EXT_DIRS)\n                return;\n            const self = this;\n            const trimmed = _tr(expression);\n            const runExpr = self._compileHandler(trimmed, element, (payload) => [payload, element]);\n            const run = (payload) => { if (runExpr)\n                runExpr(payload); };\n            const once = !!modifiers['once'];\n            let rootMargin = '0px';\n            for (const m in modifiers) {\n                if (m.startsWith('rootMargin-')) {\n                    rootMargin = m.slice('rootMargin-'.length);\n                    break;\n                }\n            }\n            const onEnter = phase === 'enter' ? { cb: (entry, info) => run({ entry, ...info }), once } : undefined;\n            const onLeave = phase === 'leave' ? { cb: (entry, info) => run({ entry, ...info }), once } : undefined;\n            const unobserve = this.framework._ioObserve(element, rootMargin, onEnter, onLeave);\n            const dir = { type: 'intersect', expression };\n            this._addDirective(element, dir);\n            this._addCleanupFunction(() => { _se(unobserve); });\n        }\n        _createEffect(updateFn, directiveRef) {\n            const effect = () => {\n                this._activeEffect = effect;\n                try {\n                    updateFn();\n                }\n                finally {\n                    this._activeEffect = null;\n                }\n            };\n            effect();\n            this._allEffects.add(effect);\n            if (XTOOL_ENABLE_STATIC_DIRECTIVES && directiveRef && directiveRef._static === undefined) {\n                let found = false;\n                for (const deps of this._propertyDependencies.values()) {\n                    if (deps.includes(effect)) {\n                        found = true;\n                        break;\n                    }\n                }\n                directiveRef._static = !found;\n            }\n            return effect;\n        }\n        _bindTransitionDirective(element, expression, part, modifiers) {\n            if (!FT_EXT_DIRS)\n                return;\n            let config = element.__x_transition || null;\n            const trimmed = _tr(expression);\n            if (trimmed) {\n                try {\n                    const evalFn = this._createElementEvaluator(trimmed, element);\n                    const val = this._safeExecute(() => evalFn());\n                    if (!config)\n                        config = {};\n                    if (val && typeof val === 'object') {\n                        for (const k in val)\n                            config[k] = val[k];\n                    }\n                    else if (typeof val === 'string') {\n                        if (part)\n                            config[part] = val;\n                        else\n                            config.toggle = val;\n                    }\n                }\n                catch { }\n            }\n            if (modifiers && (modifiers.after || modifiers.end)) {\n                const exprStr = trimmed;\n                if (exprStr) {\n                    const runExpr = this._compileHandler(exprStr, element, (payload) => [payload, element]);\n                    const call = (payload) => { if (runExpr)\n                        this._safeExecute(() => runExpr(payload)); };\n                    if (part === 'enter' || part === 'enterFrom' || part === 'enterTo')\n                        config.afterEnterRunner = call;\n                    else if (part === 'leave' || part === 'leaveFrom' || part === 'leaveTo')\n                        config.afterLeaveRunner = call;\n                    else\n                        config.afterRunner = call;\n                }\n            }\n            if (!config)\n                config = {};\n            element.__x_transition = config;\n            this._addDirective(element, { type: 'transition', expression });\n        }\n        _applyShowWithTransition(el, show, originalDisplay, onDone) {\n            if (!FT_EXT_DIRS) {\n                if (show) {\n                    if (originalDisplay)\n                        el.style.setProperty('display', originalDisplay, 'important');\n                    else\n                        el.style.removeProperty('display');\n                }\n                else {\n                    el.style.setProperty('display', STR_NONE, 'important');\n                }\n                if (onDone)\n                    onDone();\n                return;\n            }\n            const cfg = el.__x_transition;\n            const imp = 'important';\n            if (!cfg) {\n                if (show) {\n                    if (originalDisplay)\n                        el.style.setProperty('display', originalDisplay, imp);\n                    else\n                        el.style.removeProperty('display');\n                }\n                else {\n                    el.style.setProperty('display', STR_NONE, imp);\n                }\n                if (onDone)\n                    onDone();\n                return;\n            }\n            const prev = el.__x_t;\n            if (prev && typeof prev.cancel === 'function') {\n                prev.cancel();\n            }\n            const duration = typeof cfg.duration === 'number' ? cfg.duration : 150;\n            const easing = typeof cfg.easing === 'string' ? cfg.easing : 'ease';\n            const add = (cls) => { if (!cls)\n                return; cls.split(/\\s+/).forEach(c => c && el.classList.add(c)); };\n            const rm = (cls) => { if (!cls)\n                return; cls.split(/\\s+/).forEach(c => c && el.classList.remove(c)); };\n            const effectiveMs = (fallbackMs) => {\n                try {\n                    const cs = (typeof window !== 'undefined' && window.getComputedStyle) ? window.getComputedStyle(el) : null;\n                    if (!cs)\n                        return fallbackMs;\n                    const parseTimes = (s) => {\n                        if (!s)\n                            return [];\n                        return s.split(',').map(x => x.trim()).filter(Boolean).map(x => {\n                            if (x.endsWith('ms'))\n                                return parseFloat(x);\n                            if (x.endsWith('s'))\n                                return parseFloat(x) * 1000;\n                            const n = parseFloat(x);\n                            return isNaN(n) ? 0 : n;\n                        });\n                    };\n                    const sumMax = (durations, delays) => {\n                        const n = Math.max(durations.length, delays.length);\n                        let max = 0;\n                        for (let i = 0; i < n; i++) {\n                            const d = durations[i % durations.length] || 0;\n                            const dl = delays[i % delays.length] || 0;\n                            const t = d + dl;\n                            if (t > max)\n                                max = t;\n                        }\n                        return max;\n                    };\n                    const tDur = parseTimes(cs.transitionDuration || '');\n                    const tDel = parseTimes(cs.transitionDelay || '');\n                    let maxT = sumMax(tDur, tDel);\n                    const aDur = parseTimes(cs.animationDuration || '');\n                    const aDel = parseTimes(cs.animationDelay || '');\n                    const itersRaw = (cs.animationIterationCount || '').split(',').map(s => s.trim());\n                    const iters = itersRaw.map(v => (v === 'infinite' ? 0 : (parseFloat(v) || 1)));\n                    const nA = Math.max(aDur.length, aDel.length, iters.length);\n                    let maxA = 0;\n                    for (let i = 0; i < nA; i++) {\n                        const d = aDur[i % aDur.length] || 0;\n                        const dl = aDel[i % aDel.length] || 0;\n                        const it = iters[i % iters.length] || 1;\n                        if (it === 0)\n                            continue;\n                        const t = dl + d * it;\n                        if (t > maxA)\n                            maxA = t;\n                    }\n                    const eff = Math.max(maxT, maxA);\n                    return eff > 0 ? eff : fallbackMs;\n                }\n                catch {\n                    return fallbackMs;\n                }\n            };\n            const finishers = [];\n            const addFinish = (cb) => finishers.push(cb);\n            const cleanup = () => { while (finishers.length) {\n                _se(() => finishers.pop()());\n            } };\n            const waitEnd = (fallbackMs, done) => {\n                let ended = false;\n                const off = () => {\n                    if (ended)\n                        return;\n                    ended = true;\n                    done();\n                    cleanup();\n                };\n                const onEnd = () => off();\n                el.addEventListener('transitionend', onEnd, { once: true, capture: true });\n                el.addEventListener('animationend', onEnd, { once: true, capture: true });\n                const to = setTimeout(off, fallbackMs + 50);\n                addFinish(() => {\n                    _se(() => {\n                        el.removeEventListener('transitionend', onEnd, { capture: true });\n                        el.removeEventListener('animationend', onEnd, { capture: true });\n                    });\n                    clearTimeout(to);\n                });\n            };\n            const invokeAfter = (phase, msUsed) => {\n                const payload = { el, phase, config: { ...cfg, duration: msUsed ?? effectiveMs(duration), easing } };\n                try {\n                    if (phase === 'enter') {\n                        if (typeof cfg.afterEnterRunner === 'function')\n                            cfg.afterEnterRunner(payload);\n                        else if (typeof cfg.afterRunner === 'function')\n                            cfg.afterRunner(payload);\n                    }\n                    else {\n                        if (typeof cfg.afterLeaveRunner === 'function')\n                            cfg.afterLeaveRunner(payload);\n                        else if (typeof cfg.afterRunner === 'function')\n                            cfg.afterRunner(payload);\n                    }\n                }\n                catch { }\n            };\n            const startClassBased = (phase) => {\n                const enter = phase === 'enter';\n                const A = enter ? cfg.enter : cfg.leave;\n                const F = enter ? cfg.enterFrom : cfg.leaveFrom;\n                const T = enter ? cfg.enterTo : cfg.leaveTo;\n                if (enter) {\n                    if (originalDisplay)\n                        el.style.setProperty('display', originalDisplay, imp);\n                    else\n                        el.style.removeProperty('display');\n                }\n                if (!A && !F && !T)\n                    return false;\n                add(A);\n                add(F);\n                el.offsetWidth;\n                rm(F);\n                add(T);\n                const ms = effectiveMs(duration);\n                waitEnd(ms, () => {\n                    rm(A);\n                    rm(T);\n                    if (!enter)\n                        el.style.setProperty('display', STR_NONE, imp);\n                    if (onDone)\n                        onDone();\n                    invokeAfter(phase, ms);\n                });\n                el.__x_t = { cancel: () => { rm(A); rm(F); rm(T); if (!enter)\n                        el.style.setProperty('display', STR_NONE, imp); if (onDone)\n                        onDone(); } };\n                return true;\n            };\n            const startStyleFade = (phase) => {\n                const enter = phase === 'enter';\n                const prevTransition = el.style.transition;\n                const prevOpacity = el.style.opacity;\n                if (enter) {\n                    if (originalDisplay)\n                        el.style.setProperty('display', originalDisplay, imp);\n                    else\n                        el.style.removeProperty('display');\n                    el.style.setProperty('opacity', '0', imp);\n                }\n                else {\n                    el.style.setProperty('opacity', '1', imp);\n                }\n                el.offsetWidth;\n                const ms = effectiveMs(duration);\n                el.style.setProperty('transition', `opacity ${ms}ms ${easing}`, imp);\n                if (enter)\n                    el.style.setProperty('opacity', '1', imp);\n                else\n                    el.style.setProperty('opacity', '0', imp);\n                waitEnd(ms, () => {\n                    if (prevTransition)\n                        el.style.setProperty('transition', prevTransition, imp);\n                    else\n                        el.style.removeProperty('transition');\n                    if (prevOpacity)\n                        el.style.setProperty('opacity', prevOpacity, imp);\n                    else\n                        el.style.removeProperty('opacity');\n                    if (!enter)\n                        el.style.setProperty('display', STR_NONE, imp);\n                    if (onDone)\n                        onDone();\n                    invokeAfter(phase, ms);\n                });\n                el.__x_t = { cancel: () => { if (prevTransition)\n                        el.style.setProperty('transition', prevTransition, imp);\n                    else\n                        el.style.removeProperty('transition'); if (prevOpacity)\n                        el.style.setProperty('opacity', prevOpacity, imp);\n                    else\n                        el.style.removeProperty('opacity'); if (!enter)\n                        el.style.setProperty('display', STR_NONE, imp); if (onDone)\n                        onDone(); } };\n            };\n            if (typeof cfg.toggle === 'string') {\n                if (show) {\n                    if (originalDisplay)\n                        el.style.setProperty('display', originalDisplay, imp);\n                    else\n                        el.style.removeProperty('display');\n                    add(cfg.toggle);\n                    const ms = effectiveMs(duration);\n                    waitEnd(ms, () => { if (onDone)\n                        onDone(); invokeAfter('enter', ms); });\n                    el.__x_t = { cancel: () => { if (onDone)\n                            onDone(); } };\n                }\n                else {\n                    rm(cfg.toggle);\n                    const ms = effectiveMs(duration);\n                    waitEnd(ms, () => { el.style.setProperty('display', STR_NONE, imp); if (onDone)\n                        onDone(); invokeAfter('leave', ms); });\n                    el.__x_t = { cancel: () => { el.style.setProperty('display', STR_NONE, imp); if (onDone)\n                            onDone(); } };\n                }\n                return;\n            }\n            if (show) {\n                if (!startClassBased('enter'))\n                    startStyleFade('enter');\n            }\n            else {\n                if (!startClassBased('leave'))\n                    startStyleFade('leave');\n            }\n        }\n        _bindSimpleDirective(element, expression, type, directiveName) {\n            if (type === 'class' || type === STR_STYLE) {\n                return this._bindAttributeDirective(element, type, expression);\n            }\n            if (type === 'show' && element[STR_TAGNAME] === STR_TEMPLATE) {\n                return this._bindTemplateShowDirective(element, expression);\n            }\n            const evaluator = this._createElementEvaluator(expression, element);\n            let isDirty = directiveName ? element.getAttribute(directiveName) !== null : false;\n            let originalDisplay;\n            if (type === 'show') {\n                const el = element;\n                originalDisplay = el.style[STR_DISPLAY] !== STR_NONE ? el.style[STR_DISPLAY] : undefined;\n            }\n            let _prevShown = undefined;\n            const update = () => {\n                const value = evaluator();\n                const el = element;\n                if (isDirty && directiveName) {\n                    element.removeAttribute(directiveName);\n                    isDirty = false;\n                }\n                switch (type) {\n                    case 'text':\n                        el.textContent = String(value);\n                        break;\n                    case 'html':\n                        el.innerHTML = String(value || '');\n                        break;\n                    case 'show':\n                        const next = !!value;\n                        if (_prevShown === next)\n                            return;\n                        _prevShown = next;\n                        this._applyShowWithTransition(el, next, originalDisplay);\n                        break;\n                }\n            };\n            const dirInfo = { type, expression, update: undefined, originalDisplay };\n            this._addDirective(element, dirInfo);\n            const effect = this._createEffect(update, dirInfo);\n            dirInfo.update = effect;\n        }\n        _bindTemplateShowDirective(template, expression) {\n            const wrapper = d.createElement('div');\n            wrapper.style[STR_DISPLAY] = STR_CONTENTS;\n            wrapper.appendChild(template.content.cloneNode(true));\n            template.parentNode?.insertBefore(wrapper, template);\n            template.parentNode?.removeChild(template);\n            this._parseDirectives(wrapper);\n            _se(() => this.framework._discoverNestedNamed(wrapper, this));\n            const evaluator = this._createElementEvaluator(expression, wrapper);\n            let _prevShown = undefined;\n            const originalDisplay = STR_CONTENTS;\n            const update = () => {\n                const next = !!evaluator();\n                if (_prevShown === next)\n                    return;\n                _prevShown = next;\n                this._applyShowWithTransition(wrapper, next, originalDisplay);\n            };\n            const dirInfo = { type: 'show', expression, update: undefined, originalDisplay };\n            this._addDirective(wrapper, dirInfo);\n            const effect = this._createEffect(update, dirInfo);\n            dirInfo.update = effect;\n        }\n        _bindModelDirective(element, property) {\n            const isCheckbox = element.type === 'checkbox';\n            const isNumeric = element.type === 'number' || element.type === 'range';\n            const isMultiSelect = element.tagName === 'SELECT' && element.multiple === true;\n            if (!(property in this._data)) {\n                this._data[property] = undefined;\n            }\n            const getValueEvaluator = this._createElementEvaluator(property, element);\n            const setValueEvaluator = this._createEvaluator(`${property} = $value`, true);\n            const inferCheckboxValue = () => {\n                if (element.hasAttribute('value'))\n                    return element.value;\n                const loopScope = this._collectLoopScope(element);\n                if (loopScope) {\n                    const keys = Object.keys(loopScope);\n                    if (keys.length === 1)\n                        return loopScope[keys[0]];\n                }\n                return element.value;\n            };\n            const checkboxValue = isCheckbox ? inferCheckboxValue() : undefined;\n            const getInputValue = () => {\n                if (isCheckbox) {\n                    const currentData = getValueEvaluator();\n                    if (Array.isArray(currentData) && checkboxValue !== undefined) {\n                        return element.checked ? checkboxValue : undefined;\n                    }\n                    return element.hasAttribute('value') ? (element.checked ? element.value : undefined) : element.checked;\n                }\n                if (isMultiSelect) {\n                    const sel = element;\n                    const values = [];\n                    const opts = sel.options;\n                    for (let i = 0; i < opts.length; i++) {\n                        if (opts[i].selected)\n                            values.push(opts[i].value);\n                    }\n                    return values;\n                }\n                return isNumeric ? parseFloat(element.value) || 0 : element.value;\n            };\n            const setInputValue = (value) => {\n                if (isCheckbox) {\n                    if (Array.isArray(value)) {\n                        const member = element.hasAttribute('value') ? element.value : checkboxValue;\n                        element.checked = member != null ? value.includes(member) : false;\n                    }\n                    else {\n                        element.checked = !!value;\n                    }\n                    return;\n                }\n                if (isMultiSelect) {\n                    const sel = element;\n                    const arr = Array.isArray(value) ? value : [];\n                    const opts = sel.options;\n                    for (let i = 0; i < opts.length; i++) {\n                        opts[i].selected = arr.includes(opts[i].value);\n                    }\n                    return;\n                }\n                element.value = String(value ?? (isNumeric ? 0 : ''));\n            };\n            this._createEffect(() => setInputValue(getValueEvaluator()));\n            const ctx = this._createContextProxy(undefined, element);\n            const updateData = () => {\n                const raw = getInputValue();\n                const currentVal = this._safeExecute(() => getValueEvaluator());\n                if (isCheckbox && Array.isArray(currentVal)) {\n                    const member = element.hasAttribute('value') ? element.value : checkboxValue;\n                    if (member !== undefined) {\n                        const idx = currentVal.indexOf(member);\n                        if (element.checked) {\n                            if (idx === -1)\n                                currentVal.push(member);\n                        }\n                        else if (idx > -1) {\n                            currentVal.splice(idx, 1);\n                        }\n                    }\n                }\n                else if (isMultiSelect && Array.isArray(currentVal)) {\n                    currentVal.splice(0, currentVal.length, ...raw);\n                }\n                else {\n                    ctx.$value = raw;\n                    this._safeExecute(() => { setValueEvaluator.call(this._createMethodContext(), ctx); });\n                }\n            };\n            const t = element.type;\n            const eventType = (element[STR_TAGNAME] === 'SELECT' || t === 'checkbox' || t === 'radio' || t === 'file') ? 'change' : 'input';\n            this._listen(element, eventType, updateData);\n            this._addDirective(element, { type: 'model', property });\n        }\n        _bindIfDirective(element, expression) {\n            const self = this;\n            const placeholder = d.createComment('x-if');\n            element.parentNode?.insertBefore(placeholder, element);\n            element.__x_if_anchorParent = placeholder.parentElement || null;\n            const branches = [];\n            const makeActualElement = (el) => {\n                if (el[STR_TAGNAME] === STR_TEMPLATE) {\n                    const wrapper = d.createElement('div');\n                    wrapper.style[STR_DISPLAY] = STR_CONTENTS;\n                    wrapper.appendChild(el.content.cloneNode(true));\n                    return { el: wrapper, isTemplate: true };\n                }\n                return { el: el, isTemplate: false };\n            };\n            const first = makeActualElement(element);\n            const firstOD = (first.el.style[STR_DISPLAY] !== STR_NONE) ? first.el.style[STR_DISPLAY] : undefined;\n            const firstEval = self._createElementEvaluator(expression, element);\n            branches.push({ el: first.el, test: firstEval, isTemplate: first.isTemplate, originalDisplay: firstOD });\n            if (!first.isTemplate)\n                first.el.__x_tool_bound = true;\n            const originalNodes = [element];\n            if (FT_IFB) {\n                let sib = element.nextElementSibling;\n                while (sib) {\n                    const isElse = sib.hasAttribute(attrName('else'));\n                    const isElseIf = sib.hasAttribute(attrName('else-if'));\n                    if (!isElse && !isElseIf)\n                        break;\n                    if (sib.hasAttribute(attrName('else-if'))) {\n                        const attr = sib.getAttribute(attrName('else-if')) || '';\n                        const branch = makeActualElement(sib);\n                        const od = (branch.el.style[STR_DISPLAY] !== STR_NONE) ? branch.el.style[STR_DISPLAY] : undefined;\n                        const evalFn = self._createElementEvaluator(_tr(attr), sib);\n                        branches.push({ el: branch.el, test: evalFn, isTemplate: branch.isTemplate, originalDisplay: od });\n                        if (!branch.isTemplate)\n                            branch.el.__x_tool_bound = true;\n                    }\n                    else {\n                        const branch = makeActualElement(sib);\n                        const od = (branch.el.style[STR_DISPLAY] !== STR_NONE) ? branch.el.style[STR_DISPLAY] : undefined;\n                        branches.push({ el: branch.el, test: null, isTemplate: branch.isTemplate, originalDisplay: od });\n                        if (!branch.isTemplate)\n                            branch.el.__x_tool_bound = true;\n                    }\n                    sib.removeAttribute(attrName('else'));\n                    sib.removeAttribute(attrName('else-if'));\n                    originalNodes.push(sib);\n                    sib = sib.nextElementSibling;\n                }\n            }\n            let active = -1;\n            for (const orig of originalNodes) {\n                if (orig.parentNode)\n                    orig.parentNode.removeChild(orig);\n            }\n            const mountBranch = (idx) => {\n                if (idx < 0)\n                    return;\n                const b = branches[idx];\n                let anchorParent = placeholder.parentElement;\n                let parentScope = null;\n                while (anchorParent && !parentScope) {\n                    parentScope = anchorParent.__x_scope || null;\n                    if (!parentScope) {\n                        parentScope = self._loopScopes.get(anchorParent) || null;\n                    }\n                    if (!parentScope) {\n                        anchorParent = anchorParent.parentElement;\n                    }\n                }\n                if (parentScope) {\n                    b.el.__x_scope = parentScope;\n                    self._loopScopes.set(b.el, parentScope);\n                }\n                if (!b.el.__x_tool_bound) {\n                    self._parseDirectives(b.el);\n                    b.el.__x_tool_bound = true;\n                }\n                element.__x_if_current?.parentNode?.removeChild(element.__x_if_current);\n                if (!b.el.parentNode) {\n                    placeholder.parentNode?.insertBefore(b.el, placeholder.nextSibling);\n                }\n                element.__x_if_current = b.el;\n                self._applyShowWithTransition(b.el, true, b.originalDisplay);\n                _se(() => self.framework._discoverNestedNamed(b.el, self));\n                active = idx;\n            };\n            const unmountBranch = (idx, cb) => {\n                if (idx < 0) {\n                    if (cb)\n                        cb();\n                    return;\n                }\n                const b = branches[idx];\n                if (b.el.parentNode) {\n                    self._applyShowWithTransition(b.el, false, b.originalDisplay, () => {\n                        if (b.el.parentNode)\n                            b.el.parentNode.removeChild(b.el);\n                        if (cb)\n                            cb();\n                    });\n                }\n                else if (cb)\n                    cb();\n                active = -1;\n            };\n            const update = () => {\n                let next = -1;\n                for (let i = 0; i < branches[STR_LENGTH]; i++) {\n                    const b = branches[i];\n                    const pass = b.test ? !!b.test() : true;\n                    if (pass) {\n                        next = i;\n                        break;\n                    }\n                }\n                if (next === active)\n                    return;\n                if (active !== -1) {\n                    unmountBranch(active, () => mountBranch(next));\n                }\n                else {\n                    mountBranch(next);\n                }\n            };\n            const effect = self._createEffect(update);\n            self._addDirective(element, { type: 'if', expression, update: effect });\n        }\n        _bindEventDirective(element, eventName, expression, modifiers) {\n            const self = this;\n            const trimmed = _tr(expression);\n            const opts = modifiers ? {\n                once: !!modifiers.once,\n                passive: !!modifiers.passive,\n                capture: !!modifiers.capture,\n            } : undefined;\n            const onlySelf = !!modifiers?.self;\n            const shouldPrevent = !!modifiers?.prevent;\n            const shouldStop = !!modifiers?.stop;\n            const isOutside = !!modifiers?.outside;\n            const isWindow = !!modifiers?.window;\n            const deferExec = !!modifiers?.defer;\n            const keyAliasMap = { enter: ['enter'], esc: ['escape', 'esc'], escape: ['escape', 'esc'], space: [' ', 'space', 'spacebar'], tab: ['tab'], backspace: ['backspace'], delete: ['delete', 'del'], del: ['delete', 'del'], arrowup: ['arrowup', 'up'], arrowdown: ['arrowdown', 'down'], arrowleft: ['arrowleft', 'left'], arrowright: ['arrowright', 'right'], home: ['home'], end: ['end'], pageup: ['pageup'], pagedown: ['pagedown'] };\n            const comboRequirements = {\n                ctrl: !!modifiers?.ctrl,\n                alt: !!modifiers?.alt,\n                shift: !!modifiers?.shift,\n                meta: !!modifiers?.meta,\n            };\n            const buttonMap = { left: 0, middle: 1, right: 2 };\n            const touchSingle = !!modifiers?.single;\n            const touchMulti = !!modifiers?.multi;\n            const modifierKeys = modifiers ? _Okeys(modifiers) : [];\n            const allowedKeys = [];\n            for (const m of modifierKeys) {\n                const aliases = keyAliasMap[m.toLowerCase()];\n                if (aliases)\n                    allowedKeys.push(...aliases);\n            }\n            const allowedButtons = [];\n            for (const m of modifierKeys) {\n                const btn = buttonMap[m.toLowerCase()];\n                if (btn !== undefined)\n                    allowedButtons.push(btn);\n            }\n            const needKeyCheck = allowedKeys.length > 0 || comboRequirements.ctrl || comboRequirements.alt || comboRequirements.shift || comboRequirements.meta;\n            const needButtonCheck = allowedButtons.length > 0;\n            const needTouchCheck = touchSingle || touchMulti;\n            const passesFilters = (event) => {\n                const path = event.composedPath ? event.composedPath() : null;\n                const tgt = (path && path.length ? path[0] : event.target);\n                if (isOutside) {\n                    if (!tgt)\n                        return false;\n                    if (element instanceof Node && (element === tgt || element.contains(tgt)))\n                        return false;\n                }\n                if (onlySelf && event.target !== element)\n                    return false;\n                if (needTouchCheck) {\n                    if (event instanceof TouchEvent) {\n                        const tCount = event.touches.length;\n                        if (touchSingle && tCount !== 1)\n                            return false;\n                        if (touchMulti && tCount < 2)\n                            return false;\n                    }\n                    else\n                        return false;\n                }\n                if (needButtonCheck) {\n                    if (event instanceof MouseEvent) {\n                        if (!allowedButtons.includes(event.button))\n                            return false;\n                    }\n                    else\n                        return false;\n                }\n                if (needKeyCheck) {\n                    if (!(event instanceof KeyboardEvent))\n                        return false;\n                    const k = (event.key || '').toLowerCase();\n                    if (allowedKeys.length > 0 && !allowedKeys.includes(k))\n                        return false;\n                    const { ctrlKey, altKey, shiftKey, metaKey } = event;\n                    if ((comboRequirements.ctrl && !ctrlKey) || (comboRequirements.alt && !altKey) ||\n                        (comboRequirements.shift && !shiftKey) || (comboRequirements.meta && !metaKey))\n                        return false;\n                }\n                return true;\n            };\n            const runExpr = self._compileHandler(trimmed, element, (ev) => [ev, element]);\n            const createEventHandler = (event) => {\n                if (!passesFilters(event))\n                    return;\n                if (shouldPrevent)\n                    event.preventDefault();\n                if (shouldStop)\n                    event.stopPropagation();\n                if (!runExpr)\n                    return;\n                if (deferExec && typeof quMct === 'function') {\n                    const ev = event;\n                    quMct(() => self._safeExecute(() => runExpr(ev)));\n                    return;\n                }\n                self._safeExecute(() => runExpr(event));\n            };\n            const cfg = this.framework._getConfig();\n            const canDelegate = !!cfg.delegate && EV_DELEGATED.includes(eventName);\n            if (!isOutside && !isWindow && canDelegate) {\n                const remover = this.framework._registerDelegated(element, eventName, { filter: (e) => passesFilters(e), run: (e) => createEventHandler(e), once: !!modifiers?.once, comp: this });\n                this._addCleanupFunction(remover);\n            }\n            else {\n                const target = isWindow ? (typeof window !== 'undefined' ? window : element) : (isOutside ? (element?.ownerDocument || d || document) : element);\n                self._listen(target, eventName, createEventHandler, opts);\n            }\n        }\n        _createEvaluator(expression, isStatement = false) {\n            const key = `${isStatement ? 's' : 'r'}:${expression}`;\n            let fn = this._expressionCache.get(key);\n            if (!fn) {\n                try {\n                    fn = new Function('ctx', `with(ctx){${isStatement ? expression : `return (${expression})`}}`);\n                }\n                catch {\n                    expression = JSON.stringify(expression);\n                    fn = new Function('ctx', `with(ctx){${isStatement ? expression : `return (${expression})`}}`);\n                }\n                this._expressionCache.set(key, fn);\n            }\n            return fn;\n        }\n        _createElementEvaluator(expression, element) {\n            const self = this;\n            const compiled = self._createEvaluator(expression);\n            return () => {\n                const ctx = self._createContextProxy(undefined, element);\n                return self._safeExecute(() => compiled.call(self._createMethodContext(), ctx));\n            };\n        }\n        _extractArrowFunction(expression) {\n            let m = expression.match(/^\\s*\\(\\s*([^)]*?)\\s*\\)\\s*=>\\s*([\\s\\S]+)$/);\n            if (!m)\n                m = expression.match(/^\\s*([a-zA-Z_$][a-zA-Z0-9_$]*)\\s*=>\\s*([\\s\\S]+)$/);\n            if (!m)\n                return null;\n            const params = (m[1] || '')\n                .split(',')\n                .map(p => p.trim())\n                .filter(Boolean);\n            const body = _tr(m[2]);\n            const isBlock = body.startsWith('{') && body.endsWith('}');\n            const finalBody = isBlock ? body.slice(1, -1) : body;\n            return { paramsList: params, body: finalBody, isBlock };\n        }\n        _compileArrowForEvent(params, body, isBlock) {\n            const content = isBlock ? body : 'return ( ' + body + ' );';\n            return new Function('ctx', ...params, 'with(ctx){ ' + content + ' }');\n        }\n        _compileHandler(expression, element, mapArgs) {\n            const self = this;\n            const trimmed = _tr(expression);\n            if (!trimmed)\n                return null;\n            const arrow = self._extractArrowFunction(trimmed);\n            const thisCtx = self._createMethodContext();\n            if (arrow) {\n                const { paramsList, body, isBlock } = arrow;\n                const compiledArrow = self._compileArrowForEvent(paramsList, body, isBlock);\n                return (payload) => {\n                    const ctx = self._createContextProxy(payload, element);\n                    const args = mapArgs(payload);\n                    self._safeExecute(() => compiledArrow.call(thisCtx, ctx, ...args.slice(0, paramsList.length)));\n                };\n            }\n            const isStatement = trimmed.includes(';');\n            const executor = self._createEvaluator(trimmed, isStatement);\n            return (payload) => {\n                const ctx = self._createContextProxy(payload, element);\n                const result = executor.call(thisCtx, ctx);\n                if (typeof result === 'function') {\n                    _se(() => result.call(thisCtx, payload));\n                }\n            };\n        }\n        _assertMutable(parentKey, method) {\n            if (this._isInComputedEvaluation) {\n                throw new Error(`[x-tool] Mutation via '${String(parentKey)}.${method}()' is not allowed during computed evaluation.`);\n            }\n            if (this._isFrozen) {\n                throw new Error(`[x-tool] Mutation via '${String(parentKey)}.${method}()' is not allowed while component is frozen.`);\n            }\n        }\n        _wrapData(data, parentKey) {\n            if (!_FT_DR)\n                return data;\n            const isArr = ARRAY_ISARRAY(data);\n            const isSet = (typeof Set !== 'undefined') && (data instanceof Set);\n            const isMap = (typeof Map !== 'undefined') && (data instanceof Map);\n            if (!(Object.getPrototypeOf(data) === Object.prototype || isArr || isSet || isMap))\n                return data;\n            const self = this;\n            if (!this._deepReactiveCache)\n                this._deepReactiveCache = new WkMap();\n            if (this._deepReactiveCache.has(data))\n                return this._deepReactiveCache.get(data);\n            const makeCollectionWrapper = (name, fn, isArray) => function (...args) {\n                self._assertMutable(parentKey, name);\n                if (isArray) {\n                    const arr = this;\n                    const beforeLen = arr.length;\n                    const beforeFirst = arr[0];\n                    const beforeLast = arr[beforeLen - 1];\n                    const result = fn.apply(this, args);\n                    if (!self._isSealed && (arr.length !== beforeLen || arr[0] !== beforeFirst || arr[arr.length - 1] !== beforeLast)) {\n                        self._onDataChange(parentKey);\n                    }\n                    return result;\n                }\n                else {\n                    const before = this.size;\n                    const existed = (name === 'set') ? this.has(args[0]) : false;\n                    const result = fn.apply(this, args);\n                    if (!self._isSealed && (this.size !== before || (name === 'set' && !existed)))\n                        self._onDataChange(parentKey);\n                    return result;\n                }\n            };\n            const proxy = new Proxy(data, {\n                get: (target, p, receiver) => {\n                    const isCollection = isSet || isMap;\n                    if (isArr) {\n                        if (p === Symbol.iterator || p === 'length' || (typeof p === 'string' && /^\\d+$/.test(p))) {\n                            self._trackDependency(parentKey);\n                            if (p === Symbol.iterator)\n                                return Reflect.get(target, p, receiver);\n                        }\n                    }\n                    else if (isCollection) {\n                        if (p === 'size' || p === Symbol.iterator || p === 'keys' || p === 'values' || p === 'entries') {\n                            self._trackDependency(parentKey);\n                        }\n                    }\n                    else {\n                        self._trackDependency(parentKey);\n                    }\n                    const value = Reflect.get(target, p, receiver);\n                    if (isCollection && typeof value === 'function' && (p === Symbol.iterator || p === 'keys' || p === 'values' || p === 'entries')) {\n                        return function (...args) { return value.apply(target, args); };\n                    }\n                    if (typeof value === 'function') {\n                        if (isArr && ['push', 'pop', 'shift', 'unshift', 'splice', 'reverse', 'copyWithin', 'fill', 'sort'].includes(p)) {\n                            return makeCollectionWrapper(String(p), value, true).bind(target);\n                        }\n                        if (isSet && (p === 'add' || p === 'delete' || p === 'clear')) {\n                            return makeCollectionWrapper(String(p), value, false).bind(target);\n                        }\n                        if (isMap && (p === 'set' || p === 'delete' || p === 'clear')) {\n                            return makeCollectionWrapper(String(p), value, false).bind(target);\n                        }\n                    }\n                    return (value && typeof value === 'object') ? self._wrapData(value, parentKey) : value;\n                },\n                ownKeys: Reflect.ownKeys,\n                has: Reflect.has,\n                set: (target, p, value) => {\n                    if (self._isDestroyed || typeof p === 'symbol')\n                        return true;\n                    const key = String(parentKey) + '.' + String(p);\n                    if (self._isInComputedEvaluation)\n                        throw new Error(`[x-tool] Mutation of '${key}' is not allowed during computed evaluation.`);\n                    if (self._isFrozen)\n                        throw new Error(`[x-tool] Mutation of '${key}' is not allowed while component is frozen.`);\n                    const had = Reflect.has(target, p);\n                    const oldValue = had ? Reflect.get(target, p) : undefined;\n                    if (value && typeof value === 'object') {\n                        value = self._wrapData(value, parentKey);\n                    }\n                    if (!had) {\n                        _se(() => Reflect.defineProperty(target, p, { configurable: true, enumerable: true, writable: true, value }));\n                        if (!Reflect.has(target, p))\n                            Reflect.set(target, p, value);\n                        self._onDataChange(parentKey);\n                        return true;\n                    }\n                    if (oldValue === value)\n                        return true;\n                    Reflect.set(target, p, value);\n                    if (!self._isSealed)\n                        self._onDataChange(parentKey);\n                    return true;\n                },\n                deleteProperty: (target, p) => {\n                    const key = String(parentKey) + (typeof p === 'symbol' ? '' : '.' + String(p));\n                    if (self._isInComputedEvaluation)\n                        throw new Error(`[x-tool] Deletion of '${key}' is not allowed during computed evaluation.`);\n                    if (self._isFrozen)\n                        throw new Error(`[x-tool] Deletion of '${key}' is not allowed while component is frozen.`);\n                    const ok = Reflect.deleteProperty(target, p);\n                    if (ok && !self._isSealed)\n                        self._onDataChange(parentKey);\n                    return ok;\n                }\n            });\n            this._deepReactiveCache.set(data, proxy);\n            return proxy;\n        }\n        _createReactiveData(data) {\n            const self = this;\n            return new Proxy(data, {\n                get: (target, property, receiver) => {\n                    const value = Reflect.get(target, property, receiver);\n                    if (property === Symbol.iterator)\n                        return value;\n                    if (typeof property !== 'symbol') {\n                        self._trackDependency(property);\n                    }\n                    if (value && typeof value === 'object' && _FT_DR) {\n                        return self._wrapData(value, property);\n                    }\n                    return value;\n                },\n                ownKeys: (target) => Reflect.ownKeys(target),\n                has: (target, key) => Reflect.has(target, key),\n                set: (target, property, value, receiver) => {\n                    if (self._isDestroyed)\n                        return true;\n                    if (self._isFrozen)\n                        return true;\n                    if (self._isInComputedEvaluation) {\n                        throw new Error(`[x-tool] Mutation of '${String(property)}' is not allowed during computed evaluation.`);\n                    }\n                    if (property === Symbol.iterator && ARRAY_ISARRAY(target))\n                        return value;\n                    const oldValue = Reflect.get(target, property);\n                    const had = Reflect.has(target, property);\n                    if (!had) {\n                        try {\n                            Reflect.defineProperty(target, property, {\n                                configurable: true,\n                                enumerable: true,\n                                writable: true,\n                                value\n                            });\n                        }\n                        catch {\n                            Reflect.set(target, property, value, receiver);\n                        }\n                    }\n                    else {\n                        Reflect.set(target, property, value, receiver);\n                    }\n                    try {\n                        if (typeof property !== 'symbol' && isReactive(value)) {\n                            self._bridgeUtilReactive(String(property), value);\n                        }\n                    }\n                    catch { }\n                    if (!this._isSealed)\n                        this._onDataChange(property);\n                    if (this._propUpdateActive && property !== '$props' && !this._runningPropEffect) {\n                        const pc = target.$props;\n                        if (pc)\n                            pc[property] = value;\n                        const eff = this._propEffects[property];\n                        if (eff && !this._isSealed) {\n                            this._runningPropEffect = true;\n                            try {\n                                eff(value, oldValue);\n                            }\n                            finally {\n                                this._runningPropEffect = false;\n                            }\n                        }\n                    }\n                    return true;\n                }\n            });\n        }\n        _createMethodContext(_includeComputed = true) {\n            const self = this;\n            const specials = {\n                '$log': (..._args) => { },\n                '$destroy': () => self.destroy(),\n                '$forceUpdate': () => self._scheduleRender(),\n                '$addCleanupFunction': (fn) => self._addCleanupFunction(fn),\n                'Signals': {\n                    emit: (name, payload) => { self._emitSignal(String(name), payload); },\n                    connect: (name, handler) => { self._onSignal(String(name), handler); },\n                    disconnect: (name, handler) => { self._offSignal(String(name), handler); }\n                },\n                '$nextTick': (cb) => {\n                    if (cb) {\n                        self._nextTickQueue.push(cb);\n                        if (!self._renderScheduled)\n                            quMct(() => {\n                                if (!self._renderScheduled && self._nextTickQueue.length) {\n                                    const q = self._nextTickQueue.splice(0, self._nextTickQueue.length);\n                                    for (const fn of q) {\n                                        self._safeExecute(() => fn());\n                                    }\n                                }\n                            });\n                        return;\n                    }\n                    return new Promise(resolve => {\n                        self._nextTickQueue.push(() => resolve());\n                        if (!self._renderScheduled)\n                            quMct(() => {\n                                if (!self._renderScheduled && self._nextTickQueue.length) {\n                                    const q = self._nextTickQueue.splice(0, self._nextTickQueue.length);\n                                    for (const fn of q) {\n                                        self._safeExecute(() => fn());\n                                    }\n                                }\n                            });\n                    });\n                },\n                '$el': self._element,\n                '$id': self._id,\n                ...(FT_EXT_DIRS ? {\n                    '$refs': new Proxy({}, {\n                        get: (_t, refName) => {\n                            if (!refName)\n                                return null;\n                            return self._getSharedRef(refName);\n                        }\n                    }),\n                    '$ref': (refName, value) => {\n                        if (value === undefined)\n                            return self._getSharedRef(refName);\n                        self._framework._registerComponentRef(self, refName, value);\n                    }\n                } : {}),\n                '$isMounted': self._isMounted,\n                '$isDestroyed': self._isDestroyed,\n                '$isSealed': self._isSealed,\n                '$isFrozen': self._isFrozen,\n                '$parent': self._parent,\n                '$children': self._children,\n                '$seal': (on = true) => { self._setSealed(!!on); },\n                '$mutate': (fn) => {\n                    const prevMethod = self._isInMethodExecution;\n                    self._isMutationEnabled = false;\n                    if (self._isInComputedEvaluation) {\n                        throw new Error('[x-tool] $mutate cannot be used inside computed evaluation; computed getters must be pure.');\n                    }\n                    self._isInMethodExecution = false;\n                    try {\n                        return typeof fn === 'function' ? fn() : undefined;\n                    }\n                    finally {\n                        self._isInMethodExecution = prevMethod;\n                        self._isMutationEnabled = true;\n                        if (self._mutateDirty) {\n                            if (FT_C) {\n                                self._computedCache.clear();\n                                self._computedDeps.clear();\n                            }\n                            self._mutateDirty = false;\n                            self._render();\n                            self._callLifecycleHook('updated');\n                        }\n                        else {\n                            self._scheduleRender();\n                        }\n                    }\n                }\n            };\n            let data = self._data;\n            if (self._isInComputedEvaluation) {\n                data = (self._rawData);\n            }\n            return new Proxy(data, {\n                has: (_target, propStr) => {\n                    if (propStr in data)\n                        return true;\n                    if (FT_C && (propStr in self._computed))\n                        return true;\n                    if (propStr in specials)\n                        return true;\n                    if (propStr in self._methods)\n                        return true;\n                    return false;\n                },\n                get: (target, propStr) => {\n                    if (propStr in target) {\n                        self._trackDependency(propStr);\n                        const v = target[propStr];\n                        return v;\n                    }\n                    if (FT_C && (propStr in self._computed)) {\n                        return self._getComputedValue(propStr);\n                    }\n                    if (propStr in specials)\n                        return specials[propStr];\n                    return self._methods[propStr];\n                },\n                set: (_target, propStr, value) => {\n                    if (self._isInComputedEvaluation) {\n                        throw new Error(`[x-tool] Mutation of '${String(propStr)}' is not allowed during computed evaluation.`);\n                    }\n                    if (self._isFrozen) {\n                        throw new Error(`[x-tool] Mutation of '${String(propStr)}' is not allowed while component is frozen.`);\n                    }\n                    self._data[propStr] = value;\n                    return true;\n                }\n            });\n        }\n        _createContextProxy(event, targetElement, thisArg) {\n            const component = this;\n            let mergedScope = targetElement ? this._collectLoopScope(targetElement) : null;\n            if (this._initialContextScopes || this._parent?._initialContextScopes) {\n                const scopes = this._initialContextScopes || this._parent?._initialContextScopes;\n                for (const key in scopes) {\n                    if (!mergedScope || !(key in mergedScope)) {\n                        mergedScope = mergedScope || {};\n                        mergedScope[key] = scopes[key];\n                    }\n                }\n            }\n            const gWindow = (typeof window !== 'undefined' ? window : undefined);\n            const gDocument = (typeof document !== 'undefined' ? document : undefined);\n            const cfg = this.framework._getConfig();\n            const sandbox = !!cfg.sandboxExpressions;\n            const allow = new Set((cfg.allowGlobals || []).map(s => String(s)));\n            const ensureInvoker = () => this._currentInvoker || '__anonymous__';\n            const registerResource = (kind, setup) => {\n                const inv = ensureInvoker();\n                let byKind = this._invokerResources.get(inv);\n                if (!byKind) {\n                    byKind = new Map();\n                    this._invokerResources.set(inv, byKind);\n                }\n                const prev = byKind.get(kind);\n                if (prev) {\n                    _se(prev);\n                    byKind.delete(kind);\n                }\n                const cleanup = setup();\n                if (typeof cleanup === 'function') {\n                    const wrapped = () => {\n                        try {\n                            cleanup();\n                        }\n                        finally {\n                            byKind?.delete(kind);\n                        }\n                    };\n                    byKind.set(kind, wrapped);\n                    this._addCleanupFunction(wrapped);\n                }\n            };\n            const wrapTarget = (target) => {\n                if (!target || typeof target.addEventListener !== 'function')\n                    return target;\n                return new Proxy(target, {\n                    get: (obj, prop) => {\n                        if (prop === 'addEventListener') {\n                            return (eventName, handler, options) => {\n                                if (this._isSealed || this._isFrozen)\n                                    return;\n                                obj.addEventListener(eventName, handler, options);\n                                const optSig = typeof options === 'boolean' ? options : options?.capture ? '1' : '0';\n                                const key = 'listener:' + this._targetKey(obj) + ':' + eventName + ':' + optSig;\n                                registerResource(key, () => () => {\n                                    _se(() => obj.removeEventListener(eventName, handler, options));\n                                });\n                            };\n                        }\n                        if (prop === 'removeEventListener') {\n                            return (eventName, handler, options) => {\n                                _se(() => obj.removeEventListener(eventName, handler, options));\n                            };\n                        }\n                        if (prop === 'querySelector') {\n                            return (sel) => wrapTarget(obj.querySelector(sel));\n                        }\n                        if (prop === 'querySelectorAll') {\n                            return (sel) => Array.from(obj.querySelectorAll(sel)).map(wrapTarget);\n                        }\n                        if (prop === 'getElementById') {\n                            return (id) => wrapTarget(obj.getElementById(id));\n                        }\n                        if (prop === 'document') {\n                            const doc = obj.document;\n                            return wrapTarget(doc) || doc;\n                        }\n                        if (prop === 'defaultView') {\n                            const win = obj.defaultView;\n                            return wrapTarget(win) || win;\n                        }\n                        if (prop === 'body') {\n                            const body = obj.body;\n                            return wrapTarget(body) || body;\n                        }\n                        const value = obj[prop];\n                        if (typeof value === 'function') {\n                            return _se(() => value.bind(obj), value);\n                        }\n                        return value;\n                    }\n                });\n            };\n            const ctxSetTimeout = (fn, ms, ...args) => {\n                if (this._isSealed || this._isFrozen || this._isDestroyed)\n                    return undefined;\n                const id = gWindow?.setTimeout?.(thisArg ? fn.bind(thisArg) : fn, ms, ...args);\n                if (id != null)\n                    registerResource('timeout', () => () => { gWindow?.clearTimeout?.(id); });\n                return id;\n            };\n            const ctxSetInterval = (fn, ms, ...args) => {\n                if (this._isSealed || this._isFrozen)\n                    return undefined;\n                const id = gWindow?.setInterval?.(thisArg ? fn.bind(thisArg) : fn, ms, ...args);\n                if (id != null)\n                    registerResource('interval', () => () => { gWindow?.clearInterval?.(id); });\n                return id;\n            };\n            const ctxRequestAnimationFrame = (cb) => {\n                if (this._isSealed || this._isFrozen)\n                    return undefined;\n                const id = gWindow?.requestAnimationFrame?.(cb);\n                if (id != null)\n                    registerResource('raf', () => () => { gWindow?.cancelAnimationFrame?.(id); });\n                return id;\n            };\n            const wrapObserverCtor = (Orig, kind) => {\n                if (!Orig)\n                    return undefined;\n                return function (...observerArgs) {\n                    if (component._isSealed || component._isFrozen)\n                        return { observe() { }, disconnect() { }, unobserve() { } };\n                    if (thisArg) {\n                        observerArgs[0] = observerArgs[0].bind(thisArg);\n                    }\n                    const inst = new Orig(...observerArgs);\n                    registerResource('observer:' + kind, () => () => { _se(() => inst.disconnect()); });\n                    return inst;\n                };\n            };\n            const specials = {\n                '$target': targetElement || null,\n                '$event': event || null,\n                'Signals': {\n                    emit: (name, payload) => { component._emitSignal(String(name), payload); },\n                    connect: (name, handler) => { component._onSignal(String(name), handler); },\n                    disconnect: (name, handler) => { component._offSignal(String(name), handler); }\n                },\n                ...(FT_EXT_DIRS ? {\n                    '$refs': new Proxy({}, {\n                        get: (_t, refName) => {\n                            if (!refName)\n                                return null;\n                            return component._getSharedRef(refName);\n                        }\n                    }),\n                    '$ref': (refName, value) => {\n                        if (value === undefined)\n                            return component._getSharedRef(refName);\n                        component._framework._registerComponentRef(component, refName, value);\n                    }\n                } : {}),\n                ...(FT_RT && this.framework._routerEnabled() ? {\n                    'location': new Proxy(gWindow?.location || location, {\n                        get: (t, p) => t[p],\n                        set: (_t, p, v) => {\n                            const key = String(p);\n                            if (key === 'href') {\n                                try {\n                                    this.framework._navigate(String(v), true, 'program');\n                                }\n                                catch {\n                                    location.href = String(v);\n                                }\n                                return true;\n                            }\n                            _se(() => location[p] = v);\n                            return true;\n                        }\n                    })\n                } : {}),\n                ...(sandbox && !allow.has('setTimeout') ? {} : { 'setTimeout': ctxSetTimeout }),\n                ...(sandbox && !allow.has('clearTimeout') ? {} : { 'clearTimeout': (id) => { _se(() => gWindow?.clearTimeout?.(id)); } }),\n                ...(sandbox && !allow.has('setInterval') ? {} : { 'setInterval': ctxSetInterval }),\n                ...(sandbox && !allow.has('clearInterval') ? {} : { 'clearInterval': (id) => { _se(() => gWindow?.clearInterval?.(id)); } }),\n                ...(sandbox && !allow.has('requestAnimationFrame') ? {} : { 'requestAnimationFrame': ctxRequestAnimationFrame }),\n                ...(sandbox && !allow.has('cancelAnimationFrame') ? {} : { 'cancelAnimationFrame': (id) => { _se(() => gWindow?.cancelAnimationFrame?.(id)); } }),\n                ...(sandbox && !allow.has('MutationObserver') ? {} : { 'MutationObserver': wrapObserverCtor(gWindow?.MutationObserver, 'mutation') }),\n                ...(sandbox && !allow.has('ResizeObserver') ? {} : { 'ResizeObserver': wrapObserverCtor(gWindow?.ResizeObserver, 'resize') }),\n                ...(sandbox && !allow.has('IntersectionObserver') ? {} : { 'IntersectionObserver': wrapObserverCtor(gWindow?.IntersectionObserver, 'intersection') }),\n                ...(sandbox && !allow.has('window') ? {} : { 'window': wrapTarget(gWindow) }),\n                ...(sandbox && !allow.has('document') ? {} : { 'document': wrapTarget(gDocument) })\n            };\n            return new Proxy({}, {\n                get: (_t, propStr) => {\n                    if (mergedScope && propStr in mergedScope)\n                        return mergedScope[propStr];\n                    if (propStr in component._data)\n                        return component._data[propStr];\n                    if (propStr in component._computed)\n                        return component._getComputedValue(propStr);\n                    if (propStr in component._methods)\n                        return component._methods[propStr];\n                    if (propStr in specials)\n                        return specials[propStr];\n                    return undefined;\n                },\n                set: (_t, propStr, value) => {\n                    if (mergedScope) {\n                        let s = mergedScope;\n                        while (s) {\n                            if (Object.prototype.hasOwnProperty.call(s, propStr)) {\n                                s[propStr] = value;\n                                return true;\n                            }\n                            s = Object.getPrototypeOf(s);\n                        }\n                    }\n                    component._data[propStr] = value;\n                    return true;\n                },\n                has: (_t, propStr) => !!(mergedScope && propStr in mergedScope) ||\n                    propStr in component._data ||\n                    propStr in component._computed ||\n                    propStr in component._methods ||\n                    propStr in specials\n            });\n        }\n        _bindCustomDirective(element, _name, expression, directive, modifiers) {\n            const self = this;\n            const evaluator = self._createElementEvaluator(expression, element);\n            const directiveInfo = { type: 'custom', expression, customDirective: directive };\n            if (directive.bind) {\n                self._safeExecute(() => directive.bind(element, evaluator(), expression, self, modifiers, evaluator));\n            }\n            const update = () => {\n                if (directive.update)\n                    self._safeExecute(() => directive.update(element, evaluator(), expression, self, modifiers, evaluator));\n            };\n            const effect = self._createEffect(update);\n            directiveInfo.update = effect;\n            self._addDirective(element, directiveInfo);\n        }\n        _bindAttributeDirective(element, attributeName, expression) {\n            const self = this;\n            const evaluator = self._createElementEvaluator(expression, element);\n            const isSvg = element.namespaceURI === 'http://www.w3.org/2000/svg';\n            if (attributeName === 'class') {\n                const el = element;\n                if (!self._initialClassSets.get(el)) {\n                    const baseSet = new Set();\n                    const oc = isSvg ? (element.getAttribute('class') || '') : (element.className || '');\n                    if (oc)\n                        for (const cls of oc.split(/\\s+/)) {\n                            if (cls)\n                                baseSet.add(cls);\n                        }\n                    self._initialClassSets.set(el, baseSet);\n                }\n            }\n            const meta = self._resolveBindingMeta(element, attributeName);\n            const update = () => {\n                const value = evaluator();\n                if (attributeName === 'class') {\n                    const base = self._initialClassSets.get(element);\n                    if (typeof value === 'string') {\n                        const finalCls = base && base.size ? [...base].join(' ') + (value ? ' ' + value : '') : value || '';\n                        if (isSvg) {\n                            if (finalCls)\n                                element.setAttribute('class', finalCls);\n                            else\n                                element.removeAttribute('class');\n                        }\n                        else {\n                            element.className = finalCls;\n                        }\n                    }\n                    else if (ARRAY_ISARRAY(value)) {\n                        const tokens = value.filter(Boolean);\n                        const finalList = base && base.size ? [...base, ...tokens] : tokens;\n                        const finalStr = finalList.join(' ');\n                        if (isSvg) {\n                            if (finalStr)\n                                element.setAttribute('class', finalStr);\n                            else\n                                element.removeAttribute('class');\n                        }\n                        else {\n                            element.className = finalStr;\n                        }\n                    }\n                    else if (value && typeof value === 'object') {\n                        const classState = new Map();\n                        for (const raw in value) {\n                            if (!raw)\n                                continue;\n                            const on = !!value[raw];\n                            for (const tk of raw.split(/\\s+/)) {\n                                if (!tk)\n                                    continue;\n                                if (on || !classState.has(tk)) {\n                                    classState.set(tk, on);\n                                }\n                            }\n                        }\n                        const finalClasses = base ? [...base] : [];\n                        for (const [tk, on] of classState) {\n                            if (on && (!base || !base.has(tk))) {\n                                finalClasses.push(tk);\n                            }\n                        }\n                        const finalStr = finalClasses.join(' ');\n                        if (isSvg) {\n                            if (finalStr)\n                                element.setAttribute('class', finalStr);\n                            else\n                                element.removeAttribute('class');\n                        }\n                        else {\n                            element.className = finalStr;\n                        }\n                    }\n                    else if (value == null && base && base.size) {\n                        const baseStr = [...base].join(' ');\n                        if (isSvg) {\n                            if (baseStr)\n                                element.setAttribute('class', baseStr);\n                            else\n                                element.removeAttribute('class');\n                        }\n                        else {\n                            element.className = baseStr;\n                        }\n                    }\n                    else if (value == null) {\n                        element.removeAttribute('class');\n                    }\n                    return;\n                }\n                if (attributeName === STR_STYLE) {\n                    const el = element;\n                    if (typeof value === 'string') {\n                        el.style.cssText = value;\n                        return;\n                    }\n                    if (value && typeof value === 'object') {\n                        for (const k in value) {\n                            const v = value[k];\n                            const cssProp = k.startsWith('--') ? k : k.replace(/[A-Z]/g, m => '-' + m.toLowerCase());\n                            if (v != null)\n                                el.style.setProperty(cssProp, String(v));\n                            else\n                                el.style.removeProperty(cssProp);\n                        }\n                        return;\n                    }\n                    if (value == null)\n                        el.removeAttribute('style');\n                    return;\n                }\n                self._applyGenericBinding(element, attributeName, value, meta);\n            };\n            const effect = self._createEffect(update);\n            self._addDirective(element, { type: 'bind', expression, update: effect });\n        }\n        _collectLoopScope(el) {\n            if (!el)\n                return null;\n            if (!el.parentElement) {\n                const cur = el.__x_if_current;\n                if (cur && cur.parentElement) {\n                    el = cur;\n                }\n                else {\n                    const anchorParent = el.__x_if_anchorParent;\n                    if (anchorParent)\n                        el = anchorParent;\n                }\n            }\n            let node = el;\n            while (node) {\n                const s = node.__x_scope;\n                if (s)\n                    return s;\n                node = node.parentElement;\n            }\n            const merged = {};\n            node = el;\n            while (node) {\n                const scope = this._loopScopes.get(node);\n                if (scope)\n                    Object.assign(merged, scope);\n                if (node === this.element)\n                    break;\n                node = node.parentElement;\n            }\n            return _Okeys(merged).length ? merged : null;\n        }\n        _updateElementDirectives(root, force) {\n            if (!FT_EXT_DIRS)\n                return;\n            for (const [element, directives] of this._directives) {\n                for (const directive of directives) {\n                    if ((root === element || (element instanceof Element && root.contains(element))) && directive.update) {\n                        if (XTOOL_ENABLE_STATIC_DIRECTIVES && directive._static && !force)\n                            continue;\n                        directive.update();\n                    }\n                }\n            }\n        }\n        _updateElementDirectivesForVar(root, varName) {\n            const re = new RegExp('(^|[^$\\\\w])' + varName.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&') + '([^$\\\\w]|$)');\n            for (const [element, directives] of this._directives) {\n                if (!(root === element || (element instanceof Element && root.contains(element))))\n                    continue;\n                for (const directive of directives) {\n                    if (!directive.update)\n                        continue;\n                    const expr = directive.expression || '';\n                    if (re.test(expr)) {\n                        directive.update();\n                    }\n                }\n            }\n        }\n        _cleanupElementSubtree(root) {\n            if (!FT_EXT_DIRS)\n                return;\n            const toDelete = [];\n            for (const [element, directives] of this._directives) {\n                if (root === element || (element instanceof Element && root.contains(element))) {\n                    for (const directive of directives) {\n                        if (directive.type === 'custom' && directive.customDirective?.unbind) {\n                            _se(() => directive.customDirective.unbind(element, this));\n                        }\n                    }\n                    toDelete.push(element);\n                }\n            }\n            if (toDelete.length) {\n                for (const el of toDelete)\n                    this._directives.delete(el);\n            }\n        }\n        _bindForDirective(element, expression) {\n            if (!FT_EXT_DIRS)\n                return;\n            const self = this;\n            const match = expression.trim().match(/^(?:\\(\\s*([^,\\s]+)\\s*(?:,\\s*([^\\)]+))?\\s*\\)|([^,\\s]+))\\s+(in|of)\\s+(.+)$/);\n            if (!match) {\n                return;\n            }\n            const itemVar = match[1] || match[3];\n            const indexVar = match[2];\n            const listCode = match[5];\n            const keyAttrName = attrName('key');\n            const keyExpr = element.getAttribute(keyAttrName) || null;\n            if (keyExpr)\n                element.removeAttribute(keyAttrName);\n            const placeholder = d.createComment('x-for');\n            element.parentNode?.insertBefore(placeholder, element);\n            let templateToClone;\n            if (element[STR_TAGNAME] === STR_TEMPLATE) {\n                templateToClone = d.createElement('div');\n                templateToClone.style[STR_DISPLAY] = STR_CONTENTS;\n                templateToClone.appendChild(element.content.cloneNode(true));\n                element.parentNode?.removeChild(element);\n            }\n            else {\n                templateToClone = element;\n                element.parentNode?.removeChild(element);\n            }\n            const contextAnchor = placeholder.parentElement || self.element;\n            const listEval = self._createElementEvaluator(listCode.trim(), contextAnchor);\n            const keyEval = keyExpr ? self._createEvaluator(keyExpr) : null;\n            const BP_FOR = attrName('for');\n            const BP_KEY = attrName('key');\n            const BP_TEXT = attrName('text');\n            const BP_HTML = attrName('html');\n            const BP_DATA = attrName('data');\n            const buildBlueprint = (root) => {\n                const bp = [];\n                const walk = (el, path, isRootEl) => {\n                    if (!isRootEl && el.hasAttribute(BP_DATA))\n                        return;\n                    const isComponentTag = el[STR_TAGNAME] === 'COMPONENT';\n                    const scan = self._scanDirectiveAttrs(el, { skipRootFor: isRootEl });\n                    const dnames = scan.names.filter(n => n !== BP_KEY && (!isRootEl || n !== BP_FOR));\n                    const hasTextOrHtml = scan.names.includes(BP_TEXT) || scan.names.includes(BP_HTML);\n                    const forName = scan.forName;\n                    if (dnames.length) {\n                        if (forName) {\n                            bp.push({ path, directiveNames: [forName], hasTextOrHtml: hasTextOrHtml, forName });\n                            return;\n                        }\n                        bp.push({ path, directiveNames: dnames, hasTextOrHtml });\n                    }\n                    else {\n                        if (FT_TI && !hasTextOrHtml) {\n                            bp.push({ path, directiveNames: [], hasTextOrHtml });\n                        }\n                    }\n                    if (isComponentTag)\n                        return;\n                    let idx = 0;\n                    let child = el.firstElementChild;\n                    while (child) {\n                        const next = child.nextElementSibling;\n                        walk(child, path.concat(idx), false);\n                        idx++;\n                        child = next;\n                    }\n                };\n                walk(root, [], true);\n                return bp;\n            };\n            const hydrateFromBlueprint = (cloneRoot, bp) => {\n                for (let i = bp.length - 1; i >= 0; i--) {\n                    const instr = bp[i];\n                    const target = this._resolveNodeByPath(cloneRoot, instr.path);\n                    if (instr.forName) {\n                        const expr = target.getAttribute(instr.forName) || '';\n                        self._bindDirective(target, instr.forName, expr);\n                        continue;\n                    }\n                    for (let j = 0; j < instr.directiveNames.length; j++) {\n                        const dn = instr.directiveNames[j];\n                        const expr = target.getAttribute(dn) || '';\n                        if (dn === BP_KEY)\n                            continue;\n                        self._bindDirective(target, dn, expr);\n                    }\n                    if (FT_TI && !instr.hasTextOrHtml)\n                        self._bindTextInterpolationsIn(target);\n                }\n            };\n            const blueprint = buildBlueprint(templateToClone);\n            const instances = [];\n            const createScope = (item, idxOrKey, existing) => {\n                const scope = existing || {};\n                scope[itemVar] = item;\n                if (indexVar)\n                    scope[indexVar] = idxOrKey;\n                return scope;\n            };\n            const objIds = new WeakMap();\n            let objSeq = 0;\n            const extractId = (o) => {\n                if (!o || typeof o !== 'object')\n                    return null;\n                const v = o.id ?? o._id ?? o.key;\n                if (v == null)\n                    return null;\n                const t = typeof v;\n                return (t === 'string' || t === 'number') ? ('id:' + String(v)) : null;\n            };\n            const keyFor = (item) => {\n                if (item && typeof item === 'object') {\n                    const explicit = extractId(item);\n                    if (explicit)\n                        return explicit;\n                    let id = objIds.get(item);\n                    if (!id) {\n                        id = 'o#' + (++objSeq);\n                        objIds.set(item, id);\n                    }\n                    return id;\n                }\n                return 'p#' + (typeof item) + ':' + String(item);\n            };\n            const evalKeyExpr = (item, idxOrKey) => {\n                if (!keyEval)\n                    return null;\n                try {\n                    const base = self._createContextProxy(undefined, contextAnchor);\n                    const ctx = Object.create(base);\n                    ctx[itemVar] = item;\n                    if (indexVar)\n                        ctx[indexVar] = idxOrKey;\n                    const v = keyEval.call(self._createMethodContext(), ctx);\n                    const t = typeof v;\n                    return (t === 'string' || t === 'number') ? v : (v != null ? String(v) : null);\n                }\n                catch {\n                    return null;\n                }\n            };\n            const setNestedScopes = (el, initScope, firstEl) => {\n                const hasData = el.hasAttribute(attrName('data'));\n                const isComponentTag = el[STR_TAGNAME] === 'COMPONENT';\n                if (isComponentTag || hasData) {\n                    el.__x_scope = initScope;\n                    self._loopScopes.set(el, initScope);\n                    if (hasData && !self.framework._getComponentByElement(el)) {\n                        self.framework._bindInlineComponent(el, self);\n                    }\n                    if (isComponentTag)\n                        return;\n                }\n                let child = el.firstElementChild;\n                while (child) {\n                    const next = child.nextElementSibling;\n                    setNestedScopes(child, initScope, firstEl);\n                    child = next;\n                }\n            };\n            const update = () => {\n                const norm = self._safeExecute(() => {\n                    const result = listEval();\n                    if (_AisArr(result))\n                        return { list: result, keys: null, src: result };\n                    const tag = result && Object.prototype.toString.call(result);\n                    const isMap = typeof Map !== 'undefined' && (result instanceof Map || tag === '[object Map]' || (result && typeof result.get === 'function' && typeof result.set === 'function' && typeof result.keys === 'function'));\n                    if (isMap) {\n                        return { list: _Afrom(result.values()), keys: _Afrom(result.keys()), src: result };\n                    }\n                    const isSet = typeof Set !== 'undefined' && (result instanceof Set || tag === '[object Set]' || (result && typeof result.add === 'function' && typeof result.has === 'function' && typeof result.values === 'function'));\n                    if (isSet) {\n                        return { list: _Afrom(result.values()), keys: null, src: result };\n                    }\n                    if (result && typeof result[Symbol.iterator] === 'function') {\n                        return { list: _Afrom(result), keys: null, src: result };\n                    }\n                    if (result && typeof result === 'object') {\n                        const keys = Object.keys(result);\n                        const list = keys.map(k => result[k]);\n                        return { list, keys, src: result };\n                    }\n                    return { list: [], keys: null, src: null };\n                }, { list: [], keys: null, src: null });\n                const list = norm.list;\n                const keysArr = norm.keys;\n                const oldByObjKey = new Map();\n                const oldPrimQueues = new Map();\n                for (let i = 0; i < instances.length; i++) {\n                    const n = instances[i];\n                    const k = n.__x_for_key;\n                    const ps = n.__x_primSig;\n                    if (ps) {\n                        let q = oldPrimQueues.get(ps);\n                        if (!q) {\n                            q = [];\n                            oldPrimQueues.set(ps, q);\n                        }\n                        q.push(n);\n                    }\n                    else if (k) {\n                        oldByObjKey.set(k, n);\n                    }\n                }\n                const newNodes = new Array(list.length);\n                const parent = placeholder.parentNode;\n                for (let i = 0; i < list.length; i++) {\n                    const item = list[i];\n                    const idxOrKey = keysArr ? keysArr[i] : i;\n                    let node;\n                    let nodeKey;\n                    const explicitKey = keyEval ? evalKeyExpr(item, idxOrKey) : null;\n                    if (explicitKey != null) {\n                        nodeKey = 'k:' + String(explicitKey);\n                        const prev = oldByObjKey.get(nodeKey);\n                        if (prev) {\n                            node = prev;\n                            oldByObjKey.delete(nodeKey);\n                        }\n                    }\n                    if (!node) {\n                        const k = keyFor(item);\n                        if (k && k.startsWith('o#') || (k && k.startsWith('id:'))) {\n                            nodeKey = k;\n                            const prev = oldByObjKey.get(k);\n                            if (prev) {\n                                node = prev;\n                                oldByObjKey.delete(k);\n                            }\n                        }\n                        else if (k && k.startsWith('p#')) {\n                            const ps = k;\n                            const q = oldPrimQueues.get(ps);\n                            if (q && q.length) {\n                                node = q.shift();\n                            }\n                            if (node) {\n                                nodeKey = node.__x_for_key;\n                            }\n                            if (node) {\n                                node.__x_primSig = ps;\n                            }\n                        }\n                    }\n                    if (!node) {\n                        const clone = templateToClone.cloneNode(true);\n                        clone.removeAttribute('x-for');\n                        if (keyExpr)\n                            clone.removeAttribute(keyAttrName);\n                        const initScope = createScope(item, idxOrKey, {});\n                        clone.__x_scope = initScope;\n                        clone.__x_itemRef = item;\n                        if (indexVar)\n                            clone.__x_idxRef = idxOrKey;\n                        self._loopScopes.set(clone, initScope);\n                        _se(() => hydrateFromBlueprint(clone, blueprint));\n                        setNestedScopes(clone, initScope);\n                        _se(() => self.framework._discoverNestedNamed(clone, self));\n                        node = clone;\n                        node.__x_for_key = (nodeKey !== undefined) ? nodeKey : ('n#' + (++objSeq));\n                    }\n                    else {\n                        const existingScope = node.__x_scope;\n                        const prevIdxRef = node.__x_idxRef;\n                        const prevItemRef = node.__x_itemRef;\n                        const scope = createScope(item, idxOrKey, existingScope);\n                        node.__x_scope = scope;\n                        self._loopScopes.set(node, scope);\n                        let needsUpdate = false;\n                        if (prevItemRef !== item) {\n                            needsUpdate = true;\n                            node.__x_itemRef = item;\n                        }\n                        const indexChanged = !!indexVar && prevIdxRef !== idxOrKey;\n                        if (indexChanged) {\n                            needsUpdate = true;\n                            node.__x_idxRef = idxOrKey;\n                        }\n                        if (needsUpdate) {\n                            if (indexChanged && indexVar)\n                                self._updateElementDirectivesForVar(node, indexVar);\n                            else\n                                self._updateElementDirectives(node);\n                        }\n                    }\n                    if (nodeKey)\n                        node.__x_for_key = nodeKey;\n                    const sig = (!keyExpr && !(item && typeof item === 'object')) ? ('p#' + (typeof item) + ':' + String(item)) : undefined;\n                    node.__x_primSig = sig;\n                    newNodes[i] = node;\n                }\n                for (const [, node] of oldByObjKey) {\n                    if (node && node.parentNode) {\n                        self._cleanupElementSubtree(node);\n                        node.parentNode.removeChild(node);\n                    }\n                }\n                for (const [, queue] of oldPrimQueues) {\n                    for (const node of queue) {\n                        if (node && node.parentNode) {\n                            self._cleanupElementSubtree(node);\n                            node.parentNode.removeChild(node);\n                        }\n                    }\n                }\n                if (parent) {\n                    const oldIndexMap = new Map();\n                    for (let i = 0; i < instances.length; i++) {\n                        const k = instances[i].__x_for_key;\n                        if (k !== undefined)\n                            oldIndexMap.set(k, i);\n                    }\n                    const seq = new Array(newNodes.length);\n                    for (let i = 0; i < newNodes.length; i++) {\n                        const k = newNodes[i].__x_for_key;\n                        const oldIdx = oldIndexMap.has(k) ? oldIndexMap.get(k) : -1;\n                        seq[i] = oldIdx;\n                    }\n                    const { lisMask: lis } = this._computeLISMask(seq);\n                    const tailAnchor = instances.length ? (instances[instances.length - 1].nextSibling) : placeholder.nextSibling;\n                    let anchor = null;\n                    for (let i = newNodes.length - 1; i >= 0; i--) {\n                        const node = newNodes[i];\n                        const ref = anchor ?? tailAnchor;\n                        if (seq[i] === -1) {\n                            parent.insertBefore(node, ref);\n                        }\n                        else if (!lis[i]) {\n                            parent.insertBefore(node, ref);\n                        }\n                        anchor = node;\n                    }\n                    self.framework._processPending();\n                }\n                instances.length = 0;\n                for (let i = 0; i < newNodes.length; i++)\n                    instances.push(newNodes[i]);\n            };\n            const dir = { type: 'for', expression };\n            const effect = self._createEffect(update, dir);\n            dir.update = effect;\n            self._addDirective(placeholder, dir);\n        }\n        _resolveNodeByPath(root, path) {\n            if (!FT_EXT_DIRS)\n                return root;\n            let node = root;\n            for (let i = 0; i < path.length; i++) {\n                let idx = 0;\n                let child = node.firstElementChild;\n                while (child && idx < path[i]) {\n                    child = child.nextElementSibling;\n                    idx++;\n                }\n                node = child || node;\n            }\n            return node;\n        }\n        _computeLISMask(seq) {\n            if (!FT_EXT_DIRS)\n                return { lisMask: [], lisLen: 0 };\n            const predecessors = new Array(seq.length);\n            const tails = [];\n            const tailIdx = [];\n            for (let i = 0; i < seq.length; i++) {\n                const v = seq[i];\n                if (v < 0) {\n                    predecessors[i] = -1;\n                    continue;\n                }\n                let lo = 0, hi = tails.length;\n                while (lo < hi) {\n                    const mid = (lo + hi) >> 1;\n                    if (seq[tails[mid]] < v)\n                        lo = mid + 1;\n                    else\n                        hi = mid;\n                }\n                if (lo === tails.length) {\n                    tails.push(i);\n                }\n                else {\n                    tails[lo] = i;\n                }\n                predecessors[i] = lo > 0 ? tails[lo - 1] : -1;\n                tailIdx[lo] = i;\n            }\n            const lisLen = tails.length;\n            const lis = new Array(seq.length).fill(false);\n            let k = lisLen ? tails[lisLen - 1] : -1;\n            while (k >= 0) {\n                lis[k] = true;\n                k = predecessors[k];\n            }\n            return { lisMask: lis, lisLen };\n        }\n        _render() {\n            const self = this;\n            for (const directives of self._directives.values()) {\n                for (const dr of directives) {\n                    if (XTOOL_ENABLE_STATIC_DIRECTIVES && dr._static)\n                        continue;\n                    if (dr.update) {\n                        try {\n                            dr.update();\n                        }\n                        catch (error) {\n                            if (!(error instanceof ReferenceError)) { }\n                        }\n                    }\n                }\n            }\n        }\n    }\n    ReactiveComponent._BA = {\n        itemscope: 1, formnovalidate: 1, novalidate: 1, default: 1, readonly: 1\n    };\n    const xTool = new XToolFramework();\n    return xTool;\n}();\nif (typeof window !== 'undefined') {\n    const w = window;\n    w.XTool = XToolFramework;\n    w.FyneJS = XToolFramework;\n}\n//# sourceMappingURL=x-tool.js.map"],"mappings":"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","ignoreList":[]}
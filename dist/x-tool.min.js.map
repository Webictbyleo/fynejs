{"version":3,"file":"x-tool.min.js","names":["ARRAY_ISARRAY","Array","isArray","WkMap","WeakMap","quMct","queueMicrotask","XToolFramework","_Afrom","from","_AisArr","_Okeys","Object","keys","_logErr","STR_STYLE","STR_DISPLAY","STR_NONE","STR_TAGNAME","STR_TEMPLATE","STR_LENGTH","XTOOL_ENABLE_STATIC_DIRECTIVES","d","document","STR_CONTENTS","EV_DELEGATED","head","getElementById","style","createElement","id","textContent","appendChild","PFX","attrName","name","ReactiveComponent","attachToParent","parent","this","_parent","_addChild","_id","framework","_framework","element","_element","el","isBound","_isBound","v","isMounted","_isMounted","isDestroyed","_isDestroyed","_cancelUserResources","fn","_userResourceCleanups","delete","setFrozen","on","_isFrozen","_sealedBeforeFreeze","_isSealed","_scheduleRender","_setSealed","_addDirective","directive","existing","_directives","get","push","set","constructor","def","_propUpdateActive","_runningPropEffect","_beforeMountCalled","_children","_computed","_propEffects","_computedCache","Map","_computedDeps","_isInComputedEvaluation","_isInMethodExecution","_allEffects","Set","_hasComputed","_cleanupFunctions","_effectsToRun","_currentInvoker","_lastTimeoutByInvoker","_lastIntervalByInvoker","_lastRafByInvoker","_lastObserverByInvoker","mutation","resize","intersection","_eventListeners","_loopScopes","_expressionCache","_propertyDependencies","_activeEffect","_renderScheduled","_nextTickQueue","_initialClassSets","_rawData","_propParent","_callLifecycleHook","hookName","hook","_lifecycle","_safeExecute","_runWithGlobalInterception","_addCleanupFunction","wrapper","add","_addEventListenerWithCleanup","event","handler","options","addEventListener","_originalMethods","methods","computed","propEffects","length","mounted","unmounted","destroyed","updated","beforeMount","beforeUnmount","beforeDestroy","data","_data","_createReactiveData","_methods","_bindMethods","callBeforeMount","_onDataChange","_property","self","effectsToRun","directDeps","i","LastBatchId","cancelAnimationFrame","requestAnimationFrame","clear","effect","boundMethods","methodName","originalMethod","args","prev","prevInv","_getComputedValue","key","_trackDependency","has","computeFn","value","call","_createMethodContext","e","propKey","deps","includes","_render","q","splice","fallback","error","bindToElement","completeBinding","getContext","includeComputed","_applyAsyncTemplateResolved","_parseDirectives","_getComponentByElement","_registerElement","child","_removeChild","index","indexOf","src","String","test","body","trim","Function","undefined","_createContextProxy","apply","destroy","directives","type","customDirective","unbind","removeEventListener","cleanup","_propEffect","values","idx","_unregisterElement","_deepReactiveCache","_unregisterComponent","_initReactiveProps","expr","evalFn","update","obj","ctx","$props","k","processElement","isRoot","hasAttribute","isComponentTag","hasTextOrHtml","forAttr","a","attributes","n","startsWith","_bindDirective","attr","_bindTextInterpolationsIn","_walkElements","nodes","childNodes","node","nodeType","Node","TEXT_NODE","textNode","raw","nodeValue","__x_tool_ti","parentTag","parentElement","tagName","toLowerCase","inCode","segs","open","literal","slice","bs","p","charCodeAt","prefixEnd","repeat","close","hasExpr","some","s","hasEscaped","evaluators","filter","map","_createElementEvaluator","exprIndex","out","val","dirInfo","expression","_createEffect","processor","firstElementChild","next","nextElementSibling","directiveName","isShortBind","removeAttribute","_bindAttributeDirective","_bindSimpleDirective","_bindModelDirective","_bindIfDirective","_bindForDirective","prefix","rest","split","suffix","mods","modifiers","reduce","acc","m","_getCustomDirective","_bindCustomDirective","_bindEventDirective","updateFn","directiveRef","_static","found","evaluator","originalDisplay","_prevShown","innerHTML","property","isCheckbox","isNumeric","isMultiSelect","multiple","Reflect","defineProperty","configurable","enumerable","writable","getValueEvaluator","setValueEvaluator","_createEvaluator","checkboxValue","loopScope","_collectLoopScope","inferCheckboxValue","member","checked","sel","arr","opt","selected","setInputValue","t","parseFloat","getInputValue","currentVal","forEach","$value","placeholder","createComment","parentNode","insertBefore","__x_if_anchorParent","branches","makeActualElement","content","cloneNode","isTemplate","first","firstEval","__x_tool_bound","originalNodes","sib","isElse","isElseIf","getAttribute","branch","active","orig","removeChild","mountBranch","b","__x_if_current","nextSibling","cb","unmountBranch","eventName","trimmed","arrow","_extractArrowFunction","opts","once","passive","capture","onlySelf","shouldPrevent","prevent","shouldStop","stop","isOutside","outside","deferExec","defer","keyAliasMap","enter","esc","escape","space","tab","backspace","del","arrowup","arrowdown","arrowleft","arrowright","home","end","pageup","pagedown","comboRequirements","ctrl","alt","shift","meta","buttonMap","left","middle","right","touchSingle","single","touchMulti","multi","modifierKeys","allowedKeys","aliases","allowedButtons","btn","needKeyCheck","needButtonCheck","needTouchCheck","passesFilters","path","composedPath","tgt","target","contains","TouchEvent","tCount","touches","MouseEvent","button","KeyboardEvent","ctrlKey","altKey","shiftKey","metaKey","runExpr","thisCtx","compiledArrow","_compileArrowForEvent","paramsList","isBlock","mapArgs","_","isStatement","executor","result","createEventHandler","preventDefault","stopPropagation","ev","canDelegate","_getConfig","delegate","remover","_registerDelegated","run","comp","ownerDocument","compiled","match","params","Boolean","endsWith","_wrapData","parentKey","getPrototypeOf","prototype","proxy","Proxy","receiver","Symbol","iterator","Error","beforeLen","beforeFirst","beforeLast","ownKeys","had","oldValue","deleteProperty","ok","pc","eff","_includeComputed","specials","$log","$destroy","$forceUpdate","$addCleanupFunction","$nextTick","Promise","resolve","$el","$id","$isMounted","$isDestroyed","$isSealed","$isFrozen","$parent","$children","$seal","$mutate","prevMethod","propStr","_target","targetElement","component","mergedScope","scopeKeys","gWindow","window","gDocument","cfg","sandbox","sandboxExpressions","allow","allowGlobals","_lastListenerByTarget","wrapTarget","handlerMap","makeKey","JSON","stringify","prop","_receiver","inv","eKey","invMap","evMap","rem","size","invKey","rec","res","querySelector","list","querySelectorAll","doc","w","defaultView","bind","_timeoutRemovers","_intervalRemovers","_rafRemovers","wrapObserverCtor","Orig","kind","Wrapped","observe","disconnect","unobserve","inst","store","$target","$event","setTimeout","ms","clearTimeout","r","setInterval","clearInterval","MutationObserver","ResizeObserver","IntersectionObserver","_t","_name","directiveInfo","attributeName","baseSet","oc","className","cls","elAny","propName","camel","replace","c","toUpperCase","isBooleanProp","hasNonFunctionProp","isKnownBooleanAttr","_BA","base","join","tokens","tk","classList","toggle","cssText","assign","boolVal","setAttribute","normalized","parts","cur","anchorParent","merged","scope","_updateElementDirectives","root","Element","itemVar","indexVar","listCode","templateToClone","contextAnchor","listEval","instances","createScope","item","idxOrKey","dir","norm","keysArr","pop","minLen","Math","min","frag","createDocumentFragment","start","clone","ref","dr","itemscope","formnovalidate","novalidate","default","_components","_byEl","_pending","_config","_customDirectives","_namedComponentDefs","_delegated","_delegatedRootBound","registerComponent","definition","_getRegisteredComponentDef","_preDiscoveryTasks","init","config","container","debug","staticDirectives","_hpf","async","_applyPrefixInitialCSS","allSettled","_autoDiscoverComponents","_ensureRootObserver","_ensureDelegation","readyState","_inflightComponentLoads","_lazyComponentSources","loadComponents","sources","items","mode","tasks","it","_fetchAndEvalComponent","catch","then","inferredName","status","entry","trigger","promise","finally","requestIdleCallback","timeout","results","settled","failed","createComponent","_generateComponentId","componentElements","_bindElementAsComponent","reusable","_instantiateNamedComponent","_processPending","components","lastComponent","maybe","parentForEval","dataExpression","parentCtx","_parseDataExpression","initExpr","existingMounted","isConnected","Date","now","random","toString","substring","componentId","_log","retries","baseDelay","html","strings","str","attempt","fetch","cache","statusText","text","code","err","delay","pow","_rootObserver","records","addedNodes","removedNodes","stack","_onComponentSourceChanged","ro","childList","subtree","attributeFilter","source","parentComp","lazy","par","props","dynamicPropObj","rawPropExpression","propExpr","initDef","baseData","makeData","compDef","originalChildren","firstChild","template","applyTemplate","tpl","slots","slotEl","matched","replaceChild","tplVal","nested","cancelBubble","h","captureEvents","bubbleEvents","l","XTool","FyneJS"],"sourceRoot":"./dist","sources":["dist/x-tool.js"],"sourcesContent":["\"use strict\";\nconst ARRAY_ISARRAY = Array.isArray;\nconst WkMap = WeakMap;\nconst quMct = queueMicrotask;\nconst FT_C = true;\nconst FT_TI = typeof __FEAT_TEXT_INTERP__ === 'boolean' ? __FEAT_TEXT_INTERP__ : true;\nconst _FT_DR = typeof __FEAT_DEEP_REACTIVE__ === 'boolean' ? __FEAT_DEEP_REACTIVE__ : true;\nconst FT_IFB = typeof __FEAT_IF_BRANCHES__ === 'boolean' ? __FEAT_IF_BRANCHES__ : true;\nconst XToolFramework = function () {\n    const _Afrom = Array.from;\n    const _AisArr = ARRAY_ISARRAY;\n    const _Okeys = Object.keys;\n    const _logErr = (..._args) => { };\n    const STR_STYLE = 'style';\n    const STR_DISPLAY = 'display';\n    const STR_NONE = 'none';\n    const STR_TAGNAME = 'tagName';\n    const STR_TEMPLATE = 'TEMPLATE';\n    const STR_LENGTH = 'length';\n    let XTOOL_ENABLE_STATIC_DIRECTIVES = true;\n    const d = (typeof document !== 'undefined' ? document : null);\n    const STR_CONTENTS = 'contents';\n    const EV_CLICK = 'click', EV_INPUT = 'input', EV_CHANGE = 'change', EV_KEYDOWN = 'keydown', EV_KEYUP = 'keyup';\n    const EV_DELEGATED = [EV_CLICK, EV_INPUT, EV_CHANGE, EV_KEYDOWN, EV_KEYUP];\n    try {\n        if (d && d.head && !d.getElementById('x-tool-initial-css')) {\n            const style = d.createElement(STR_STYLE);\n            style.id = 'x-tool-initial-css';\n            style.textContent = '[x-show],[x-if],[x-else],[x-else-if],[x\\\\:show],[x\\\\:if],[x\\\\:else],[x\\\\:else-if]{display:none;}';\n            d.head.appendChild(style);\n        }\n    }\n    catch { }\n    let PFX = 'x';\n    const attrName = (name) => `${PFX}-${name}`;\n    class XToolFramework {\n        constructor() {\n            this._components = new Map();\n            this._byEl = new WkMap();\n            this._pending = [];\n            this._config = {};\n            this._customDirectives = new Map();\n            this._namedComponentDefs = new Map();\n            this._delegated = new WkMap();\n            this._delegatedRootBound = false;\n            this.directive = (name, directive) => {\n                if (name.startsWith(PFX + '-')) {\n                    throw new Error(`Custom directive names should not start with \"${PFX}-\". Use: XTool.directive(\"my-directive\", ...)`);\n                }\n                this._customDirectives.set(name, directive);\n                return this;\n            };\n            this.registerComponent = (definition) => {\n                if (!definition || !definition.name)\n                    throw new Error('registerComponent requires a name');\n                const name = definition.name.toLowerCase();\n                if (this._namedComponentDefs.has(name))\n                    throw new Error(`Component name \"${name}\" already registered`);\n                this._namedComponentDefs.set(name, definition);\n                return this;\n            };\n            this._getRegisteredComponentDef = (name) => this._namedComponentDefs.get(name.toLowerCase());\n            this._getCustomDirective = (name) => this._customDirectives.get(name);\n            this._getConfig = () => this._config;\n            this._preDiscoveryTasks = [];\n            this.init = (config = {}) => {\n                this._config = { container: 'body', debug: false, staticDirectives: true, ...config };\n                if (typeof this._config.staticDirectives === 'boolean') {\n                    XTOOL_ENABLE_STATIC_DIRECTIVES = this._config.staticDirectives;\n                }\n                const _hpf = this._config.prefix;\n                if (_hpf && typeof _hpf === 'string' && _hpf[STR_LENGTH] > 0) {\n                    PFX = _hpf;\n                }\n                else {\n                    PFX = 'x';\n                }\n                const start = async () => {\n                    this._applyPrefixInitialCSS();\n                    if (this._preDiscoveryTasks.length) {\n                        try {\n                            await Promise.allSettled(this._preDiscoveryTasks);\n                        }\n                        catch { }\n                    }\n                    this._autoDiscoverComponents();\n                    const c = d?.querySelector(this._config.container);\n                    if (c) {\n                        this._ensureRootObserver(c);\n                        if (this._config.delegate)\n                            this._ensureDelegation(c);\n                    }\n                };\n                if (d && d.readyState === 'loading') {\n                    d.addEventListener('DOMContentLoaded', () => { void start(); });\n                }\n                else if (!d || d.readyState === 'complete' || d.readyState === 'interactive') {\n                    void start();\n                }\n                return this;\n            };\n            this._inflightComponentLoads = new Map();\n            this._lazyComponentSources = new Map();\n            this.loadComponents = (sources) => {\n                const items = sources.map(s => typeof s === 'string' ? { path: s, mode: 'preload', name: undefined } : { path: s.path, mode: (s.mode || 'preload'), name: s.name });\n                const tasks = [];\n                for (const it of items) {\n                    if (it.mode === 'defer') {\n                        const p = this._fetchAndEvalComponent(it.path).catch(() => { throw new Error('load failed'); });\n                        this._preDiscoveryTasks.push(p);\n                        tasks.push(p.then(() => { }));\n                    }\n                    else if (it.mode === 'lazy') {\n                        const inferredName = (it.name || it.path.split('/').pop() || '').replace(/\\.(mjs|js|ts)(\\?.*)?$/i, '').toLowerCase();\n                        if (inferredName && !this._lazyComponentSources.has(inferredName)) {\n                            this._lazyComponentSources.set(inferredName, { path: it.path, status: 'pending' });\n                            if (d && d.querySelector(`component[source=\"${inferredName}\"]`)) {\n                                const entry = this._lazyComponentSources.get(inferredName);\n                                const trigger = () => {\n                                    if (entry.status !== 'pending')\n                                        return;\n                                    entry.status = 'loading';\n                                    entry.promise = this._fetchAndEvalComponent(entry.path)\n                                        .then(() => { entry.status = 'loaded'; })\n                                        .catch(() => { entry.status = 'error'; })\n                                        .finally(() => { try {\n                                        this._autoDiscoverComponents();\n                                    }\n                                    catch { } });\n                                };\n                                try {\n                                    window.requestIdleCallback ? window.requestIdleCallback(trigger, { timeout: 2000 }) : setTimeout(trigger, 50);\n                                }\n                                catch {\n                                    setTimeout(trigger, 50);\n                                }\n                            }\n                        }\n                    }\n                    else {\n                        const p = this._fetchAndEvalComponent(it.path).catch(() => { throw new Error('load failed'); });\n                        tasks.push(p);\n                    }\n                }\n                return Promise.allSettled(tasks).then(results => {\n                    try {\n                        this._autoDiscoverComponents();\n                    }\n                    catch { }\n                    const settled = results.length;\n                    const failed = results.filter(r => r.status === 'rejected').length;\n                    return { settled, failed };\n                });\n            };\n            this.createComponent = (definition) => {\n                const component = new ReactiveComponent(this._generateComponentId(), definition, this);\n                this._components.set(component.id, component);\n                component.callBeforeMount();\n                return component;\n            };\n            this._autoDiscoverComponents = () => {\n                const container = d?.querySelector(this._config.container);\n                if (!container)\n                    return;\n                const componentElements = container.querySelectorAll(`[${attrName('data')}]`);\n                for (const element of componentElements) {\n                    if (!this._getComponentByElement(element))\n                        this._bindElementAsComponent(element);\n                }\n                const reusable = container.querySelectorAll('component[source]');\n                for (const el of reusable) {\n                    if (!this._getComponentByElement(el))\n                        this._instantiateNamedComponent(el);\n                }\n                this._processPending();\n                if (componentElements[STR_LENGTH] === 0 && !this._getComponentByElement(container)) {\n                    const components = _Afrom(this._components.values());\n                    const lastComponent = components[components[STR_LENGTH] - 1];\n                    if (lastComponent && !lastComponent.isBound) {\n                        lastComponent.bindToElement(container);\n                    }\n                }\n            };\n            this._processPending = () => {\n                if (!this._pending[STR_LENGTH])\n                    return;\n                for (const p of this._pending) {\n                    let cur = p.el.parentElement;\n                    let parent;\n                    while (cur && !parent) {\n                        const maybe = this._getComponentByElement(cur);\n                        if (maybe)\n                            parent = maybe;\n                        else\n                            cur = cur.parentElement;\n                    }\n                    if (parent) {\n                        p.comp.attachToParent(parent);\n                    }\n                }\n                for (const p of this._pending)\n                    p.comp.completeBinding();\n                this._pending = [];\n            };\n            this._bindElementAsComponent = (element, parentForEval) => {\n                const dataExpression = element.getAttribute(attrName('data'));\n                let data = {};\n                if (dataExpression) {\n                    element.removeAttribute(attrName('data'));\n                    try {\n                        if (parentForEval) {\n                            let parentCtx = {};\n                            try {\n                                parentCtx = parentForEval._createMethodContext?.() || {};\n                            }\n                            catch {\n                                parentCtx = {};\n                            }\n                            const evalFn = new Function('parent', `with(parent){ return (${dataExpression}) }`);\n                            data = evalFn(parentCtx);\n                        }\n                        else {\n                            data = this._parseDataExpression(dataExpression);\n                        }\n                        if (data.methods) {\n                            data = { methods: data.methods, data: { ...data } };\n                        }\n                        else {\n                            data = { data: { ...data } };\n                        }\n                        if (parentForEval) {\n                            data.data.$parent = parentForEval;\n                        }\n                    }\n                    catch (e) {\n                    }\n                }\n                const comp = this.createComponent(data);\n                comp.element = element;\n                comp.callBeforeMount();\n                this._registerElement(comp.element, comp);\n                this._pending.push({ el: element, comp });\n                const initExpr = element.getAttribute(attrName('init'));\n                if (initExpr) {\n                    element.removeAttribute(attrName('init'));\n                    const existingMounted = comp._lifecycle?.mounted;\n                    comp._lifecycle.mounted = function () {\n                        if (existingMounted) {\n                            try {\n                                existingMounted.call(this);\n                            }\n                            catch { }\n                        }\n                        const evaluator = new Function('ctx', 'with(ctx){' + initExpr + '} ');\n                        quMct(() => {\n                            if (comp.isDestroyed || !comp.element || !comp.element.isConnected)\n                                return;\n                            try {\n                                const ctx = comp._createMethodContext?.() || comp.getContext?.() || {};\n                                const result = evaluator(ctx);\n                                if (typeof result === 'function') {\n                                    try {\n                                        result();\n                                    }\n                                    catch { }\n                                }\n                            }\n                            catch { }\n                        });\n                    };\n                }\n            };\n            this._generateComponentId = () => 'component_' + Date.now() + '_' + Math.random().toString(36).substring(2, 9);\n            this._parseDataExpression = (expression) => {\n                try {\n                    return new Function('return ' + expression.trim())();\n                }\n                catch {\n                    return {};\n                }\n            };\n            this._unregisterComponent = (componentId) => { this._components.delete(componentId); };\n            this._log = (..._args) => { };\n            this._registerElement = (element, component) => {\n                this._byEl.set(element, component);\n            };\n            this._unregisterElement = (element) => { try {\n                this._byEl.delete(element);\n            }\n            catch { } };\n        }\n        _fetchAndEvalComponent(path, retries = 2, baseDelay = 300) {\n            const existing = this._inflightComponentLoads.get(path);\n            if (existing)\n                return existing;\n            const self = this;\n            const html = (strings, ...values) => strings.reduce((acc, str, i) => acc + str + (i < values.length ? values[i] : ''), '');\n            const attempt = (n) => {\n                return fetch(path, { cache: 'no-cache' }).then(res => {\n                    if (!res.ok)\n                        throw new Error(res.status + ' ' + res.statusText);\n                    return res.text();\n                }).then(code => {\n                    const wrapped = code + `\\n//# sourceURL=${path}`;\n                    new Function('XTool', 'html', wrapped)(self, html);\n                }).catch(err => {\n                    if (n >= retries)\n                        throw err;\n                    const delay = baseDelay * Math.pow(2, n);\n                    return new Promise(resolve => setTimeout(resolve, delay)).then(() => attempt(n + 1));\n                });\n            };\n            const p = attempt(0).finally(() => { this._inflightComponentLoads.delete(path); });\n            this._inflightComponentLoads.set(path, p);\n            return p;\n        }\n        _applyPrefixInitialCSS() {\n            if (!d)\n                return;\n            if (PFX === 'x')\n                return;\n            const id = `x-tool-initial-css-${PFX}`;\n            if (d.head && !d.getElementById(id)) {\n                const style = d.createElement(STR_STYLE);\n                style.id = id;\n                style.textContent = `[${PFX}-show],[${PFX}-if],[${PFX}-else],[${PFX}-else-if],[${PFX}\\\\:show],[${PFX}\\\\:if],[${PFX}\\\\:else],[${PFX}\\\\:else-if]{display:none;}`;\n                d.head.appendChild(style);\n            }\n        }\n        _ensureRootObserver(container) {\n            if (this._rootObserver || typeof MutationObserver === 'undefined')\n                return;\n            this._rootObserver = new MutationObserver(records => {\n                for (const r of records) {\n                    if (r.type === 'childList') {\n                        for (let i = 0; i < r.addedNodes.length; i++) {\n                            const n = r.addedNodes[i];\n                            if (n.nodeType !== 1)\n                                continue;\n                            const el = n;\n                            if (el[STR_TAGNAME] === 'COMPONENT') {\n                                const src = el.getAttribute('source');\n                                if (src && !this._getComponentByElement(el))\n                                    this._instantiateNamedComponent(el);\n                            }\n                        }\n                        for (let i = 0; i < r.removedNodes.length; i++) {\n                            const n = r.removedNodes[i];\n                            if (n.nodeType !== 1)\n                                continue;\n                            const el = n;\n                            quMct(() => {\n                                if (el.isConnected)\n                                    return;\n                                const stack = [el];\n                                while (stack.length) {\n                                    const cur = stack.pop();\n                                    const comp = this._getComponentByElement(cur);\n                                    if (comp && !comp.isDestroyed) {\n                                        try {\n                                            comp.destroy();\n                                        }\n                                        catch { }\n                                    }\n                                    let child = cur.firstElementChild;\n                                    while (child) {\n                                        stack.push(child);\n                                        child = child.nextElementSibling;\n                                    }\n                                }\n                            });\n                        }\n                    }\n                    else if (r.type === 'attributes') {\n                        const target = r.target;\n                        if (target && target[STR_TAGNAME] === 'COMPONENT') {\n                            if (r.attributeName === 'source') {\n                                this._onComponentSourceChanged(target);\n                            }\n                            else if (r.attributeName === 'readonly') {\n                                const comp = this._getComponentByElement(target);\n                                if (comp) {\n                                    try {\n                                        const ro = target.hasAttribute('readonly');\n                                        comp.setFrozen(!!ro);\n                                    }\n                                    catch { }\n                                }\n                            }\n                        }\n                    }\n                }\n                this._processPending();\n            });\n            this._rootObserver.observe(container, { childList: true, subtree: true, attributes: true, attributeFilter: ['source', 'readonly'] });\n        }\n        _onComponentSourceChanged(el) {\n            const src = (el.getAttribute('source') || '').trim();\n            const existing = this._getComponentByElement(el);\n            if (!src) {\n                if (existing && !existing.isDestroyed) {\n                    try {\n                        existing.destroy();\n                    }\n                    catch { }\n                }\n                el.innerHTML = '';\n                return;\n            }\n            if (existing && !existing.isDestroyed) {\n                try {\n                    existing.destroy();\n                }\n                catch { }\n            }\n            el.innerHTML = '';\n            this._instantiateNamedComponent(el);\n        }\n        _instantiateNamedComponent(el) {\n            const source = el.getAttribute('source');\n            if (!source)\n                return;\n            let def = this._getRegisteredComponentDef(source);\n            if (!def) {\n                const name = source.toLowerCase();\n                const lazy = this._lazyComponentSources?.get(name);\n                if (lazy) {\n                    if (lazy.status === 'pending') {\n                        lazy.status = 'loading';\n                        lazy.promise = this._fetchAndEvalComponent(lazy.path)\n                            .then(() => { lazy.status = 'loaded'; })\n                            .catch(() => { lazy.status = 'error'; })\n                            .finally(() => { try {\n                            this._autoDiscoverComponents();\n                        }\n                        catch { } });\n                    }\n                    lazy.promise?.then(() => { try {\n                        const again = this._getRegisteredComponentDef(source);\n                        if (again)\n                            this._instantiateNamedComponent(el);\n                    }\n                    catch { } });\n                }\n                return;\n            }\n            let parentComp;\n            let par = el.parentElement;\n            while (par && !parentComp) {\n                const maybe = this._getComponentByElement(par);\n                if (maybe)\n                    parentComp = maybe;\n                else\n                    par = par.parentElement;\n            }\n            let props = null;\n            let dynamicPropObj = null;\n            let rawPropExpression = null;\n            if (!props)\n                props = {};\n            const propExpr = el.getAttribute(attrName('prop'));\n            if (propExpr) {\n                rawPropExpression = propExpr;\n                if (parentComp) {\n                    try {\n                        const fn = new Function('ctx', 'with(ctx){return (' + propExpr + ')}');\n                        const ctx = parentComp.getContext(true);\n                        dynamicPropObj = fn(ctx);\n                    }\n                    catch {\n                        dynamicPropObj = null;\n                    }\n                }\n                else {\n                    try {\n                        dynamicPropObj = new Function('return (' + propExpr + ')')();\n                    }\n                    catch {\n                        dynamicPropObj = null;\n                    }\n                }\n                if (dynamicPropObj && typeof dynamicPropObj === 'object')\n                    for (const k in dynamicPropObj)\n                        if (!(k in props))\n                            props[k] = String(dynamicPropObj[k]);\n                el.removeAttribute(attrName('prop'));\n            }\n            let baseData = {};\n            if (def.makeData) {\n                try {\n                    baseData = def.makeData(props) || {};\n                }\n                catch {\n                    baseData = {};\n                }\n            }\n            if (def.data) {\n                for (const k in def.data) {\n                    baseData[k] = def.data[k];\n                }\n            }\n            for (const k in props) {\n                if (!(k in baseData))\n                    baseData[k] = props[k];\n            }\n            baseData.$props = props;\n            let initDef;\n            if (typeof def.init === 'function') {\n                try {\n                    const maybe = def.init(props);\n                    initDef = (maybe && typeof maybe === 'object') ? maybe : undefined;\n                }\n                catch {\n                    initDef = undefined;\n                }\n            }\n            const compDef = {\n                data: baseData,\n                methods: { ...(def.methods || {}), ...(initDef?.methods || {}) },\n                computed: { ...(def.computed || {}), ...(initDef?.computed || {}) },\n                propEffects: { ...(def.propEffects || {}), ...(initDef?.propEffects || {}) },\n                mounted: initDef?.mounted || def.mounted,\n                unmounted: initDef?.unmounted || def.unmounted,\n                beforeMount: initDef?.beforeMount || def.beforeMount,\n                beforeUnmount: initDef?.beforeUnmount || def.beforeUnmount,\n                updated: initDef?.updated || def.updated,\n                destroyed: initDef?.destroyed || def.destroyed,\n                beforeDestroy: initDef?.beforeDestroy || def.beforeDestroy\n            };\n            const comp = this.createComponent(compDef);\n            comp.element = el;\n            const originalChildren = [];\n            while (el.firstChild) {\n                const n = el.firstChild;\n                originalChildren.push(n);\n                el.removeChild(n);\n            }\n            if (def.template) {\n                const applyTemplate = (tpl) => {\n                    el.innerHTML = tpl;\n                    const slots = el.querySelectorAll('slot');\n                    if (slots.length) {\n                        for (const slotEl of slots) {\n                            const name = slotEl.getAttribute('name');\n                            let matched = [];\n                            if (name) {\n                                matched = originalChildren.filter(n => n.nodeType === 1 && n.getAttribute('slot') === name);\n                            }\n                            else {\n                                matched = originalChildren.filter(n => n.nodeType !== 1 || !n.hasAttribute('slot'));\n                            }\n                            if (matched.length) {\n                                const frag = d.createDocumentFragment();\n                                for (const n of matched)\n                                    frag.appendChild(n);\n                                slotEl.parentNode?.replaceChild(frag, slotEl);\n                            }\n                        }\n                    }\n                };\n                const tplVal = def.template;\n                if (typeof tplVal === 'string') {\n                    applyTemplate(tplVal);\n                }\n                else if (typeof tplVal === 'function') {\n                    try {\n                        const res = tplVal();\n                        if (res && typeof res.then === 'function') {\n                            el.innerHTML = '';\n                            res.then(html => { applyTemplate(html || ''); try {\n                                comp._applyAsyncTemplateResolved();\n                            }\n                            catch { } });\n                        }\n                        else {\n                            applyTemplate(String(res || ''));\n                        }\n                    }\n                    catch {\n                        el.innerHTML = '';\n                    }\n                }\n                else if (tplVal && typeof tplVal.then === 'function') {\n                    el.innerHTML = '';\n                    tplVal.then(html => { applyTemplate(html || ''); try {\n                        comp._applyAsyncTemplateResolved();\n                    }\n                    catch { } });\n                }\n            }\n            else {\n                for (const n of originalChildren)\n                    el.appendChild(n);\n            }\n            this._registerElement(el, comp);\n            try {\n                const nested = el.querySelectorAll(`[${attrName('data')}]`);\n                for (const node of nested) {\n                    if (!this._getComponentByElement(node))\n                        this._bindElementAsComponent(node, comp);\n                }\n            }\n            catch { }\n            this._pending.push({ el, comp });\n            if (rawPropExpression && parentComp) {\n                try {\n                    comp._initReactiveProps(rawPropExpression, parentComp);\n                }\n                catch { }\n            }\n            this._processPending();\n        }\n        _getComponentByElement(element) { return this._byEl.get(element); }\n        observe(_element) { }\n        _ensureDelegation(container) {\n            if (this._delegatedRootBound)\n                return;\n            const root = container;\n            const handler = (e) => {\n                let cur = e.target;\n                while (cur && cur !== root.parentElement) {\n                    if (e.cancelBubble)\n                        break;\n                    const map = this._delegated.get(cur);\n                    if (map) {\n                        const list = map.get(e.type);\n                        if (list && list.length) {\n                            for (const h of [...list]) {\n                                try {\n                                    if (h.comp && h.comp.isDestroyed) {\n                                        const i = list.indexOf(h);\n                                        if (i > -1)\n                                            list.splice(i, 1);\n                                        continue;\n                                    }\n                                    if (!h.filter || h.filter(e)) {\n                                        h.run(e);\n                                        if (h.once) {\n                                            const idx = list.indexOf(h);\n                                            if (idx > -1)\n                                                list.splice(idx, 1);\n                                        }\n                                    }\n                                }\n                                catch { }\n                            }\n                        }\n                    }\n                    cur = cur.parentElement;\n                }\n            };\n            const captureEvents = ['keydown', 'keyup'];\n            const bubbleEvents = ['click', 'input', 'change'];\n            for (const ev of captureEvents)\n                root.addEventListener(ev, handler, true);\n            for (const ev of bubbleEvents)\n                root.addEventListener(ev, handler, false);\n            this._delegatedRootBound = true;\n        }\n        _registerDelegated(element, event, entry) {\n            let map = this._delegated.get(element);\n            if (!map) {\n                map = new Map();\n                this._delegated.set(element, map);\n            }\n            let list = map.get(event);\n            if (!list) {\n                list = [];\n                map.set(event, list);\n            }\n            list.push(entry);\n            return () => {\n                try {\n                    const m = this._delegated.get(element);\n                    const l = m?.get(event);\n                    if (!l)\n                        return;\n                    const idx = l.indexOf(entry);\n                    if (idx > -1)\n                        l.splice(idx, 1);\n                }\n                catch { }\n            };\n        }\n    }\n    class ReactiveComponent {\n        attachToParent(parent) {\n            this._parent = parent;\n            parent._addChild(this);\n        }\n        get id() { return this._id; }\n        get framework() { return this._framework; }\n        get element() { return this._element; }\n        set element(el) { this._element = el; }\n        get isBound() { return this._isBound; }\n        set isBound(v) { this._isBound = v; }\n        get isMounted() { return this._isMounted; }\n        set isMounted(v) { this._isMounted = v; }\n        get isDestroyed() { return this._isDestroyed; }\n        set isDestroyed(v) { this._isDestroyed = v; }\n        _cancelUserResources() {\n            for (const fn of Array.from(this._userResourceCleanups)) {\n                try {\n                    fn();\n                }\n                catch { }\n                this._userResourceCleanups.delete(fn);\n            }\n        }\n        setFrozen(on) {\n            if (on === this._isFrozen)\n                return;\n            this._isFrozen = on;\n            if (on) {\n                this._sealedBeforeFreeze = this._isSealed;\n                this._isSealed = true;\n                this._cancelUserResources();\n            }\n            else {\n                if (this._sealedBeforeFreeze !== null) {\n                    this._isSealed = this._sealedBeforeFreeze;\n                }\n                else {\n                    this._isSealed = false;\n                }\n                this._sealedBeforeFreeze = null;\n                try {\n                    this._scheduleRender();\n                }\n                catch { }\n            }\n        }\n        _setSealed(on) {\n            if (on === this._isSealed)\n                return;\n            this._isSealed = on;\n            if (on) {\n                this._cancelUserResources();\n            }\n        }\n        _addDirective(element, directive) {\n            const existing = this._directives.get(element) || [];\n            existing.push(directive);\n            this._directives.set(element, existing);\n        }\n        constructor(id, def, framework) {\n            this._propUpdateActive = false;\n            this._runningPropEffect = false;\n            this._element = null;\n            this._isBound = false;\n            this._isMounted = false;\n            this._isDestroyed = false;\n            this._beforeMountCalled = false;\n            this._children = [];\n            this._parent = null;\n            this._computed = {};\n            this._propEffects = {};\n            this._computedCache = new Map();\n            this._computedDeps = new Map();\n            this._isInComputedEvaluation = false;\n            this._isInMethodExecution = false;\n            this._allEffects = new Set();\n            this._hasComputed = false;\n            this._directives = new Map();\n            this._cleanupFunctions = new Set();\n            this._isSealed = false;\n            this._isFrozen = false;\n            this._sealedBeforeFreeze = null;\n            this._userResourceCleanups = new Set();\n            this._effectsToRun = new Set();\n            this._currentInvoker = null;\n            this._lastTimeoutByInvoker = new Map();\n            this._lastIntervalByInvoker = new Map();\n            this._lastRafByInvoker = new Map();\n            this._lastObserverByInvoker = {\n                mutation: new Map(),\n                resize: new Map(),\n                intersection: new Map()\n            };\n            this._eventListeners = [];\n            this._loopScopes = new WkMap();\n            this._expressionCache = new Map();\n            this._propertyDependencies = new Map();\n            this._activeEffect = null;\n            this._renderScheduled = false;\n            this._nextTickQueue = [];\n            this._initialClassSets = new WkMap();\n            this._rawData = {};\n            this._propParent = null;\n            this._callLifecycleHook = (hookName) => {\n                const hook = this._lifecycle[hookName];\n                if (typeof hook === 'function') {\n                    this._safeExecute(() => this._runWithGlobalInterception(hook, []));\n                }\n            };\n            this._addCleanupFunction = (fn) => {\n                if (typeof fn !== 'function')\n                    return undefined;\n                const wrapper = () => {\n                    try {\n                        fn();\n                    }\n                    catch {\n                        _logErr();\n                    }\n                    try {\n                        this._cleanupFunctions.delete(wrapper);\n                    }\n                    catch { }\n                };\n                this._cleanupFunctions.add(wrapper);\n                return () => { try {\n                    this._cleanupFunctions.delete(wrapper);\n                }\n                catch { } };\n            };\n            this._addEventListenerWithCleanup = (element, event, handler, options) => {\n                element.addEventListener(event, handler, options);\n                this._eventListeners.push({ element, event, handler, options });\n            };\n            this._id = id;\n            this._framework = framework;\n            this._originalMethods = def.methods || {};\n            this._computed = def.computed || {};\n            this._propEffects = def.propEffects || {};\n            this._hasComputed = !!(def.computed && Object.keys(def.computed).length);\n            this._lifecycle = {\n                mounted: def.mounted,\n                unmounted: def.unmounted || def.destroyed,\n                updated: def.updated,\n                beforeMount: def.beforeMount,\n                beforeUnmount: def.beforeUnmount || def.beforeDestroy\n            };\n            this._rawData = def.data || {};\n            this._data = this._createReactiveData(this._rawData || {});\n            this._methods = this._bindMethods();\n        }\n        callBeforeMount() {\n            if (!this._beforeMountCalled) {\n                this._callLifecycleHook('beforeMount');\n                this._beforeMountCalled = true;\n            }\n        }\n        _onDataChange(_property) {\n            if (this.isBound) {\n                const self = this;\n                const effectsToRun = self._effectsToRun;\n                const directDeps = self._propertyDependencies.get(_property);\n                if (directDeps)\n                    for (let i = 0; i < directDeps.length; i++)\n                        effectsToRun.add(directDeps[i]);\n                if (self.LastBatchId) {\n                    cancelAnimationFrame(self.LastBatchId);\n                }\n                self.LastBatchId = requestAnimationFrame(() => {\n                    if (FT_C)\n                        self._computedCache.clear();\n                    self.LastBatchId = null;\n                    if (self.isDestroyed)\n                        return;\n                    for (const effect of effectsToRun)\n                        self._safeExecute(effect);\n                    effectsToRun.clear();\n                    if (self._hasComputed || !XTOOL_ENABLE_STATIC_DIRECTIVES) {\n                        self._scheduleRender();\n                    }\n                    self._callLifecycleHook('updated');\n                });\n            }\n        }\n        _bindMethods() {\n            const boundMethods = {};\n            for (const methodName in this._originalMethods) {\n                const originalMethod = this._originalMethods[methodName];\n                boundMethods[methodName] = (...args) => {\n                    const prev = this._isInMethodExecution;\n                    const prevInv = this._currentInvoker;\n                    this._isInMethodExecution = true;\n                    this._currentInvoker = methodName;\n                    try {\n                        return this._safeExecute(() => this._runWithGlobalInterception(originalMethod, args));\n                    }\n                    finally {\n                        this._isInMethodExecution = prev;\n                        this._currentInvoker = prevInv;\n                    }\n                };\n            }\n            return boundMethods;\n        }\n        _getComputedValue(key) {\n            if (!FT_C)\n                return undefined;\n            this._trackDependency(key);\n            if (this._computedCache.has(key))\n                return this._computedCache.get(key);\n            try {\n                const computeFn = this._computed[key];\n                this._isInComputedEvaluation = true;\n                this._computedDeps.set(key, new Set());\n                const value = computeFn.call(this._createMethodContext());\n                this._isInComputedEvaluation = false;\n                this._computedCache.set(key, value);\n                return value;\n            }\n            catch (e) {\n                this._isInComputedEvaluation = false;\n                return undefined;\n            }\n        }\n        _trackDependency(propKey) {\n            if (!this._activeEffect)\n                return;\n            let deps = this._propertyDependencies.get(propKey);\n            if (!deps) {\n                deps = [];\n                this._propertyDependencies.set(propKey, deps);\n            }\n            if (!deps.includes(this._activeEffect))\n                deps.push(this._activeEffect);\n        }\n        _scheduleRender() {\n            if (this._isSealed || this._isFrozen)\n                return;\n            if (this._renderScheduled)\n                return;\n            this._renderScheduled = true;\n            requestAnimationFrame(() => {\n                this._renderScheduled = false;\n                this._render();\n                if (this._nextTickQueue && this._nextTickQueue.length) {\n                    const q = this._nextTickQueue.splice(0, this._nextTickQueue.length);\n                    for (const fn of q) {\n                        try {\n                            fn();\n                        }\n                        catch { }\n                    }\n                }\n            });\n        }\n        _safeExecute(fn, fallback) {\n            try {\n                return fn();\n            }\n            catch (error) {\n                console.error(error);\n                return fallback;\n            }\n        }\n        bindToElement(element) {\n            if (this._isBound)\n                return;\n            this._element = element;\n            if (!this._beforeMountCalled) {\n                this.callBeforeMount();\n            }\n            this.completeBinding();\n        }\n        getContext(includeComputed = true) {\n            return this._createMethodContext(includeComputed);\n        }\n        _applyAsyncTemplateResolved() {\n            if (!this._element)\n                return;\n            try {\n                this._parseDirectives(this._element);\n            }\n            catch { }\n            this._scheduleRender();\n        }\n        completeBinding() {\n            if (this._isBound || !this._element)\n                return;\n            if (!this._framework._getComponentByElement(this._element))\n                this._framework._registerElement(this._element, this);\n            this._isBound = true;\n            this._isMounted = true;\n            this._parseDirectives(this._element);\n            this._render();\n            this._callLifecycleHook('mounted');\n        }\n        _addChild(child) {\n            if (!this._children.includes(child)) {\n                this._children.push(child);\n            }\n        }\n        _removeChild(child) {\n            const index = this._children.indexOf(child);\n            if (index > -1) {\n                this._children.splice(index, 1);\n            }\n        }\n        _runWithGlobalInterception(fn, args) {\n            try {\n                const src = String(fn);\n                if (!/\\[native code\\]/.test(src)) {\n                    let body = src.trim();\n                    if (!/^function[\\s\\(]/.test(body) && !/^[\\w\\$_][\\w\\d\\$_]*\\s*=>/.test(body) && !/^\\(.*?\\)\\s*=>/.test(body)) {\n                        body = 'function ' + body;\n                    }\n                    const trySrc = 'with(ctx){ const f = (' + body + '); return f.apply(thisArg, argsArray); }';\n                    const wrapper = new Function('thisArg', 'argsArray', 'ctx', trySrc);\n                    return wrapper.call(undefined, this._createMethodContext(), args, this._createContextProxy(undefined, undefined));\n                }\n            }\n            catch {\n            }\n            return fn.apply(this._createMethodContext(), args);\n        }\n        destroy() {\n            const self = this;\n            if (self._isDestroyed)\n                return;\n            self._callLifecycleHook('beforeUnmount');\n            for (const child of self._children) {\n                if (!child.isDestroyed)\n                    child.destroy();\n            }\n            if (self._parent) {\n                self._parent._removeChild(self);\n            }\n            for (const [element, directives] of self._directives) {\n                for (const directive of directives) {\n                    if (directive.type === 'custom' && directive.customDirective?.unbind) {\n                        try {\n                            directive.customDirective.unbind(element, self);\n                        }\n                        catch {\n                            _logErr();\n                        }\n                    }\n                }\n            }\n            self._directives.clear();\n            for (const { element, event, handler, options } of self._eventListeners) {\n                element.removeEventListener(event, handler, options);\n            }\n            self._eventListeners = [];\n            for (const cleanup of Array.from(self._cleanupFunctions)) {\n                try {\n                    cleanup();\n                }\n                catch {\n                    _logErr();\n                }\n            }\n            self._cleanupFunctions.clear();\n            self._computedCache.clear();\n            self._expressionCache.clear();\n            self._propertyDependencies.clear();\n            if (self._propParent && self._propEffect) {\n                for (const deps of self._propParent._propertyDependencies.values()) {\n                    const idx = deps.indexOf(self._propEffect);\n                    if (idx > -1)\n                        deps.splice(idx, 1);\n                }\n            }\n            if (self._element)\n                self._framework._unregisterElement(self._element);\n            self._callLifecycleHook('unmounted');\n            self._isDestroyed = true;\n            self._isMounted = false;\n            self._isBound = false;\n            self._children = [];\n            self._parent = null;\n            this._deepReactiveCache = new WkMap;\n            this._effectsToRun.clear();\n            self._element = null;\n            quMct(() => self._framework._unregisterComponent(self._id));\n        }\n        _initReactiveProps(expr, parent) {\n            if (!expr || !parent)\n                return;\n            this._propParent = parent;\n            let evalFn;\n            try {\n                evalFn = new Function('ctx', 'with(ctx){return (' + expr + ')}');\n            }\n            catch {\n                return;\n            }\n            const update = () => {\n                parent._activeEffect = update;\n                let obj;\n                try {\n                    const ctx = parent.getContext(true);\n                    obj = evalFn(ctx);\n                }\n                catch {\n                    obj = null;\n                }\n                parent._activeEffect = null;\n                if (obj && typeof obj === 'object') {\n                    this._data.$props = this._data.$props || {};\n                    this._propUpdateActive = true;\n                    for (const k in obj) {\n                        const v = obj[k];\n                        if (this._data[k] !== v)\n                            this._data[k] = v;\n                    }\n                    this._propUpdateActive = false;\n                }\n            };\n            this._propEffect = update;\n            update();\n        }\n        _parseDirectives(element) {\n            const self = this;\n            let processedElements = 0;\n            const processElement = (el, isRoot = false) => {\n                if (!isRoot && (el.hasAttribute(attrName('data')) || this._framework._getComponentByElement(el))) {\n                    return false;\n                }\n                const isComponentTag = el[STR_TAGNAME] === 'COMPONENT';\n                const directives = [];\n                let hasTextOrHtml = false;\n                let forAttr = null;\n                for (const a of el.attributes) {\n                    const n = a.name;\n                    if (n.startsWith(PFX + '-') || n.startsWith(PFX + ':')) {\n                        directives.push(a);\n                        if (!hasTextOrHtml && (n === attrName('text') || n === attrName('html')))\n                            hasTextOrHtml = true;\n                        if (!forAttr && n === attrName('for'))\n                            forAttr = a;\n                    }\n                }\n                if (directives.length > 0) {\n                    processedElements++;\n                    if (forAttr) {\n                        self._bindDirective(el, forAttr.name, forAttr.value);\n                        return false;\n                    }\n                    for (const attr of directives)\n                        self._bindDirective(el, attr.name, attr.value);\n                }\n                if (FT_TI && !hasTextOrHtml)\n                    self._bindTextInterpolationsIn(el);\n                return isRoot || !isComponentTag;\n            };\n            processElement(element, true);\n            self._walkElements(element, processElement);\n        }\n        _bindTextInterpolationsIn(el) {\n            const nodes = Array.from(el.childNodes);\n            for (const node of nodes) {\n                if (node.nodeType !== Node.TEXT_NODE)\n                    continue;\n                const textNode = node;\n                const raw = textNode.nodeValue || '';\n                if (textNode.__x_tool_ti || raw.indexOf('{{') === -1)\n                    continue;\n                const parentTag = (textNode.parentElement?.tagName || '').toLowerCase();\n                const inCode = parentTag === 'code' || parentTag === 'pre';\n                const segs = [];\n                let i = 0;\n                while (i < raw.length) {\n                    const open = raw.indexOf('{{', i);\n                    if (open === -1) {\n                        segs.push({ literal: raw.slice(i) });\n                        break;\n                    }\n                    let bs = 0;\n                    for (let p = open - 1; p >= 0 && raw.charCodeAt(p) === 92; p--)\n                        bs++;\n                    if (bs > 0) {\n                        const prefixStart = i;\n                        const prefixEnd = open - bs;\n                        if (prefixEnd > prefixStart)\n                            segs.push({ literal: raw.slice(prefixStart, prefixEnd) });\n                        if (bs > 1)\n                            segs.push({ literal: '\\\\'.repeat(bs - 1) });\n                        const close = raw.indexOf('}}', open + 2);\n                        if (close === -1) {\n                            segs.push({ literal: raw.slice(open, raw.length) });\n                            i = raw.length;\n                            break;\n                        }\n                        segs.push({ literal: raw.slice(open, close + 2) });\n                        i = close + 2;\n                        continue;\n                    }\n                    else {\n                        if (open > i)\n                            segs.push({ literal: raw.slice(i, open) });\n                        const close = raw.indexOf('}}', open + 2);\n                        if (close === -1) {\n                            segs.push({ literal: raw.slice(open) });\n                            i = raw.length;\n                            break;\n                        }\n                        const expr = raw.slice(open + 2, close).trim();\n                        if (expr)\n                            segs.push({ expr });\n                        else\n                            segs.push({ literal: '' });\n                        i = close + 2;\n                        continue;\n                    }\n                }\n                const hasExpr = segs.some(s => s.expr);\n                const hasEscaped = segs.some(s => s.literal && s.literal.includes('{{'));\n                if (!hasExpr && !hasEscaped)\n                    continue;\n                textNode.__x_tool_ti = true;\n                const evaluators = hasExpr && !inCode ? segs.filter(s => s.expr).map(s => this._createElementEvaluator(s.expr, el)) : [];\n                let exprIndex = 0;\n                const update = () => {\n                    exprIndex = 0;\n                    let out = '';\n                    for (const s of segs) {\n                        if (s.literal != null) {\n                            out += s.literal;\n                        }\n                        else if (s.expr) {\n                            if (inCode) {\n                                out += '{{ ' + s.expr + ' }}';\n                            }\n                            else {\n                                const val = evaluators[exprIndex++]();\n                                out += (val == null ? '' : String(val));\n                            }\n                        }\n                    }\n                    if (textNode.textContent !== out)\n                        textNode.textContent = out;\n                };\n                const dirInfo = { type: 'text-interpolation', expression: raw, update: undefined };\n                this._addDirective(el, dirInfo);\n                const effect = this._createEffect(update, dirInfo);\n                dirInfo.update = effect;\n            }\n        }\n        _walkElements(parent, processor) {\n            let child = parent.firstElementChild;\n            while (child) {\n                const next = child.nextElementSibling;\n                if (processor(child))\n                    this._walkElements(child, processor);\n                child = next;\n            }\n        }\n        _bindDirective(element, directiveName, expression) {\n            const self = this;\n            const isShortBind = directiveName.startsWith(PFX + ':');\n            const type = directiveName.slice(PFX.length + 1);\n            if (isShortBind || type === 'class' || type === STR_STYLE) {\n                element.removeAttribute(directiveName);\n                return self._bindAttributeDirective(element, type, expression);\n            }\n            if (type === 'text' || type === 'html' || type === 'show') {\n                element.removeAttribute(directiveName);\n                return self._bindSimpleDirective(element, expression, type);\n            }\n            const handled = type === 'model' ? (element.removeAttribute(directiveName), self._bindModelDirective(element, expression), true)\n                : type === 'if' ? (element.removeAttribute(directiveName), self._bindIfDirective(element, expression), true)\n                    : type === 'for' ? (element.removeAttribute(directiveName), self._bindForDirective(element, expression), true)\n                        : false;\n            if (handled)\n                return;\n            if (type.indexOf(':') > -1) {\n                const [prefix, rest] = type.split(':', 2);\n                const [suffix, ...mods] = rest.split('.');\n                const modifiers = mods.reduce((acc, m) => { if (m)\n                    acc[m] = true; return acc; }, {});\n                if (prefix === 'on') {\n                    element.removeAttribute(directiveName);\n                    const customDirective = self.framework._getCustomDirective(suffix);\n                    return customDirective\n                        ? self._bindCustomDirective(element, suffix, expression, customDirective, modifiers)\n                        : self._bindEventDirective(element, suffix, expression, modifiers);\n                }\n                element.removeAttribute(directiveName);\n                return self._bindAttributeDirective(element, suffix, expression);\n            }\n        }\n        _createEffect(updateFn, directiveRef) {\n            const effect = () => {\n                this._activeEffect = effect;\n                try {\n                    updateFn();\n                }\n                finally {\n                    this._activeEffect = null;\n                }\n            };\n            effect();\n            this._allEffects.add(effect);\n            if (XTOOL_ENABLE_STATIC_DIRECTIVES && directiveRef && directiveRef._static === undefined) {\n                let found = false;\n                for (const deps of this._propertyDependencies.values()) {\n                    if (deps.includes(effect)) {\n                        found = true;\n                        break;\n                    }\n                }\n                directiveRef._static = !found;\n            }\n            return effect;\n        }\n        _bindSimpleDirective(element, expression, type) {\n            if (type === 'class' || type === STR_STYLE) {\n                return this._bindAttributeDirective(element, type, expression);\n            }\n            const evaluator = this._createElementEvaluator(expression, element);\n            let originalDisplay;\n            if (type === 'show') {\n                const el = element;\n                originalDisplay = el.style[STR_DISPLAY] !== STR_NONE ? el.style[STR_DISPLAY] : undefined;\n            }\n            let _prevShown = undefined;\n            const update = () => {\n                const value = evaluator();\n                const el = element;\n                switch (type) {\n                    case 'text':\n                        el.textContent = String(value);\n                        break;\n                    case 'html':\n                        el.innerHTML = String(value || '');\n                        break;\n                    case 'show':\n                        const next = !!value;\n                        if (_prevShown === next)\n                            return;\n                        _prevShown = next;\n                        el.style[STR_DISPLAY] = next ? (originalDisplay || '') : STR_NONE;\n                        break;\n                }\n            };\n            const dirInfo = { type, expression, update: undefined, originalDisplay };\n            this._addDirective(element, dirInfo);\n            const effect = this._createEffect(update, dirInfo);\n            dirInfo.update = effect;\n        }\n        _bindModelDirective(element, property) {\n            const isCheckbox = element.type === 'checkbox';\n            const isNumeric = element.type === 'number' || element.type === 'range';\n            const isMultiSelect = element.tagName === 'SELECT' && element.multiple === true;\n            if (!Reflect.has(this._data, property)) {\n                Reflect.defineProperty(this._data, property, {\n                    'configurable': true,\n                    'enumerable': true,\n                    'writable': true\n                });\n            }\n            const getValueEvaluator = this._createElementEvaluator(property, element);\n            const setValueEvaluator = this._createEvaluator(`${property} = $value`, true);\n            const inferCheckboxValue = () => {\n                if (element.hasAttribute('value'))\n                    return element.value;\n                const loopScope = this._collectLoopScope(element);\n                if (loopScope) {\n                    const keys = Object.keys(loopScope);\n                    if (keys.length === 1)\n                        return loopScope[keys[0]];\n                }\n                return element.value;\n            };\n            const checkboxValue = isCheckbox ? inferCheckboxValue() : undefined;\n            const getInputValue = () => {\n                if (isCheckbox) {\n                    if (Array.isArray(getValueEvaluator()) && checkboxValue !== undefined) {\n                        return element.checked ? checkboxValue : undefined;\n                    }\n                    if (element.hasAttribute('value'))\n                        return element.checked ? element.value : undefined;\n                    return element.checked;\n                }\n                if (isMultiSelect) {\n                    const sel = element;\n                    const values = [];\n                    for (let i = 0; i < sel.options.length; i++) {\n                        const opt = sel.options[i];\n                        if (opt.selected)\n                            values.push(opt.value);\n                    }\n                    return values;\n                }\n                return isNumeric ? parseFloat(element.value) || 0 : element.value;\n            };\n            const setInputValue = (value) => {\n                if (isCheckbox) {\n                    if (Array.isArray(value)) {\n                        const member = element.hasAttribute('value') ? element.value : checkboxValue;\n                        element.checked = member != null ? value.includes(member) : false;\n                    }\n                    else {\n                        element.checked = !!value;\n                    }\n                    return;\n                }\n                if (isMultiSelect) {\n                    const sel = element;\n                    const arr = Array.isArray(value) ? value : [];\n                    for (let i = 0; i < sel.options.length; i++) {\n                        const opt = sel.options[i];\n                        opt.selected = arr.includes(opt.value);\n                    }\n                    return;\n                }\n                element.value = String(value ?? (isNumeric ? 0 : ''));\n            };\n            this._createEffect(() => setInputValue(getValueEvaluator()));\n            const ctx = this._createContextProxy(undefined, element);\n            const updateData = () => {\n                const raw = getInputValue();\n                const currentVal = this._safeExecute(() => getValueEvaluator());\n                if (isCheckbox && Array.isArray(currentVal)) {\n                    const arr = currentVal;\n                    const member = element.hasAttribute('value') ? element.value : checkboxValue;\n                    if (member !== undefined) {\n                        const idx = arr.indexOf(member);\n                        if (element.checked) {\n                            if (idx === -1)\n                                arr.push(member);\n                        }\n                        else if (idx > -1) {\n                            arr.splice(idx, 1);\n                        }\n                    }\n                }\n                else if (isMultiSelect && Array.isArray(currentVal)) {\n                    const arr = currentVal;\n                    arr.splice(0, arr.length);\n                    raw.forEach(v => arr.push(v));\n                }\n                else {\n                    ctx.$value = raw;\n                    this._safeExecute(() => { setValueEvaluator.call(this._createMethodContext(), ctx); });\n                }\n            };\n            const t = element.type;\n            const eventType = (element[STR_TAGNAME] === 'SELECT' || t === 'checkbox' || t === 'radio' || t === 'file') ? 'change' : 'input';\n            this._addEventListenerWithCleanup(element, eventType, updateData);\n            this._addDirective(element, { type: 'model', property });\n        }\n        _bindIfDirective(element, expression) {\n            const self = this;\n            const placeholder = d.createComment('x-if');\n            element.parentNode?.insertBefore(placeholder, element);\n            element.__x_if_anchorParent = placeholder.parentElement || null;\n            const branches = [];\n            const makeActualElement = (el) => {\n                if (el[STR_TAGNAME] === STR_TEMPLATE) {\n                    const wrapper = d.createElement('div');\n                    wrapper.style[STR_DISPLAY] = STR_CONTENTS;\n                    wrapper.appendChild(el.content.cloneNode(true));\n                    return { el: wrapper, isTemplate: true };\n                }\n                return { el: el, isTemplate: false };\n            };\n            const first = makeActualElement(element);\n            const firstEval = self._createElementEvaluator(expression, element);\n            branches.push({ el: first.el, test: firstEval, isTemplate: first.isTemplate });\n            if (!first.isTemplate)\n                first.el.__x_tool_bound = true;\n            const originalNodes = [element];\n            if (FT_IFB) {\n                if (FT_IFB) {\n                    let sib = element.nextElementSibling;\n                    while (sib) {\n                        const isElse = sib.hasAttribute('x-else');\n                        const isElseIf = sib.hasAttribute('x-else-if');\n                        if (!isElse && !isElseIf)\n                            break;\n                        if (sib.hasAttribute('x-else-if')) {\n                            const attr = sib.getAttribute('x-else-if') || '';\n                            const branch = makeActualElement(sib);\n                            const evalFn = self._createElementEvaluator((attr || '').trim(), sib);\n                            branches.push({ el: branch.el, test: evalFn, isTemplate: branch.isTemplate });\n                            if (!branch.isTemplate)\n                                branch.el.__x_tool_bound = true;\n                        }\n                        else {\n                            const branch = makeActualElement(sib);\n                            branches.push({ el: branch.el, test: null, isTemplate: branch.isTemplate });\n                            if (!branch.isTemplate)\n                                branch.el.__x_tool_bound = true;\n                        }\n                        sib.removeAttribute('x-else');\n                        sib.removeAttribute('x-else-if');\n                        originalNodes.push(sib);\n                        sib = sib.nextElementSibling;\n                    }\n                }\n            }\n            let active = -1;\n            for (const orig of originalNodes) {\n                if (orig.parentNode)\n                    orig.parentNode.removeChild(orig);\n            }\n            const mountBranch = (idx) => {\n                if (idx < 0)\n                    return;\n                const b = branches[idx];\n                if (!b.el.__x_tool_bound) {\n                    self._parseDirectives(b.el);\n                    b.el.__x_tool_bound = true;\n                }\n                element.__x_if_current?.parentNode?.removeChild(element.__x_if_current);\n                if (!b.el.parentNode) {\n                    placeholder.parentNode?.insertBefore(b.el, placeholder.nextSibling);\n                }\n                element.__x_if_current = b.el;\n                active = idx;\n            };\n            const unmountBranch = (idx, cb) => {\n                if (idx < 0) {\n                    if (cb)\n                        cb();\n                    return;\n                }\n                const b = branches[idx];\n                if (b.el.parentNode) {\n                    if (b.el.parentNode)\n                        b.el.parentNode.removeChild(b.el);\n                    if (cb)\n                        cb();\n                }\n                else if (cb)\n                    cb();\n                active = -1;\n            };\n            const update = () => {\n                let next = -1;\n                for (let i = 0; i < branches[STR_LENGTH]; i++) {\n                    const b = branches[i];\n                    const pass = b.test ? !!b.test() : true;\n                    if (pass) {\n                        next = i;\n                        break;\n                    }\n                }\n                if (next === active)\n                    return;\n                if (active !== -1) {\n                    unmountBranch(active, () => mountBranch(next));\n                }\n                else {\n                    mountBranch(next);\n                }\n            };\n            const effect = self._createEffect(update);\n            self._addDirective(element, { type: 'if', expression, update: effect });\n        }\n        _bindEventDirective(element, eventName, expression, modifiers) {\n            const self = this;\n            const trimmed = (expression || '').trim();\n            const arrow = self._extractArrowFunction(trimmed);\n            const opts = modifiers ? {\n                once: !!modifiers.once,\n                passive: !!modifiers.passive,\n                capture: !!modifiers.capture,\n            } : undefined;\n            const onlySelf = !!modifiers?.self;\n            const shouldPrevent = !!modifiers?.prevent;\n            const shouldStop = !!modifiers?.stop;\n            const isOutside = !!modifiers?.outside;\n            const deferExec = !!modifiers?.defer;\n            const keyAliasMap = {\n                enter: ['enter'],\n                esc: ['escape', 'esc'],\n                escape: ['escape', 'esc'],\n                space: [' ', 'space', 'spacebar'],\n                tab: ['tab'],\n                backspace: ['backspace'],\n                delete: ['delete', 'del'],\n                del: ['delete', 'del'],\n                arrowup: ['arrowup', 'up'],\n                arrowdown: ['arrowdown', 'down'],\n                arrowleft: ['arrowleft', 'left'],\n                arrowright: ['arrowright', 'right'],\n                home: ['home'],\n                end: ['end'],\n                pageup: ['pageup'],\n                pagedown: ['pagedown']\n            };\n            const comboRequirements = {\n                ctrl: !!modifiers?.ctrl,\n                alt: !!modifiers?.alt,\n                shift: !!modifiers?.shift,\n                meta: !!modifiers?.meta,\n            };\n            const buttonMap = { left: 0, middle: 1, right: 2 };\n            const touchSingle = !!modifiers?.single;\n            const touchMulti = !!modifiers?.multi;\n            const modifierKeys = modifiers ? _Okeys(modifiers) : [];\n            const allowedKeys = [];\n            for (const m of modifierKeys) {\n                const aliases = keyAliasMap[m.toLowerCase()];\n                if (aliases)\n                    allowedKeys.push(...aliases);\n            }\n            const allowedButtons = [];\n            for (const m of modifierKeys) {\n                const btn = buttonMap[m.toLowerCase()];\n                if (btn !== undefined)\n                    allowedButtons.push(btn);\n            }\n            const needKeyCheck = allowedKeys.length > 0 || comboRequirements.ctrl || comboRequirements.alt || comboRequirements.shift || comboRequirements.meta;\n            const needButtonCheck = allowedButtons.length > 0;\n            const needTouchCheck = touchSingle || touchMulti;\n            const passesFilters = (event) => {\n                const path = event.composedPath ? event.composedPath() : null;\n                const tgt = (path && path.length ? path[0] : event.target);\n                if (isOutside) {\n                    if (!tgt)\n                        return false;\n                    if (element instanceof Node && (element === tgt || element.contains(tgt)))\n                        return false;\n                }\n                if (onlySelf && event.target !== element)\n                    return false;\n                if (needTouchCheck) {\n                    if (event instanceof TouchEvent) {\n                        const tCount = event.touches.length;\n                        if (touchSingle && tCount !== 1)\n                            return false;\n                        if (touchMulti && tCount < 2)\n                            return false;\n                    }\n                    else\n                        return false;\n                }\n                if (needButtonCheck) {\n                    if (event instanceof MouseEvent) {\n                        if (!allowedButtons.includes(event.button))\n                            return false;\n                    }\n                    else\n                        return false;\n                }\n                if (needKeyCheck) {\n                    if (!(event instanceof KeyboardEvent))\n                        return false;\n                    const k = (event.key || '').toLowerCase();\n                    if (allowedKeys.length > 0 && !allowedKeys.includes(k))\n                        return false;\n                    if (comboRequirements.ctrl && !event.ctrlKey)\n                        return false;\n                    if (comboRequirements.alt && !event.altKey)\n                        return false;\n                    if (comboRequirements.shift && !event.shiftKey)\n                        return false;\n                    if (comboRequirements.meta && !event.metaKey)\n                        return false;\n                }\n                return true;\n            };\n            const hasExpr = !!trimmed;\n            let runExpr = null;\n            const thisCtx = self._createMethodContext();\n            if (arrow) {\n                const compiledArrow = self._compileArrowForEvent(arrow.paramsList, arrow.body, arrow.isBlock);\n                const mapArgs = arrow.paramsList.length\n                    ? (event) => arrow.paramsList.map((_, idx) => (idx === 0 ? event : idx === 1 ? element : undefined))\n                    : () => [];\n                runExpr = (event) => {\n                    const ctx = self._createContextProxy(event, element);\n                    compiledArrow.call(thisCtx, ctx, ...mapArgs(event));\n                };\n            }\n            else if (hasExpr) {\n                const isStatement = trimmed.includes(';');\n                const executor = self._createEvaluator(trimmed, isStatement);\n                runExpr = (event) => {\n                    const ctx = self._createContextProxy(event, element);\n                    const result = executor.call(thisCtx, ctx);\n                    if (typeof result === 'function')\n                        result.call(thisCtx, event);\n                };\n            }\n            const createEventHandler = (event) => {\n                if (!passesFilters(event))\n                    return;\n                if (shouldPrevent && typeof event.preventDefault === 'function')\n                    event.preventDefault();\n                if (shouldStop && typeof event.stopPropagation === 'function')\n                    event.stopPropagation();\n                if (!runExpr)\n                    return;\n                if (deferExec && typeof quMct === 'function') {\n                    const ev = event;\n                    quMct(() => self._safeExecute(() => runExpr(ev)));\n                    return;\n                }\n                self._safeExecute(() => runExpr(event));\n            };\n            const cfg = this.framework._getConfig();\n            const canDelegate = !!cfg.delegate && EV_DELEGATED.includes(eventName);\n            if (!isOutside && canDelegate) {\n                const remover = this.framework._registerDelegated(element, eventName, { filter: (e) => passesFilters(e), run: (e) => createEventHandler(e), once: !!modifiers?.once, comp: this });\n                this._addCleanupFunction(remover);\n            }\n            else {\n                const target = isOutside ? (element?.ownerDocument || d || document) : element;\n                self._addEventListenerWithCleanup(target, eventName, createEventHandler, opts);\n            }\n        }\n        _createEvaluator(expression, isStatement = false) {\n            const key = `${isStatement ? 's' : 'r'}:${expression}`;\n            let fn = this._expressionCache.get(key);\n            if (!fn) {\n                fn = new Function('ctx', `with(ctx){${isStatement ? expression : `return (${expression})`}}`);\n                this._expressionCache.set(key, fn);\n            }\n            return fn;\n        }\n        _createElementEvaluator(expression, element) {\n            const self = this;\n            const compiled = self._createEvaluator(expression);\n            return () => this._safeExecute(() => compiled.call(self._createMethodContext(), self._createContextProxy(undefined, element)));\n        }\n        _extractArrowFunction(expression) {\n            let m = expression.match(/^\\s*\\(\\s*([^)]*?)\\s*\\)\\s*=>\\s*([\\s\\S]+)$/);\n            if (!m)\n                m = expression.match(/^\\s*([a-zA-Z_$][a-zA-Z0-9_$]*)\\s*=>\\s*([\\s\\S]+)$/);\n            if (!m)\n                return null;\n            const params = (m[1] || '')\n                .split(',')\n                .map(p => p.trim())\n                .filter(Boolean);\n            const body = (m[2] || '').trim();\n            const isBlock = body.startsWith('{') && body.endsWith('}');\n            const finalBody = isBlock ? body.slice(1, -1) : body;\n            return { paramsList: params, body: finalBody, isBlock };\n        }\n        _compileArrowForEvent(params, body, isBlock) {\n            const content = isBlock ? body : 'return ( ' + body + ' );';\n            return new Function('ctx', ...params, 'with(ctx){ ' + content + ' }');\n        }\n        _wrapData(data, parentKey) {\n            if (!(Object.getPrototypeOf(data) === Object.prototype || ARRAY_ISARRAY(data)))\n                return data;\n            const self = this;\n            if (!this._deepReactiveCache)\n                this._deepReactiveCache = new WkMap();\n            if (this._deepReactiveCache.has(data))\n                return this._deepReactiveCache.get(data);\n            const proxy = new Proxy(data, {\n                get: (target, p, receiver) => {\n                    if (ARRAY_ISARRAY(target)) {\n                        if (p === Symbol.iterator) {\n                            self._trackDependency(parentKey);\n                            return Reflect.get(target, p, receiver);\n                        }\n                        if (p === 'length' || (typeof p === 'string' && /^\\d+$/.test(p))) {\n                            self._trackDependency(parentKey);\n                        }\n                    }\n                    else {\n                        self._trackDependency(parentKey);\n                    }\n                    const value = Reflect.get(target, p, receiver);\n                    if (ARRAY_ISARRAY(target) && typeof value === 'function' && ['push', 'pop', 'shift', 'unshift', 'splice', 'reverse', 'copyWithin', 'fill'].includes(p)) {\n                        return function (...args) {\n                            if (self._isInComputedEvaluation) {\n                                const name = String(p);\n                                throw new Error(`[x-tool] Mutation via '${String(parentKey)}.${name}()' is not allowed during computed evaluation.`);\n                            }\n                            if (self._isFrozen) {\n                                const name = String(p);\n                                throw new Error(`[x-tool] Mutation via '${String(parentKey)}.${name}()' is not allowed while component is frozen.`);\n                            }\n                            const arr = target;\n                            const beforeLen = arr.length;\n                            const beforeFirst = arr[0];\n                            const beforeLast = arr[beforeLen - 1];\n                            const result = value.apply(target, args);\n                            if (!self._isSealed && (arr.length !== beforeLen || arr[0] !== beforeFirst || arr[arr.length - 1] !== beforeLast)) {\n                                self._onDataChange(parentKey);\n                            }\n                            return result;\n                        };\n                    }\n                    const type = typeof value;\n                    if (value && type === 'object') {\n                        return self._wrapData(value, parentKey);\n                    }\n                    return value;\n                },\n                ownKeys: (target) => { return Reflect.ownKeys(target); },\n                has: (target, key) => { return Reflect.has(target, key); },\n                set: (target, p, value) => {\n                    if (self._isDestroyed)\n                        return true;\n                    if (self._isInComputedEvaluation) {\n                        const key = String(parentKey) + (typeof p === 'symbol' ? '' : '.' + String(p));\n                        throw new Error(`[x-tool] Mutation of '${key}' is not allowed during computed evaluation.`);\n                    }\n                    if (self._isFrozen) {\n                        const key = String(parentKey) + (typeof p === 'symbol' ? '' : '.' + String(p));\n                        throw new Error(`[x-tool] Mutation of '${key}' is not allowed while component is frozen.`);\n                    }\n                    if (typeof p === 'symbol')\n                        return true;\n                    const had = Reflect.has(target, p);\n                    const oldValue = had ? Reflect.get(target, p) : undefined;\n                    if (value && typeof value === 'object') {\n                        value = self._wrapData(value, typeof p === 'symbol' ? parentKey : (String(parentKey) + '.' + String(p)));\n                    }\n                    if (!had) {\n                        try {\n                            Reflect.defineProperty(target, p, {\n                                configurable: true,\n                                enumerable: true,\n                                writable: true,\n                                value\n                            });\n                        }\n                        catch {\n                            Reflect.set(target, p, value);\n                        }\n                        self._onDataChange(parentKey);\n                        return true;\n                    }\n                    if (oldValue === value)\n                        return true;\n                    Reflect.set(target, p, value);\n                    if (!self._isSealed)\n                        self._onDataChange(parentKey);\n                    return true;\n                },\n                deleteProperty: (target, p) => {\n                    if (self._isInComputedEvaluation) {\n                        const key = String(parentKey) + (typeof p === 'symbol' ? '' : '.' + String(p));\n                        throw new Error(`[x-tool] Deletion of '${key}' is not allowed during computed evaluation.`);\n                    }\n                    if (self._isFrozen) {\n                        const key = String(parentKey) + (typeof p === 'symbol' ? '' : '.' + String(p));\n                        throw new Error(`[x-tool] Deletion of '${key}' is not allowed while component is frozen.`);\n                    }\n                    const ok = Reflect.deleteProperty(target, p);\n                    if (ok && !self._isSealed)\n                        self._onDataChange(parentKey);\n                    return ok;\n                }\n            });\n            this._deepReactiveCache.set(data, proxy);\n            return proxy;\n        }\n        _createReactiveData(data) {\n            const self = this;\n            return new Proxy(data, {\n                get: (target, property, receiver) => {\n                    const value = Reflect.get(target, property, receiver);\n                    if (property === Symbol.iterator)\n                        return value;\n                    if (typeof property !== 'symbol') {\n                        self._trackDependency(property);\n                    }\n                    if (value && typeof value === 'object') {\n                        return self._wrapData(value, property);\n                    }\n                    return value;\n                },\n                ownKeys: (target) => Reflect.ownKeys(target),\n                has: (target, key) => Reflect.has(target, key),\n                set: (target, property, value, receiver) => {\n                    if (self._isDestroyed)\n                        return true;\n                    if (self._isFrozen)\n                        return true;\n                    if (self._isInComputedEvaluation) {\n                        throw new Error(`[x-tool] Mutation of '${String(property)}' is not allowed during computed evaluation.`);\n                    }\n                    if (property === Symbol.iterator && ARRAY_ISARRAY(target))\n                        return value;\n                    const oldValue = Reflect.get(target, property);\n                    const had = Reflect.has(target, property);\n                    if (!had) {\n                        try {\n                            Reflect.defineProperty(target, property, {\n                                configurable: true,\n                                enumerable: true,\n                                writable: true,\n                                value\n                            });\n                        }\n                        catch {\n                            Reflect.set(target, property, value, receiver);\n                        }\n                    }\n                    else {\n                        Reflect.set(target, property, value, receiver);\n                    }\n                    if (!this._isSealed)\n                        this._onDataChange(property);\n                    if (this._propUpdateActive && property !== '$props') {\n                        const pc = target.$props;\n                        if (pc)\n                            pc[property] = value;\n                        const eff = this._propEffects[property];\n                        if (eff && !this._runningPropEffect && !this._isSealed) {\n                            this._runningPropEffect = true;\n                            this._safeExecute(() => eff.call(this._createMethodContext(), value, oldValue));\n                            this._runningPropEffect = false;\n                        }\n                    }\n                    return true;\n                }\n            });\n        }\n        _createMethodContext(_includeComputed = true) {\n            const specials = {\n                '$log': (..._args) => { },\n                '$destroy': () => this.destroy(),\n                '$forceUpdate': () => this._scheduleRender(),\n                '$addCleanupFunction': (fn) => this._addCleanupFunction(fn),\n                '$nextTick': (cb) => {\n                    if (cb) {\n                        this._nextTickQueue.push(cb);\n                        if (!this._renderScheduled)\n                            quMct(() => {\n                                if (!this._renderScheduled && this._nextTickQueue.length) {\n                                    const q = this._nextTickQueue.splice(0, this._nextTickQueue.length);\n                                    for (const fn of q) {\n                                        this._safeExecute(() => fn());\n                                    }\n                                }\n                            });\n                        return;\n                    }\n                    return new Promise(resolve => {\n                        this._nextTickQueue.push(() => resolve());\n                        if (!this._renderScheduled)\n                            quMct(() => {\n                                if (!this._renderScheduled && this._nextTickQueue.length) {\n                                    const q = this._nextTickQueue.splice(0, this._nextTickQueue.length);\n                                    for (const fn of q) {\n                                        this._safeExecute(() => fn());\n                                    }\n                                }\n                            });\n                    });\n                },\n                '$el': this._element,\n                '$id': this._id,\n                '$isMounted': this._isMounted,\n                '$isDestroyed': this._isDestroyed,\n                '$isSealed': this._isSealed,\n                '$isFrozen': this._isFrozen,\n                '$parent': this._parent,\n                '$children': this._children,\n                '$seal': (on = true) => { this._setSealed(!!on); },\n                '$mutate': (fn) => {\n                    const prevMethod = this._isInMethodExecution;\n                    if (this._isInComputedEvaluation) {\n                        throw new Error('[x-tool] $mutate cannot be used inside computed evaluation; computed getters must be pure.');\n                    }\n                    this._isInMethodExecution = false;\n                    try {\n                        return typeof fn === 'function' ? fn() : undefined;\n                    }\n                    finally {\n                        this._isInMethodExecution = prevMethod;\n                        this._scheduleRender();\n                    }\n                }\n            };\n            let data = this._data;\n            if (this._isInComputedEvaluation) {\n                data = (this._rawData);\n            }\n            return new Proxy(data, {\n                get: (target, propStr) => {\n                    if (propStr in target) {\n                        this._trackDependency(propStr);\n                        const v = target[propStr];\n                        return v;\n                    }\n                    if (FT_C && (propStr in this._computed)) {\n                        return this._getComputedValue(propStr);\n                    }\n                    if (propStr in specials)\n                        return specials[propStr];\n                    return this._methods[propStr];\n                },\n                set: (_target, propStr, value) => {\n                    if (this._isInComputedEvaluation) {\n                        throw new Error(`[x-tool] Mutation of '${String(propStr)}' is not allowed during computed evaluation.`);\n                    }\n                    if (this._isFrozen) {\n                        throw new Error(`[x-tool] Mutation of '${String(propStr)}' is not allowed while component is frozen.`);\n                    }\n                    this._data[propStr] = value;\n                    return true;\n                }\n            });\n        }\n        _createContextProxy(event, targetElement) {\n            const component = this;\n            const mergedScope = targetElement ? this._collectLoopScope(targetElement) : null;\n            const scopeKeys = mergedScope ? new Set(_Okeys(mergedScope)) : new Set();\n            const gWindow = (typeof window !== 'undefined' ? window : undefined);\n            const gDocument = (typeof document !== 'undefined' ? document : undefined);\n            const cfg = this.framework._getConfig();\n            const sandbox = !!cfg.sandboxExpressions;\n            const allow = new Set((cfg.allowGlobals || []).map(s => String(s)));\n            const _lastListenerByTarget = new WkMap();\n            const wrapTarget = (t) => {\n                if (!t)\n                    return t;\n                const hasAdd = typeof t.addEventListener === 'function';\n                if (!hasAdd)\n                    return t;\n                const handlerMap = new WkMap();\n                const makeKey = (event, options) => {\n                    try {\n                        return event + '|' + (options === undefined ? '' : (typeof options === 'object' ? JSON.stringify(options) : String(options)));\n                    }\n                    catch {\n                        return event + '|';\n                    }\n                };\n                return new Proxy(t, {\n                    get(target, prop, _receiver) {\n                        if (prop === 'addEventListener') {\n                            return function (event, handler, options) {\n                                if (component._isSealed || component._isFrozen)\n                                    return;\n                                const inv = component._currentInvoker || '__anonymous__';\n                                const eKey = makeKey(event, options);\n                                let invMap = _lastListenerByTarget.get(target);\n                                if (!invMap) {\n                                    invMap = new Map();\n                                    _lastListenerByTarget.set(target, invMap);\n                                }\n                                let evMap = invMap.get(inv);\n                                if (!evMap) {\n                                    evMap = new Map();\n                                    invMap.set(inv, evMap);\n                                }\n                                const prev = evMap.get(eKey);\n                                if (prev) {\n                                    try {\n                                        target.removeEventListener(event, prev.handler, prev.options);\n                                    }\n                                    catch { }\n                                    try {\n                                        prev.remover && prev.remover();\n                                    }\n                                    catch { }\n                                    evMap.delete(eKey);\n                                }\n                                target.addEventListener(event, handler, options);\n                                const remover = component._addCleanupFunction(() => {\n                                    try {\n                                        target.removeEventListener(event, handler, options);\n                                    }\n                                    catch { }\n                                });\n                                if (remover)\n                                    component._userResourceCleanups.add(remover);\n                                try {\n                                    if (typeof handler === 'function' && remover) {\n                                        let m = handlerMap.get(handler);\n                                        if (!m) {\n                                            m = new Map();\n                                            handlerMap.set(handler, m);\n                                        }\n                                        m.set(eKey, remover);\n                                    }\n                                }\n                                catch { }\n                                evMap.set(eKey, { handler, options, remover });\n                            };\n                        }\n                        if (prop === 'removeEventListener') {\n                            return function (event, handler, options) {\n                                try {\n                                    target.removeEventListener(event, handler, options);\n                                }\n                                catch { }\n                                const key = makeKey(event, options);\n                                try {\n                                    if (typeof handler === 'function') {\n                                        const m = handlerMap.get(handler);\n                                        if (m) {\n                                            const rem = m.get(key);\n                                            if (rem) {\n                                                try {\n                                                    rem();\n                                                }\n                                                catch { }\n                                                ;\n                                                m.delete(key);\n                                            }\n                                            if (m.size === 0)\n                                                handlerMap.delete(handler);\n                                        }\n                                    }\n                                }\n                                catch { }\n                                const invMap = _lastListenerByTarget.get(target);\n                                if (invMap) {\n                                    for (const [invKey, evMap] of invMap) {\n                                        const rec = evMap.get(key);\n                                        if (rec && rec.handler === handler) {\n                                            try {\n                                                rec.remover && rec.remover();\n                                            }\n                                            catch { }\n                                            evMap.delete(key);\n                                            if (evMap.size === 0)\n                                                invMap.delete(invKey);\n                                            break;\n                                        }\n                                    }\n                                }\n                            };\n                        }\n                        if (prop === 'querySelector') {\n                            return function (sel) { const res = target.querySelector(sel); return wrapTarget(res); };\n                        }\n                        if (prop === 'querySelectorAll') {\n                            return function (sel) { const list = target.querySelectorAll(sel); return Array.from(list).map(wrapTarget); };\n                        }\n                        if (prop === 'getElementById') {\n                            return function (id) { const res = target.getElementById(id); return wrapTarget(res); };\n                        }\n                        if (prop === 'document') {\n                            const doc = target.document;\n                            return wrapTarget(doc) || doc;\n                        }\n                        if (prop === 'body' && target === gDocument) {\n                            const b = target.body;\n                            return wrapTarget(b) || b;\n                        }\n                        if (prop === 'defaultView' && target === gDocument) {\n                            const w = target.defaultView;\n                            return wrapTarget(w) || w;\n                        }\n                        const val = target[prop];\n                        if (typeof val === 'function') {\n                            try {\n                                return val.bind(target);\n                            }\n                            catch { }\n                        }\n                        return val;\n                    }\n                });\n            };\n            const _timeoutRemovers = new Map();\n            const _intervalRemovers = new Map();\n            const _rafRemovers = new Map();\n            const ctxSetTimeout = (fn, ms, ...args) => {\n                if (component._isSealed || component._isFrozen)\n                    return undefined;\n                const key = component._currentInvoker || '__anonymous__';\n                const prev = component._lastTimeoutByInvoker.get(key);\n                if (prev) {\n                    try {\n                        gWindow?.clearTimeout?.(prev.id);\n                    }\n                    catch { }\n                    ;\n                    try {\n                        prev.remover && prev.remover();\n                    }\n                    catch { }\n                }\n                const id = gWindow?.setTimeout?.(fn, ms, ...args);\n                if (id != null) {\n                    const remover = component._addCleanupFunction(() => { try {\n                        gWindow?.clearTimeout?.(id);\n                    }\n                    catch { } });\n                    if (remover)\n                        component._userResourceCleanups.add(remover);\n                    _timeoutRemovers.set(id, remover);\n                    component._lastTimeoutByInvoker.set(key, { id, remover });\n                }\n                return id;\n            };\n            const ctxSetInterval = (fn, ms, ...args) => {\n                if (component._isSealed || component._isFrozen)\n                    return undefined;\n                const key = component._currentInvoker || '__anonymous__';\n                const prev = component._lastIntervalByInvoker.get(key);\n                if (prev) {\n                    try {\n                        gWindow?.clearInterval?.(prev.id);\n                    }\n                    catch { }\n                    ;\n                    try {\n                        prev.remover && prev.remover();\n                    }\n                    catch { }\n                }\n                const id = gWindow?.setInterval?.(fn, ms, ...args);\n                if (id != null) {\n                    const remover = component._addCleanupFunction(() => { try {\n                        gWindow?.clearInterval?.(id);\n                    }\n                    catch { } });\n                    if (remover)\n                        component._userResourceCleanups.add(remover);\n                    _intervalRemovers.set(id, remover);\n                    component._lastIntervalByInvoker.set(key, { id, remover });\n                }\n                return id;\n            };\n            const ctxRequestAnimationFrame = (cb) => {\n                if (component._isSealed || component._isFrozen)\n                    return undefined;\n                const key = component._currentInvoker || '__anonymous__';\n                const prev = component._lastRafByInvoker.get(key);\n                if (prev) {\n                    try {\n                        gWindow?.cancelAnimationFrame?.(prev.id);\n                    }\n                    catch { }\n                    ;\n                    try {\n                        prev.remover && prev.remover();\n                    }\n                    catch { }\n                }\n                const id = gWindow?.requestAnimationFrame?.(cb);\n                if (id != null) {\n                    const remover = component._addCleanupFunction(() => { try {\n                        gWindow?.cancelAnimationFrame?.(id);\n                    }\n                    catch { } });\n                    if (remover)\n                        component._userResourceCleanups.add(remover);\n                    _rafRemovers.set(id, remover);\n                    component._lastRafByInvoker.set(key, { id, remover });\n                }\n                return id;\n            };\n            const wrapObserverCtor = (Orig, kind) => {\n                if (!Orig)\n                    return undefined;\n                const Wrapped = function (...args) {\n                    if (component._isSealed || component._isFrozen)\n                        return { observe() { }, disconnect() { }, unobserve() { } };\n                    const inst = new Orig(...args);\n                    const key = component._currentInvoker || '__anonymous__';\n                    let store = kind === 'mutation' ? component._lastObserverByInvoker.mutation : kind === 'resize' ? component._lastObserverByInvoker.resize : component._lastObserverByInvoker.intersection;\n                    const prev = store.get(key);\n                    if (prev) {\n                        try {\n                            prev.inst.disconnect();\n                        }\n                        catch { }\n                        ;\n                        try {\n                            prev.remover && prev.remover();\n                        }\n                        catch { }\n                    }\n                    const remover = component._addCleanupFunction(() => { try {\n                        inst.disconnect();\n                    }\n                    catch { } });\n                    if (remover)\n                        component._userResourceCleanups.add(remover);\n                    store.set(key, { inst, remover });\n                    return inst;\n                };\n                Wrapped.prototype = Orig.prototype;\n                return Wrapped;\n            };\n            const specials = {\n                '$target': targetElement || null,\n                '$event': event || null,\n                ...(sandbox && !allow.has('setTimeout') ? {} : { 'setTimeout': ctxSetTimeout }),\n                ...(sandbox && !allow.has('clearTimeout') ? {} : { 'clearTimeout': (id) => { try {\n                        gWindow?.clearTimeout?.(id);\n                    }\n                    catch { }\n                    finally {\n                        try {\n                            const r = _timeoutRemovers.get(id);\n                            if (r) {\n                                r();\n                                _timeoutRemovers.delete(id);\n                            }\n                        }\n                        catch { }\n                    } } }),\n                ...(sandbox && !allow.has('setInterval') ? {} : { 'setInterval': ctxSetInterval }),\n                ...(sandbox && !allow.has('clearInterval') ? {} : { 'clearInterval': (id) => { try {\n                        gWindow?.clearInterval?.(id);\n                    }\n                    catch { }\n                    finally {\n                        try {\n                            const r = _intervalRemovers.get(id);\n                            if (r) {\n                                r();\n                                _intervalRemovers.delete(id);\n                            }\n                        }\n                        catch { }\n                    } } }),\n                ...(sandbox && !allow.has('requestAnimationFrame') ? {} : { 'requestAnimationFrame': ctxRequestAnimationFrame }),\n                ...(sandbox && !allow.has('cancelAnimationFrame') ? {} : { 'cancelAnimationFrame': (id) => { try {\n                        gWindow?.cancelAnimationFrame?.(id);\n                    }\n                    catch { }\n                    finally {\n                        try {\n                            const r = _rafRemovers.get(id);\n                            if (r) {\n                                r();\n                                _rafRemovers.delete(id);\n                            }\n                        }\n                        catch { }\n                    } } }),\n                ...(sandbox && !allow.has('MutationObserver') ? {} : { 'MutationObserver': wrapObserverCtor(gWindow?.MutationObserver, 'mutation') }),\n                ...(sandbox && !allow.has('ResizeObserver') ? {} : { 'ResizeObserver': wrapObserverCtor(gWindow?.ResizeObserver, 'resize') }),\n                ...(sandbox && !allow.has('IntersectionObserver') ? {} : { 'IntersectionObserver': wrapObserverCtor(gWindow?.IntersectionObserver, 'intersection') }),\n                ...(sandbox && !allow.has('window') ? {} : { 'window': wrapTarget(gWindow) }),\n                ...(sandbox && !allow.has('document') ? {} : { 'document': wrapTarget(gDocument) })\n            };\n            return new Proxy({}, {\n                get: (_t, propStr) => {\n                    if (mergedScope && propStr in mergedScope)\n                        return mergedScope[propStr];\n                    if (propStr in component._data)\n                        return component._data[propStr];\n                    if (propStr in component._computed)\n                        return component._getComputedValue(propStr);\n                    if (propStr in component._methods)\n                        return component._methods[propStr];\n                    if (propStr in specials)\n                        return specials[propStr];\n                    return undefined;\n                },\n                set: (_t, propStr, value) => {\n                    if (mergedScope && scopeKeys.has(propStr)) {\n                        mergedScope[propStr] = value;\n                    }\n                    else {\n                        component._data[propStr] = value;\n                    }\n                    return true;\n                },\n                has: (_t, propStr) => !!(mergedScope && propStr in mergedScope) ||\n                    propStr in component._data ||\n                    propStr in component._computed ||\n                    propStr in component._methods ||\n                    propStr in specials\n            });\n        }\n        _bindCustomDirective(element, _name, expression, directive, modifiers) {\n            const self = this;\n            const evaluator = self._createElementEvaluator(expression, element);\n            const directiveInfo = { type: 'custom', expression, customDirective: directive };\n            if (directive.bind) {\n                self._safeExecute(() => directive.bind(element, evaluator(), expression, self, modifiers, evaluator));\n            }\n            const update = () => {\n                if (directive.update)\n                    self._safeExecute(() => directive.update(element, evaluator(), expression, self, modifiers, evaluator));\n            };\n            const effect = self._createEffect(update);\n            directiveInfo.update = effect;\n            self._addDirective(element, directiveInfo);\n        }\n        _bindAttributeDirective(element, attributeName, expression) {\n            const self = this;\n            const evaluator = self._createElementEvaluator(expression, element);\n            if (attributeName === 'class') {\n                const el = element;\n                if (!self._initialClassSets.get(el)) {\n                    const baseSet = new Set();\n                    const oc = el.className || '';\n                    if (oc)\n                        for (const cls of oc.split(/\\s+/)) {\n                            if (cls)\n                                baseSet.add(cls);\n                        }\n                    self._initialClassSets.set(el, baseSet);\n                }\n            }\n            const elAny = element;\n            let propName = null;\n            if (attributeName in elAny)\n                propName = attributeName;\n            else {\n                const camel = attributeName.replace(/-([a-z])/g, (_, c) => c.toUpperCase());\n                if (camel in elAny)\n                    propName = camel;\n                else if (attributeName.toLowerCase() === 'readonly' && 'readOnly' in elAny)\n                    propName = 'readOnly';\n            }\n            const isBooleanProp = !!(propName && typeof elAny[propName] === 'boolean');\n            const hasNonFunctionProp = !!(propName && (propName in elAny) && typeof elAny[propName] !== 'function');\n            const isKnownBooleanAttr = !!ReactiveComponent._BA[attributeName.toLowerCase()];\n            const update = () => {\n                const value = evaluator();\n                if (attributeName === 'class') {\n                    const el = element;\n                    const base = self._initialClassSets.get(el);\n                    if (typeof value === 'string') {\n                        el.className = base && base.size ? [...base].join(' ') + (value ? ' ' + value : '') : value || '';\n                    }\n                    else if (ARRAY_ISARRAY(value)) {\n                        if (base && base.size)\n                            el.className = [...base, ...value.filter(Boolean)].join(' ');\n                        else\n                            el.className = value.filter(Boolean).join(' ');\n                    }\n                    else if (value && typeof value === 'object') {\n                        if (base && base.size)\n                            el.className = [...base].join(' ');\n                        for (const raw in value) {\n                            const on = !!value[raw];\n                            if (!raw)\n                                continue;\n                            const tokens = raw.split(/\\s+/);\n                            for (let i = 0; i < tokens.length; i++) {\n                                const tk = tokens[i];\n                                if (!tk)\n                                    continue;\n                                el.classList.toggle(tk, on);\n                            }\n                        }\n                    }\n                    else if (value == null && base && base.size) {\n                        el.className = [...base].join(' ');\n                    }\n                    else if (value == null) {\n                        el.removeAttribute('class');\n                    }\n                    return;\n                }\n                if (attributeName === STR_STYLE) {\n                    const el = element;\n                    if (typeof value === 'string') {\n                        el.style.cssText = value;\n                        return;\n                    }\n                    if (value && typeof value === 'object') {\n                        Object.assign(el.style, value);\n                        return;\n                    }\n                    if (value == null)\n                        el.removeAttribute('style');\n                    return;\n                }\n                if ((isBooleanProp && propName) || isKnownBooleanAttr) {\n                    const boolVal = !!value;\n                    if (propName && isBooleanProp)\n                        elAny[propName] = boolVal;\n                    if (boolVal)\n                        element.setAttribute(attributeName, '');\n                    else\n                        element.removeAttribute(attributeName);\n                    return;\n                }\n                let normalized = null;\n                if (value && typeof value === 'object') {\n                    const parts = [];\n                    for (const k in value) {\n                        if (value[k])\n                            parts.push(k);\n                    }\n                    normalized = parts.length ? parts.join(' ') : null;\n                }\n                else if (value !== null && value !== undefined) {\n                    normalized = String(value);\n                }\n                if (hasNonFunctionProp && propName) {\n                    if (normalized !== null) {\n                        try {\n                            elAny[propName] = normalized;\n                        }\n                        catch (e) {\n                            try {\n                                element.setAttribute(attributeName, normalized);\n                            }\n                            catch { }\n                        }\n                    }\n                    else {\n                        element.removeAttribute(attributeName);\n                    }\n                    return;\n                }\n                if (normalized !== null) {\n                    const cur = element.getAttribute(attributeName);\n                    if (cur !== normalized)\n                        element.setAttribute(attributeName, normalized);\n                }\n                else {\n                    if (element.hasAttribute(attributeName))\n                        element.removeAttribute(attributeName);\n                }\n            };\n            const effect = self._createEffect(update);\n            self._addDirective(element, { type: 'bind', expression, update: effect });\n        }\n        _collectLoopScope(el) {\n            if (!el)\n                return null;\n            if (!el.parentElement) {\n                const cur = el.__x_if_current;\n                if (cur && cur.parentElement) {\n                    el = cur;\n                }\n                else {\n                    const anchorParent = el.__x_if_anchorParent;\n                    if (anchorParent)\n                        el = anchorParent;\n                }\n            }\n            const merged = {};\n            let node = el;\n            while (node) {\n                const scope = this._loopScopes.get(node);\n                if (scope)\n                    Object.assign(merged, scope);\n                if (node === this.element)\n                    break;\n                node = node.parentElement;\n            }\n            return _Okeys(merged).length ? merged : null;\n        }\n        _updateElementDirectives(root) {\n            for (const [element, directives] of this._directives) {\n                for (const directive of directives) {\n                    if ((root === element || (element instanceof Element && root.contains(element))) && directive.update) {\n                        directive.update();\n                    }\n                }\n            }\n        }\n        _bindForDirective(element, expression) {\n            const self = this;\n            const match = expression.trim().match(/^(?:\\(\\s*([^,\\s]+)\\s*(?:,\\s*([^\\)]+))?\\s*\\)|([^,\\s]+))\\s+(in|of)\\s+(.+)$/);\n            if (!match) {\n                return;\n            }\n            const itemVar = match[1] || match[3];\n            const indexVar = match[2];\n            const listCode = match[5];\n            const placeholder = d.createComment('x-for');\n            element.parentNode?.insertBefore(placeholder, element);\n            let templateToClone;\n            if (element[STR_TAGNAME] === STR_TEMPLATE) {\n                templateToClone = d.createElement('div');\n                templateToClone.style[STR_DISPLAY] = STR_CONTENTS;\n                templateToClone.appendChild(element.content.cloneNode(true));\n                element.parentNode?.removeChild(element);\n            }\n            else {\n                templateToClone = element;\n                element.parentNode?.removeChild(element);\n            }\n            const contextAnchor = placeholder.parentElement || self.element;\n            const listEval = self._createElementEvaluator(listCode.trim(), contextAnchor);\n            const instances = [];\n            const createScope = (item, idxOrKey) => {\n                const scope = { [itemVar]: item };\n                if (indexVar)\n                    scope[indexVar] = idxOrKey;\n                return scope;\n            };\n            const update = () => {\n                const norm = self._safeExecute(() => {\n                    const result = listEval();\n                    if (_AisArr(result))\n                        return { list: result, keys: null };\n                    if (typeof Map !== 'undefined' && result instanceof Map) {\n                        return { list: _Afrom(result.values()), keys: _Afrom(result.keys()) };\n                    }\n                    if (typeof Set !== 'undefined' && result instanceof Set) {\n                        return { list: _Afrom(result.values()), keys: null };\n                    }\n                    if (result && typeof result[Symbol.iterator] === 'function') {\n                        return { list: _Afrom(result), keys: null };\n                    }\n                    if (result && typeof result === 'object') {\n                        const keys = Object.keys(result);\n                        const list = keys.map(k => result[k]);\n                        return { list, keys };\n                    }\n                    return { list: [], keys: null };\n                }, { list: [], keys: null });\n                const list = norm.list;\n                const keysArr = norm.keys;\n                if (instances.length > list.length) {\n                    while (instances.length > list.length) {\n                        const inst = instances.pop();\n                        if (inst.parentNode)\n                            inst.parentNode.removeChild(inst);\n                    }\n                }\n                const minLen = Math.min(instances.length, list.length);\n                for (let i = 0; i < minLen; i++) {\n                    const inst = instances[i];\n                    const keyVal = keysArr ? keysArr[i] : i;\n                    self._loopScopes.set(inst, createScope(list[i], keyVal));\n                    self._updateElementDirectives(inst);\n                }\n                if (list.length > instances.length) {\n                    const frag = d.createDocumentFragment();\n                    const start = instances.length;\n                    for (let i = start; i < list.length; i++) {\n                        const clone = templateToClone.cloneNode(true);\n                        clone.removeAttribute('x-for');\n                        const keyVal = keysArr ? keysArr[i] : i;\n                        self._loopScopes.set(clone, createScope(list[i], keyVal));\n                        try {\n                            self._parseDirectives(clone);\n                        }\n                        catch { }\n                        frag.appendChild(clone);\n                        instances.push(clone);\n                    }\n                    const ref = instances[start - 1] || placeholder;\n                    if (ref.parentNode)\n                        ref.parentNode.insertBefore(frag, ref.nextSibling);\n                }\n            };\n            const dir = { type: 'for', expression };\n            const effect = self._createEffect(update, dir);\n            dir.update = effect;\n            self._addDirective(placeholder, dir);\n        }\n        _render() {\n            const self = this;\n            for (const directives of self._directives.values()) {\n                for (const dr of directives) {\n                    if (XTOOL_ENABLE_STATIC_DIRECTIVES && dr._static)\n                        continue;\n                    if (dr.update) {\n                        try {\n                            dr.update();\n                        }\n                        catch (error) {\n                            if (!(error instanceof ReferenceError)) { }\n                        }\n                    }\n                }\n            }\n        }\n    }\n    ReactiveComponent._BA = {\n        itemscope: 1, formnovalidate: 1, novalidate: 1, default: 1\n    };\n    const xTool = new XToolFramework();\n    return xTool;\n}();\nif (typeof window !== 'undefined') {\n    const w = window;\n    w.XTool = XToolFramework;\n    w.FyneJS = XToolFramework;\n}\n//# sourceMappingURL=x-tool.js.map"],"mappings":"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","ignoreList":[]}
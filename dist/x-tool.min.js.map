{"version":3,"names":["stripTypes","caseKebabToCamel","ARRAY_ISARRAY","Array","isArray","WkMap","WeakMap","quMct","queueMicrotask","FT_EXT_DIRS","__FEAT_EXT_DIRECTIVES__","XToolFramework","_se","fn","_tr","s","trim","_Afrom","from","_AisArr","_Okeys","Object","keys","STR_STYLE","STR_DISPLAY","STR_NONE","STR_TAGNAME","STR_TEMPLATE","STR_LENGTH","STR_SOURCE","STR_READONLY","XTOOL_ENABLE_STATIC_DIRECTIVES","d","document","STR_CONTENTS","EV_DELEGATED","head","getElementById","style","createElement","id","textContent","appendChild","PFX","attrCache","Map","attrName","name","cached","get","value","set","ReactiveComponent","attachToParent","parent","this","_parent","_addChild","_id","framework","_framework","element","_element","el","isBound","_isBound","v","isMounted","_isMounted","isDestroyed","_isDestroyed","_abortInvokerResources","byKind","_invokerResources","values","cleanup","clear","_cancelUserResources","_resolveBindingMeta","attributeName","elAny","propName","camel","replace","_","c","toUpperCase","toLowerCase","isBooleanProp","hasNonFunctionProp","isKnownBooleanAttr","_BA","_applyGenericBinding","meta","boolVal","setAttribute","removeAttribute","normalized","parts","k","push","length","join","String","getAttribute","_scanDirectiveAttrs","opts","prefixDash","prefixColon","namesOut","hasTextOrHtml","forName","names","getAttributeNames","i","startsWith","skipRootFor","setFrozen","on","_isFrozen","_sealedBeforeFreeze","_isSealed","_scheduleRender","_setSealed","_addDirective","directive","existing","_directives","constructor","def","_propUpdateActive","_runningPropEffect","_beforeMountCalled","_children","_computed","_propEffects","_computedCache","_computedDeps","_computedKeyStack","_isInComputedEvaluation","_isInMethodExecution","_allEffects","Set","_hasComputed","_cleanupFunctions","_directiveAbort","AbortController","_targetIds","_targetSeq","_isMutationEnabled","_effectsToRun","_currentInvoker","_loopScopes","_expressionCache","_propertyDependencies","_activeEffect","_renderScheduled","_nextTickQueue","_changeFrameId","_renderFrameId","_initialClassSets","_rawData","_propParent","_callLifecycleHook","hookName","hook","_lifecycle","_safeExecute","_runWithGlobalInterception","_xInitExpr","expr","isConnected","runner","trimmed","arrow","_extractArrowFunction","ctx","_createMethodContext","_compileArrowForEvent","paramsList","body","isBlock","args","out","call","_createContextProxy","undefined","slice","_addCleanupFunction","result","_createEvaluator","indexOf","wrapped","delete","add","_originalMethods","methods","_bindComputed","computed","propEffects","_bindPropEffects","mounted","unmounted","destroyed","updated","beforeMount","beforeUnmount","beforeDestroy","_cloneData","data","_data","_createReactiveData","_methods","_bindMethods","seen","has","arr","Date","getTime","RegExp","source","flags","m","forEach","st","proto","getPrototypeOf","prototype","create","key","callBeforeMount","_onDataChange","_property","self","cancelAnimationFrame","effectsToRun","directDeps","size","queue","visited","affectedComputed","queueIdx","base","compKey","baseDeps","entries","compEffects","requestAnimationFrame","effect","_bindFunctionMap","src","kind","makeNoArgCtxRunner","test","isNative","compiled","Function","original","prev","prevInv","newValue","oldValue","prevFlag","_getComputedValue","_trackDependency","getter","pop","e","propKey","activeEff","deps","includes","stackLen","current","_render","q","splice","fallback","error","bindToElement","completeBinding","getContext","includeComputed","_applyAsyncTemplateResolved","_parseDirectives","_getComponentByElement","_registerElement","child","_removeChild","index","_setXInitExpr","wrapper","thisArg","apply","destroy","directives","type","customDirective","unbind","abort","_runCleanupCallbacks","_propEffect","idx","_unregisterElement","_clearComponentRefs","_deepReactiveCache","_unregisterComponent","_initReactiveProps","evalFn","update","obj","$props","_listen","event","handler","options","signal","addEventListener","capture","merged","_targetKey","target","toString","processElement","isRoot","hasAttribute","isComponentTag","directiveNames","_bindDirective","attr","_bindTextInterpolationsIn","_walkElements","nodes","childNodes","node","nodeType","Node","TEXT_NODE","textNode","raw","nodeValue","__x_ti_bound","segs","charCodeAt","run","start","close","text","repeat","code","nextEsc","nextOpen","end","some","literalOut","map","evaluators","_createElementEvaluator","ei","dirInfo","expression","_createEffect","processor","firstElementChild","next","nextElementSibling","directiveName","isAtEvent","isShortBind","_bindAttributeDirective","modifiers","split","filter","Boolean","reduce","acc","_bindTransitionDirective","_bindSimpleDirective","_bindRefDirective","_bindIfDirective","_bindForDirective","_bindModelDirective","prefix","rest","suffix","mods","_getCustomDirective","_bindCustomDirective","_bindEventDirective","part","enter","leave","_bindIntersectDirective","refName","_registerComponentRef","dir","_getSharedRef","ref","_getComponentRefs","phase","runExpr","_compileHandler","payload","once","rootMargin","onEnter","cb","entry","info","onLeave","unobserve","_ioObserve","updateFn","directiveRef","_static","found","config","__x_transition","val","toggle","after","exprStr","afterEnterRunner","afterLeaveRunner","afterRunner","_applyShowWithTransition","show","originalDisplay","onDone","setProperty","removeProperty","cfg","imp","__x_t","cancel","duration","easing","cls","classList","rm","remove","effectiveMs","fallbackMs","cs","window","getComputedStyle","parseTimes","x","endsWith","parseFloat","n","isNaN","maxT","durations","delays","Math","max","t","sumMax","transitionDuration","transitionDelay","aDur","animationDuration","aDel","animationDelay","iters","animationIterationCount","nA","maxA","dl","it","eff","finishers","waitEnd","done","ended","off","onEnd","to","setTimeout","removeEventListener","clearTimeout","invokeAfter","msUsed","startClassBased","A","F","enterFrom","leaveFrom","T","enterTo","leaveTo","offsetWidth","ms","startStyleFade","prevTransition","transition","prevOpacity","opacity","evaluator","_prevShown","isDirty","innerHTML","property","isCheckbox","isNumeric","isMultiSelect","tagName","multiple","getValueEvaluator","setValueEvaluator","checkboxValue","loopScope","_collectLoopScope","inferCheckboxValue","member","checked","sel","selected","setInputValue","eventType","currentData","getInputValue","currentVal","$value","placeholder","createComment","parentNode","insertBefore","__x_if_anchorParent","parentElement","branches","makeActualElement","content","cloneNode","isTemplate","first","firstOD","firstEval","__x_tool_bound","originalNodes","sib","isElse","isElseIf","branch","od","active","orig","removeChild","mountBranch","b","__x_if_current","nextSibling","_discoverNestedNamed","unmountBranch","eventName","passive","onlySelf","shouldPrevent","prevent","shouldStop","stop","isOutside","outside","isWindow","deferExec","defer","keyAliasMap","esc","escape","space","tab","backspace","del","arrowup","arrowdown","arrowleft","arrowright","home","pageup","pagedown","comboRequirements","ctrl","alt","shift","buttonMap","left","middle","right","touchSingle","single","touchMulti","multi","modifierKeys","allowedKeys","aliases","allowedButtons","btn","needKeyCheck","needButtonCheck","needTouchCheck","passesFilters","path","composedPath","tgt","contains","TouchEvent","tCount","touches","MouseEvent","button","KeyboardEvent","ctrlKey","altKey","shiftKey","metaKey","ev","createEventHandler","preventDefault","stopPropagation","canDelegate","_getConfig","delegate","ownerDocument","remover","_registerDelegated","comp","isStatement","JSON","stringify","match","params","p","mapArgs","thisCtx","compiledArrow","executor","_assertMutable","parentKey","method","Error","_wrapData","isArr","isSet","isMap","makeCollectionWrapper","beforeLen","beforeFirst","beforeLast","before","existed","proxy","Proxy","receiver","isCollection","Symbol","iterator","Reflect","bind","ownKeys","had","defineProperty","configurable","enumerable","writable","deleteProperty","ok","pc","_includeComputed","specials","$log","$destroy","$forceUpdate","$addCleanupFunction","$nextTick","Promise","resolve","$el","$id","$refs","_t","$ref","$isMounted","$isDestroyed","$isSealed","$isFrozen","$parent","$children","$seal","$mutate","prevMethod","propStr","_target","targetElement","component","mergedScope","gWindow","gDocument","sandbox","sandboxExpressions","allow","allowGlobals","ensureInvoker","registerResource","setup","inv","wrapTarget","prop","optSig","querySelector","querySelectorAll","doc","win","defaultView","wrapObserverCtor","Orig","observerArgs","observe","disconnect","inst","$target","$event","_routerEnabled","location","_navigate","href","setInterval","clearInterval","MutationObserver","ResizeObserver","IntersectionObserver","hasOwnProperty","_name","directiveInfo","isSvg","namespaceURI","baseSet","oc","className","finalCls","tokens","finalStr","baseStr","tk","cssText","cssProp","cur","anchorParent","__x_scope","scope","assign","_updateElementDirectives","root","force","Element","_updateElementDirectivesForVar","varName","re","_cleanupElementSubtree","toDelete","itemVar","indexVar","listCode","keyAttrName","keyExpr","templateToClone","contextAnchor","listEval","keyEval","BP_FOR","BP_KEY","BP_TEXT","BP_HTML","BP_DATA","hydrateFromBlueprint","cloneRoot","bp","instr","_resolveNodeByPath","j","dn","blueprint","walk","isRootEl","scan","dnames","concat","buildBlueprint","instances","createScope","item","idxOrKey","objIds","objSeq","keyFor","explicit","o","extractId","evalKeyExpr","norm","list","tag","keysArr","oldByObjKey","oldPrimQueues","__x_for_key","ps","__x_primSig","newNodes","nodeKey","explicitKey","existingScope","prevIdxRef","__x_idxRef","prevItemRef","__x_itemRef","needsUpdate","indexChanged","clone","initScope","sig","oldIndexMap","seq","oldIdx","lisMask","lis","_computeLISMask","tailAnchor","anchor","lisLen","predecessors","tails","tailIdx","lo","hi","mid","fill","dr","ReferenceError","itemscope","formnovalidate","novalidate","default","readonly","_components","_byEl","_pending","_config","_customDirectives","_currentArrayInterceptorComp","_namedComponentDefs","_delegated","_delegatedRootBound","_prefetched","_currentDocURL","_scrollPositions","_refsRegistry","_refCleanupRegistry","compRefs","refSet","_runRefCleanup","registerComponent","definition","_getRegisteredComponentDef","_preDiscoveryTasks","init","container","debug","staticDirectives","router","enabled","transitionName","_hpf","async","_applyPrefixInitialCSS","allSettled","_autoDiscoverComponents","_ensureRootObserver","_ensureDelegation","_installRouting","_normalizeDocURL","readyState","_inflightComponentLoads","_lazyComponentSources","loadComponents","sources","items","mode","tasks","_fetchAndEvalComponent","catch","then","inferredName","status","results","settled","failed","r","createComponent","_generateComponentId","dataAttr","_bindElementAsComponent","componentElements","reusable","_instantiateNamedComponent","_processPending","components","lastComponent","remaining","ready","containerEl","maybe","parentForEval","dataExpression","parentCtx","_parseDataExpression","desc","getOwnPropertyDescriptors","plainData","dsc","hasOwnMethods","methodsObj","initExpr","_finalizeComponentMount","xInitExpr","now","random","substring","parentHint","hosts","host","componentId","_log","_routerTransitionName","_isSameOrigin","u","URL","baseURI","origin","_isSameDocument","pathname","search","_scrollToHash","hash","decodeURIComponent","CSS","scrollIntoView","block","behavior","defaultPrevented","a","url","prefetchOnHover","preloadEventHandler","link","preload","targetURL","targetKey","err","curKey","scrollX","y","scrollY","html","_fetchHTML","history","pushState","_swapDocument","pos","scrollTo","message","res","fetch","credentials","cache","redirect","redirected","finalUrl","statusText","DOMParser","parseFromString","newHead","newTitle","applySwap","title","_morphElement","vt","startViewTransition","cont","getPropertyValue","finished","_setAttributes","curAttrs","nextAttrs","_attributesEqual","aNames","bNames","_isDynamicNode","nodeName","replaceWith","firstChild","curChildren","nextChildren","cn","nn","toRemove","retries","baseDelay","isTypeScript","strings","str","attempt","delay","pow","finally","_rootObserver","records","addedNodes","removedNodes","stack","_onComponentSourceChanged","ro","childList","subtree","attributes","attributeFilter","_ensureIO","_ioObservers","_ioRegistry","io","reg","isIntersecting","visible","lazy","promise","parentComp","par","props","dynamicPropObj","rawPropExpression","propExpr","propPrefix","modifierPropExpressions","resolvePropName","lower","tryMatch","evaluated","existingDynamic","modifierKeysToAppend","closeIndex","lastIndexOf","needsComma","appended","allKeys","initDef","baseData","makeData","compDef","originalChildren","replaceChildren","template","applyTemplate","tpl","slots","slotEl","matched","tplVal","append","nested","cancelBubble","h","captureEvents","bubbleEvents","l","w","XTool","FyneJS"],"sourceRoot":"./dist","sources":["dist/x-tool.js"],"sourcesContent":["import stripTypes from './src/strip-ts';\nimport { caseKebabToCamel } from './src/util';\nconst ARRAY_ISARRAY = Array.isArray;\nconst WkMap = WeakMap;\nconst quMct = queueMicrotask;\nconst FT_C = true;\nconst FT_TI = typeof __FEAT_TEXT_INTERP__ === 'boolean' ? __FEAT_TEXT_INTERP__ : true;\nconst _FT_DR = typeof __FEAT_DEEP_REACTIVE__ === 'boolean' ? __FEAT_DEEP_REACTIVE__ : true;\nconst FT_IFB = typeof __FEAT_IF_BRANCHES__ === 'boolean' ? __FEAT_IF_BRANCHES__ : true;\nconst FT_RT = typeof __FEAT_ROUTER__ === 'boolean' ? __FEAT_ROUTER__ : true;\nconst FT_TS = typeof __FEAT_TS__ === 'boolean' ? __FEAT_TS__ : true;\nconst FT_EXT_DIRS = typeof __FEAT_EXT_DIRECTIVES__ === 'boolean' ? __FEAT_EXT_DIRECTIVES__ : true;\nconst XToolFramework = function () {\n    const _se = (fn) => { try {\n        fn();\n    }\n    catch { } };\n    const _tr = (s) => (s || '').trim();\n    const _Afrom = Array.from;\n    const _AisArr = ARRAY_ISARRAY;\n    const _Okeys = Object.keys;\n    const STR_STYLE = 'style';\n    const STR_DISPLAY = 'display';\n    const STR_NONE = 'none';\n    const STR_TAGNAME = 'tagName';\n    const STR_TEMPLATE = 'TEMPLATE';\n    const STR_LENGTH = 'length';\n    const STR_SOURCE = 'source';\n    const STR_READONLY = 'readonly';\n    let XTOOL_ENABLE_STATIC_DIRECTIVES = true;\n    const d = (typeof document !== 'undefined' ? document : null);\n    const STR_CONTENTS = 'contents';\n    const EV_CLICK = 'click', EV_INPUT = 'input', EV_CHANGE = 'change', EV_KEYDOWN = 'keydown', EV_KEYUP = 'keyup';\n    const EV_DELEGATED = [EV_CLICK, EV_INPUT, EV_CHANGE, EV_KEYDOWN, EV_KEYUP];\n    const LS_PENDING = 0, LS_LOADING = 1, LS_LOADED = 2, LS_ERROR = 3;\n    try {\n        if (d && d.head && !d.getElementById('x-tool-initial-css')) {\n            const style = d.createElement(STR_STYLE);\n            style.id = 'x-tool-initial-css';\n            style.textContent = '[x-show],[x-if],[x-else],[x-else-if],[x\\\\:show],[x\\\\:if],[x\\\\:else],[x\\\\:else-if]{display:none;}';\n            d.head.appendChild(style);\n        }\n    }\n    catch { }\n    let PFX = 'x';\n    let attrCache = new Map();\n    const attrName = (name) => {\n        const cached = attrCache.get(name);\n        if (cached)\n            return cached;\n        const value = `${PFX}-${name}`;\n        attrCache.set(name, value);\n        return value;\n    };\n    class XToolFramework {\n        constructor() {\n            this._components = new Map();\n            this._byEl = new WkMap();\n            this._pending = [];\n            this._config = {};\n            this._customDirectives = new Map();\n            this._currentArrayInterceptorComp = null;\n            this._namedComponentDefs = new Map();\n            this._delegated = new WkMap();\n            this._delegatedRootBound = false;\n            this._prefetched = new Set();\n            this._currentDocURL = '';\n            this._scrollPositions = new Map();\n            this._refsRegistry = new WkMap();\n            this._refCleanupRegistry = new WkMap();\n            this._getComponentRefs = (comp, refName) => {\n                const compRefs = this._refsRegistry.get(comp);\n                return compRefs?.get(refName);\n            };\n            this._registerComponentRef = (comp, refName, el) => {\n                if (!FT_EXT_DIRS)\n                    return;\n                let compRefs = this._refsRegistry.get(comp);\n                if (!compRefs) {\n                    compRefs = new Map();\n                    this._refsRegistry.set(comp, compRefs);\n                }\n                let refSet = compRefs.get(refName);\n                if (!refSet) {\n                    refSet = new Set();\n                    compRefs.set(refName, refSet);\n                }\n                if (refSet.has(el))\n                    return;\n                refSet.add(el);\n                if (el instanceof Element === false)\n                    return;\n                this._refCleanupRegistry.set(el, () => {\n                    refSet.delete(el);\n                    if (refSet.size === 0) {\n                        compRefs.delete(refName);\n                    }\n                    if (compRefs.size === 0) {\n                        this._refsRegistry.delete(comp);\n                    }\n                });\n            };\n            this._runRefCleanup = (el) => {\n                const cleanup = this._refCleanupRegistry.get(el);\n                if (cleanup) {\n                    cleanup();\n                    this._refCleanupRegistry.delete(el);\n                }\n            };\n            this._clearComponentRefs = (comp) => {\n                this._refsRegistry.delete(comp);\n            };\n            this.directive = (name, directive) => {\n                if (name.startsWith(PFX + '-')) {\n                    throw new Error(`Custom directive names should not start with \"${PFX}-\". Use: XTool.directive(\"my-directive\", ...)`);\n                }\n                this._customDirectives.set(name, directive);\n                return this;\n            };\n            this.registerComponent = (definition) => {\n                if (!definition || !definition.name)\n                    throw new Error('registerComponent requires a name');\n                const name = definition.name.toLowerCase();\n                if (this._namedComponentDefs.has(name))\n                    return this;\n                this._namedComponentDefs.set(name, definition);\n                return this;\n            };\n            this._getRegisteredComponentDef = (name) => this._namedComponentDefs.get(name.toLowerCase());\n            this._getCustomDirective = (name) => this._customDirectives.get(name);\n            this._getConfig = () => this._config;\n            this._preDiscoveryTasks = [];\n            this.init = (config = {}) => {\n                const base = { container: 'body', debug: false, staticDirectives: true, router: { enabled: false, transitionName: 'route' } };\n                this._config = { ...base, ...config, router: { ...base.router, ...(config.router || {}) } };\n                if (typeof this._config.staticDirectives === 'boolean') {\n                    XTOOL_ENABLE_STATIC_DIRECTIVES = this._config.staticDirectives;\n                }\n                const _hpf = this._config.prefix;\n                if (_hpf && typeof _hpf === 'string' && _hpf[STR_LENGTH] > 0) {\n                    PFX = _hpf;\n                }\n                else {\n                    PFX = 'x';\n                }\n                attrCache.clear();\n                const start = async () => {\n                    this._applyPrefixInitialCSS();\n                    if (this._preDiscoveryTasks.length) {\n                        try {\n                            await Promise.allSettled(this._preDiscoveryTasks);\n                        }\n                        catch { }\n                    }\n                    this._autoDiscoverComponents();\n                    const c = d?.querySelector(this._config.container);\n                    if (c) {\n                        this._ensureRootObserver(c);\n                        if (this._config.delegate)\n                            this._ensureDelegation(c);\n                        if (FT_RT && this._routerEnabled())\n                            this._installRouting(c);\n                    }\n                    try {\n                        this._currentDocURL = this._normalizeDocURL(location.href);\n                    }\n                    catch { }\n                };\n                if (d && d.readyState === 'loading') {\n                    d.addEventListener('DOMContentLoaded', () => { void start(); });\n                }\n                else if (!d || d.readyState === 'complete' || d.readyState === 'interactive') {\n                    void start();\n                }\n                return this;\n            };\n            this._inflightComponentLoads = new Map();\n            this._lazyComponentSources = new Map();\n            this.loadComponents = (sources) => {\n                const items = sources.map(s => typeof s === 'string' ? { path: s, mode: 'preload', name: undefined } : { path: s.path, mode: (s.mode || 'preload'), name: s.name });\n                const tasks = [];\n                for (const it of items) {\n                    if (it.mode === 'defer') {\n                        const p = this._fetchAndEvalComponent(it.path).catch(() => { throw new Error('load failed'); });\n                        this._preDiscoveryTasks.push(p);\n                        tasks.push(p.then(() => { }));\n                    }\n                    else if (it.mode === 'lazy') {\n                        const inferredName = (it.name || it.path.split('/').pop() || '').replace(/\\.(mjs|js|ts)(\\?.*)?$/i, '').toLowerCase();\n                        if (inferredName && !this._lazyComponentSources.has(inferredName)) {\n                            this._lazyComponentSources.set(inferredName, { path: it.path, status: LS_PENDING });\n                        }\n                    }\n                    else {\n                        const p = this._fetchAndEvalComponent(it.path).catch(() => { throw new Error('load failed'); });\n                        tasks.push(p);\n                    }\n                }\n                return Promise.allSettled(tasks).then(results => {\n                    try {\n                        this._autoDiscoverComponents();\n                    }\n                    catch { }\n                    const settled = results.length;\n                    const failed = results.filter(r => r.status === 'rejected').length;\n                    return { settled, failed };\n                });\n            };\n            this.createComponent = (definition) => {\n                const component = new ReactiveComponent(this._generateComponentId(), definition, this);\n                this._components.set(component.id, component);\n                component.callBeforeMount();\n                return component;\n            };\n            this._autoDiscoverComponents = () => {\n                const container = d?.querySelector(this._config.container);\n                if (!container)\n                    return;\n                const dataAttr = attrName('data');\n                if (container.hasAttribute(dataAttr) && !this._getComponentByElement(container)) {\n                    this._bindElementAsComponent(container, undefined);\n                }\n                const componentElements = container.querySelectorAll(`[${dataAttr}]`);\n                for (const element of componentElements) {\n                    if (!this._getComponentByElement(element))\n                        this._bindElementAsComponent(element);\n                }\n                const reusable = container.querySelectorAll('component[source]');\n                for (const el of reusable) {\n                    if (!this._getComponentByElement(el))\n                        this._instantiateNamedComponent(el);\n                }\n                this._processPending();\n                if (componentElements[STR_LENGTH] === 0 && !this._getComponentByElement(container)) {\n                    const components = _Afrom(this._components.values());\n                    const lastComponent = components[components[STR_LENGTH] - 1];\n                    if (lastComponent && !lastComponent.isBound) {\n                        lastComponent.bindToElement(container);\n                    }\n                }\n            };\n            this._processPending = () => {\n                if (!this._pending[STR_LENGTH])\n                    return;\n                const remaining = [];\n                const ready = [];\n                const containerEl = (this._config.container ? d?.querySelector(this._config.container) : null);\n                for (const p of this._pending) {\n                    if (!p.el.isConnected) {\n                        remaining.push(p);\n                        continue;\n                    }\n                    let cur = p.el.parentElement;\n                    let parent;\n                    while (cur && !parent) {\n                        const maybe = this._getComponentByElement(cur);\n                        if (maybe)\n                            parent = maybe;\n                        else\n                            cur = cur.parentElement;\n                    }\n                    if (parent) {\n                        p.comp.attachToParent(parent);\n                        ready.push(p.comp);\n                    }\n                    else if (containerEl && (containerEl === p.el || containerEl.contains(p.el))) {\n                        ready.push(p.comp);\n                    }\n                    else {\n                        remaining.push(p);\n                    }\n                }\n                for (const c of ready)\n                    c.completeBinding();\n                this._pending = remaining;\n            };\n            this._bindElementAsComponent = (element, parentForEval) => {\n                const dataExpression = element.getAttribute(attrName('data'));\n                let data = {};\n                if (dataExpression) {\n                    element.removeAttribute(attrName('data'));\n                    try {\n                        if (parentForEval) {\n                            let parentCtx = {};\n                            if (parentForEval._createMethodContext) {\n                                try {\n                                    parentCtx = parentForEval._createMethodContext();\n                                }\n                                catch { }\n                            }\n                            const evalFn = new Function('parent', `with(parent){ return (${dataExpression}) }`);\n                            data = evalFn(parentCtx);\n                        }\n                        else {\n                            data = this._parseDataExpression(dataExpression);\n                        }\n                        const desc = Object.getOwnPropertyDescriptors(data);\n                        const computed = {};\n                        const plainData = {};\n                        for (const key in desc) {\n                            const dsc = desc[key];\n                            if (typeof dsc.get === 'function') {\n                                computed[key] = dsc.get;\n                            }\n                            else if ('value' in dsc) {\n                                plainData[key] = dsc.value;\n                            }\n                        }\n                        const hasOwnMethods = plainData.methods || data.methods;\n                        const methodsObj = data.methods;\n                        const def = hasOwnMethods ? { methods: methodsObj, data: plainData } : { data: plainData };\n                        if (_Okeys(computed).length)\n                            def.computed = computed;\n                        if (parentForEval) {\n                            def.data.$parent = parentForEval;\n                        }\n                        data = def;\n                    }\n                    catch (e) {\n                    }\n                }\n                const comp = this.createComponent(data);\n                const initExpr = element.getAttribute(attrName('init')) || undefined;\n                if (initExpr)\n                    element.removeAttribute(attrName('init'));\n                this._finalizeComponentMount(element, comp, { callBeforeMount: true, xInitExpr: initExpr });\n            };\n            this._generateComponentId = () => {\n                const now = Date.now();\n                const random = Math.random().toString(36).substring(2, 15);\n                const counter = (this._components.size + 1).toString(36);\n                return `component_${now}_${counter}_${random}`;\n            };\n            this._discoverNestedNamed = (root, parentHint) => {\n                try {\n                    const hosts = [];\n                    if (root[STR_TAGNAME] === 'COMPONENT' && root.hasAttribute('source'))\n                        hosts.push(root);\n                    const found = root.querySelectorAll('component[source]');\n                    for (const el of found)\n                        hosts.push(el);\n                    for (const host of hosts) {\n                        if (!this._getComponentByElement(host))\n                            this._instantiateNamedComponent(host, parentHint);\n                    }\n                }\n                catch { }\n            };\n            this._parseDataExpression = (expression) => {\n                try {\n                    return new Function('return ' + expression.trim())();\n                }\n                catch {\n                    return {};\n                }\n            };\n            this._unregisterComponent = (componentId) => { this._components.delete(componentId); };\n            this._log = (..._args) => { };\n            this._registerElement = (element, component) => {\n                this._byEl.set(element, component);\n            };\n            this._unregisterElement = (element) => { try {\n                this._byEl.delete(element);\n            }\n            catch { } };\n        }\n        _routerEnabled() { const c = this._config; return !!(c.router?.enabled); }\n        _routerTransitionName() { const c = this._config; return (c.router?.transitionName ?? 'route'); }\n        _isSameOrigin(href) {\n            if (!FT_RT)\n                return false;\n            try {\n                const u = new URL(href, d?.baseURI || location.href);\n                const cur = new URL(location.href);\n                return u.origin === cur.origin;\n            }\n            catch {\n                return false;\n            }\n        }\n        _isSameDocument(target) {\n            if (!FT_RT)\n                return false;\n            try {\n                const u = typeof target === 'string' ? new URL(target, d?.baseURI || location.href) : target;\n                const cur = new URL(location.href);\n                return (u.origin === cur.origin && u.pathname === cur.pathname && u.search === cur.search);\n            }\n            catch {\n                return false;\n            }\n        }\n        _normalizeDocURL(target) {\n            const u = typeof target === 'string' ? new URL(target, d?.baseURI || location.href) : target;\n            return `${u.origin}${u.pathname}${u.search}`;\n        }\n        _scrollToHash(hash) {\n            if (FT_RT === false)\n                return false;\n            try {\n                if (!hash || hash === '#')\n                    return false;\n                const id = decodeURIComponent(hash.replace(/^#/, ''));\n                const el = d.getElementById(id) || d.querySelector(`[name=\"${CSS.escape(id)}\"]`);\n                if (el) {\n                    el.scrollIntoView({ block: 'start', 'behavior': 'instant' });\n                    return true;\n                }\n            }\n            catch { }\n            return false;\n        }\n        _installRouting(root) {\n            if (!FT_RT)\n                return;\n            const self = this;\n            const preload = (href) => {\n                try {\n                    if (!self._isSameOrigin(href))\n                        return;\n                }\n                catch {\n                    return;\n                }\n                const u = new URL(href, location.href);\n                if (self._isSameDocument(u))\n                    return;\n                u.hash = '';\n                const url = u.toString();\n                if (self._prefetched.has(url))\n                    return;\n                const existing = d?.head?.querySelector(`link[rel=\"prefetch\"][href=\"${CSS.escape(url)}\"]`);\n                if (existing) {\n                    self._prefetched.add(url);\n                    return;\n                }\n                try {\n                    const link = d.createElement('link');\n                    link.setAttribute('rel', 'prefetch');\n                    link.setAttribute('as', 'document');\n                    link.setAttribute('href', url);\n                    d.head.appendChild(link);\n                    self._prefetched.add(url);\n                }\n                catch { }\n            };\n            const onClick = (e) => {\n                const ev = e;\n                if (ev.defaultPrevented || ev.metaKey || ev.ctrlKey || ev.shiftKey || ev.altKey)\n                    return;\n                let el = ev.target;\n                while (el && el !== root && el.tagName !== 'A')\n                    el = el.parentElement;\n                if (!el || el.tagName !== 'A' || el.hasAttribute('download'))\n                    return;\n                const a = el;\n                const href = a.getAttribute('href');\n                if (!href || href.startsWith('#'))\n                    return;\n                const target = a.getAttribute('target');\n                if (target && target.toLowerCase() === '_blank')\n                    return;\n                if (!self._isSameOrigin(href))\n                    return;\n                const url = new URL(href, location.href);\n                if (self._isSameDocument(url))\n                    return;\n                ev.preventDefault();\n                self._navigate(url.toString(), true, 'link').catch(() => { location.assign(url.toString()); });\n            };\n            root.addEventListener('click', onClick);\n            if (this._config.router?.prefetchOnHover) {\n                const preloadEventHandler = (e) => {\n                    const t = e.target;\n                    let el = t;\n                    while (el && el !== root && el.tagName !== 'A')\n                        el = el.parentElement;\n                    if (!el || el.tagName !== 'A' || el.hasAttribute('download'))\n                        return;\n                    const href = el.getAttribute('href');\n                    if (!href || href.startsWith('#'))\n                        return;\n                    preload(href);\n                };\n                root.addEventListener('mouseover', preloadEventHandler, { passive: true });\n                root.addEventListener('touchstart', preloadEventHandler, { passive: true });\n            }\n            window.addEventListener('popstate', () => { self._navigate(location.href, false, 'popstate').catch(() => { }); });\n        }\n        async _navigate(url, push, source = 'program') {\n            if (!FT_RT)\n                return;\n            if (!this._routerEnabled())\n                return Promise.resolve();\n            if (!this._isSameOrigin(url)) {\n                location.assign(url);\n                return;\n            }\n            const targetURL = new URL(url);\n            const targetKey = this._normalizeDocURL(targetURL);\n            if (source !== 'popstate') {\n                if (this._isSameDocument(targetURL)) {\n                    location.href = url;\n                    return;\n                }\n            }\n            else {\n                if (this._currentDocURL && targetKey === this._currentDocURL) {\n                    this._scrollToHash(targetURL.hash);\n                    return;\n                }\n            }\n            const from = location.href;\n            try {\n                const res = await (this._config.router?.before?.(url, from, { source }));\n                if (res === false)\n                    return;\n            }\n            catch (err) {\n                try {\n                    this._config.router?.error?.(err, url, from);\n                }\n                catch { }\n                return;\n            }\n            const curKey = this._currentDocURL || this._normalizeDocURL(from);\n            this._scrollPositions.set(curKey, { x: window.scrollX || 0, y: window.scrollY || 0 });\n            try {\n                const html = await this._fetchHTML(url);\n                if (push)\n                    history.pushState({}, '', url);\n                await this._swapDocument(html);\n                this._currentDocURL = targetKey;\n                _se(() => {\n                    if (source === 'popstate') {\n                        const pos = this._scrollPositions.get(targetKey);\n                        if (pos)\n                            (window).scrollTo(pos.x, pos.y);\n                        else if (!this._scrollToHash(targetURL.hash))\n                            (window).scrollTo(0, 0);\n                    }\n                    else {\n                        if (!this._scrollToHash(targetURL.hash))\n                            (window).scrollTo(0, 0);\n                    }\n                });\n                try {\n                    await this._config.router?.after?.(url, from, { source });\n                }\n                catch { }\n            }\n            catch (err) {\n                if (err && (err.name === 'XToolRedirect' || err.message === 'XToolRedirect'))\n                    return;\n                _se(() => this._config.router?.error?.(err, url, from));\n                try {\n                    location.assign(url);\n                }\n                catch {\n                    _se(() => location.href = url);\n                }\n            }\n        }\n        async _fetchHTML(url) {\n            if (!FT_RT)\n                return Promise.reject();\n            const res = await fetch(url, { credentials: 'same-origin', cache: 'default', redirect: 'follow' });\n            if (res.redirected) {\n                const finalUrl = res.url;\n                try {\n                    location.assign(finalUrl);\n                }\n                catch {\n                    _se(() => location.href = finalUrl);\n                }\n                const e = new Error('XToolRedirect');\n                e.name = 'XToolRedirect';\n                e.url = finalUrl;\n                throw e;\n            }\n            if (!res.ok)\n                throw new Error(res.status + ' ' + res.statusText);\n            return await res.text();\n        }\n        async _swapDocument(html) {\n            if (!FT_RT)\n                return;\n            const parser = new DOMParser();\n            const doc = parser.parseFromString(html, 'text/html');\n            const newHead = doc.head;\n            const newTitle = newHead?.querySelector('title');\n            const applySwap = () => {\n                if (newTitle) {\n                    const t = newTitle.textContent || '';\n                    if (document.title !== t)\n                        document.title = t;\n                }\n                const sel = this._config.container || 'body';\n                const cur = d.querySelector(sel);\n                const next = doc.querySelector(sel);\n                if (cur && next) {\n                    this._morphElement(cur, next);\n                }\n                else if (next) {\n                    d.body.innerHTML = next.innerHTML;\n                }\n                else {\n                    d.body.innerHTML = doc.body.innerHTML;\n                }\n                this._byEl.delete(cur);\n                this._autoDiscoverComponents();\n                const c = d?.querySelector(this._config.container);\n                if (c) {\n                    this._ensureRootObserver(c);\n                    if (this._config.delegate)\n                        this._ensureDelegation(c);\n                }\n            };\n            const vt = (document).startViewTransition?.bind(document);\n            if (vt && this._getConfig().router?.transitionName) {\n                const sel = this._config.container || 'body';\n                const cont = d.querySelector(sel);\n                const prev = cont ? (cont.style.getPropertyValue('view-transition-name') || '') : '';\n                _se(() => { if (cont)\n                    cont.style.setProperty('view-transition-name', this._routerTransitionName()); });\n                try {\n                    const transition = vt(applySwap);\n                    await transition.finished;\n                }\n                finally {\n                    try {\n                        if (cont) {\n                            if (prev)\n                                cont.style.setProperty('view-transition-name', prev);\n                            else\n                                cont.style.removeProperty('view-transition-name');\n                        }\n                    }\n                    catch { }\n                }\n            }\n            else\n                applySwap();\n        }\n        _setAttributes(cur, next) {\n            if (!FT_RT)\n                return;\n            const curAttrs = cur.getAttributeNames();\n            for (let i = 0; i < curAttrs.length; i++) {\n                const name = curAttrs[i];\n                if (!next.hasAttribute(name))\n                    cur.removeAttribute(name);\n            }\n            const nextAttrs = next.getAttributeNames();\n            for (let i = 0; i < nextAttrs.length; i++) {\n                const name = nextAttrs[i];\n                const val = next.getAttribute(name);\n                if (cur.getAttribute(name) !== val)\n                    cur.setAttribute(name, val);\n            }\n        }\n        _attributesEqual(a, b) {\n            if (!FT_RT)\n                return false;\n            const aNames = a.getAttributeNames();\n            const bNames = b.getAttributeNames();\n            if (aNames.length !== bNames.length)\n                return false;\n            const map = new Map();\n            for (let i = 0; i < aNames.length; i++) {\n                const n = aNames[i];\n                map.set(n, a.getAttribute(n));\n            }\n            for (let i = 0; i < bNames.length; i++) {\n                const n = bNames[i];\n                if (!map.has(n))\n                    return false;\n                if (map.get(n) !== b.getAttribute(n))\n                    return false;\n            }\n            return true;\n        }\n        _isDynamicNode(el) {\n            const tag = el.tagName;\n            if (tag === 'IFRAME' && el.hasAttribute('src'))\n                return true;\n            if (tag === 'COMPONENT' && el.hasAttribute('source'))\n                return true;\n            return false;\n        }\n        _morphElement(cur, next) {\n            if (!FT_RT)\n                return;\n            if (cur.nodeName !== next.nodeName || this._isDynamicNode(next)) {\n                cur.replaceWith(next.cloneNode(true));\n                return;\n            }\n            this._setAttributes(cur, next);\n            if (!cur.firstChild && !next.firstChild)\n                return;\n            const curChildren = Array.from(cur.childNodes);\n            const nextChildren = Array.from(next.childNodes);\n            const max = nextChildren.length;\n            for (let i = 0; i < max; i++) {\n                const n = nextChildren[i];\n                const c = curChildren[i];\n                if (!c) {\n                    cur.appendChild(n.cloneNode(true));\n                    continue;\n                }\n                if (n.nodeType === c.nodeType) {\n                    if (n.nodeType === 3) {\n                        const a = c;\n                        const b = n;\n                        if (a.data !== b.data)\n                            a.data = b.data;\n                    }\n                    else if (n.nodeType === 1) {\n                        const cn = c;\n                        const nn = n;\n                        if (this._isDynamicNode(nn)) {\n                            try {\n                                cn.replaceWith(nn.cloneNode(true));\n                            }\n                            catch { }\n                        }\n                        else if (cn.nodeName === nn.nodeName && this._attributesEqual(cn, nn)) {\n                            this._morphElement(cn, nn);\n                        }\n                        else {\n                            try {\n                                cn.replaceWith(nn.cloneNode(true));\n                            }\n                            catch { }\n                        }\n                    }\n                    else {\n                        try {\n                            c.replaceWith(n.cloneNode(true));\n                        }\n                        catch { }\n                    }\n                }\n                else {\n                    try {\n                        c.replaceWith(n.cloneNode(true));\n                    }\n                    catch { }\n                }\n            }\n            if (curChildren.length > max) {\n                for (let i = curChildren.length - 1; i >= max; i--) {\n                    const toRemove = cur.childNodes[i];\n                    try {\n                        cur.removeChild(toRemove);\n                    }\n                    catch { }\n                }\n            }\n        }\n        _fetchAndEvalComponent(path, retries = 2, baseDelay = 300) {\n            const existing = this._inflightComponentLoads.get(path);\n            if (existing)\n                return existing;\n            const self = this;\n            const isTypeScript = /\\.ts?$/.test(new URL(path, d?.baseURI || location.href).pathname);\n            if (isTypeScript && !FT_TS) {\n                throw new Error(`TypeScript component loading is not enabled in tiny builds. Loading failed for: ${path} failed.`);\n            }\n            const html = (strings, ...values) => strings.reduce((acc, str, i) => acc + str + (i < values.length ? values[i] : ''), '') + `\\n`;\n            const attempt = (n) => {\n                return fetch(path, { cache: 'no-cache' }).then(res => {\n                    if (!res.ok)\n                        throw new Error(res.status + ' ' + res.statusText);\n                    return res.text();\n                }).then(code => {\n                    if (FT_TS && isTypeScript) {\n                        code = stripTypes(code);\n                    }\n                    const wrapped = code + `\\n//# sourceURL=${path}`;\n                    try {\n                        new Function('XTool', 'html', wrapped)(self, html);\n                    }\n                    catch (err) {\n                        console.error(`Error evaluating component script at ${path}:`, err);\n                    }\n                }).catch(err => {\n                    if (n >= retries)\n                        throw err;\n                    const delay = baseDelay * Math.pow(2, n);\n                    return new Promise(resolve => setTimeout(resolve, delay)).then(() => attempt(n + 1));\n                });\n            };\n            const p = attempt(0).finally(() => { this._inflightComponentLoads.delete(path); });\n            this._inflightComponentLoads.set(path, p);\n            return p;\n        }\n        _applyPrefixInitialCSS() {\n            if (!d)\n                return;\n            if (PFX === 'x')\n                return;\n            const id = `x-tool-initial-css-${PFX}`;\n            if (d.head && !d.getElementById(id)) {\n                const style = d.createElement(STR_STYLE);\n                style.id = id;\n                style.textContent = `[${PFX}-show],[${PFX}-if],[${PFX}-else],[${PFX}-else-if],[${PFX}\\\\:show],[${PFX}\\\\:if],[${PFX}\\\\:else],[${PFX}\\\\:else-if]{display:none;}`;\n                d.head.appendChild(style);\n            }\n        }\n        _ensureRootObserver(container) {\n            if (this._rootObserver || typeof MutationObserver === 'undefined')\n                return;\n            this._rootObserver = new MutationObserver(records => {\n                for (const r of records) {\n                    if (r.type === 'childList') {\n                        for (let i = 0; i < r.addedNodes.length; i++) {\n                            const n = r.addedNodes[i];\n                            if (n.nodeType !== 1)\n                                continue;\n                            const el = n;\n                            if (el[STR_TAGNAME] === 'COMPONENT') {\n                                const src = el.getAttribute(STR_SOURCE);\n                                if (src && !this._getComponentByElement(el))\n                                    this._instantiateNamedComponent(el);\n                            }\n                        }\n                        for (let i = 0; i < r.removedNodes.length; i++) {\n                            const n = r.removedNodes[i];\n                            if (n.nodeType !== 1)\n                                continue;\n                            const el = n;\n                            quMct(() => {\n                                if (el.isConnected)\n                                    return;\n                                this._runRefCleanup(el);\n                                const stack = [el];\n                                while (stack.length) {\n                                    const cur = stack.pop();\n                                    const comp = this._getComponentByElement(cur);\n                                    if (comp && !comp.isDestroyed) {\n                                        try {\n                                            this._clearComponentRefs(comp);\n                                            comp.destroy();\n                                        }\n                                        catch { }\n                                    }\n                                    let child = cur.firstElementChild;\n                                    while (child) {\n                                        stack.push(child);\n                                        child = child.nextElementSibling;\n                                    }\n                                }\n                            });\n                        }\n                    }\n                    else if (r.type === 'attributes') {\n                        const target = r.target;\n                        if (target && target[STR_TAGNAME] === 'COMPONENT') {\n                            if (r.attributeName === STR_SOURCE) {\n                                this._onComponentSourceChanged(target);\n                            }\n                            else if (r.attributeName === STR_READONLY) {\n                                const comp = this._getComponentByElement(target);\n                                if (comp) {\n                                    try {\n                                        const ro = target.hasAttribute(STR_READONLY);\n                                        comp.setFrozen(!!ro);\n                                    }\n                                    catch { }\n                                }\n                            }\n                        }\n                    }\n                }\n                this._processPending();\n            });\n            this._rootObserver.observe(container, { childList: true, subtree: true, attributes: true, attributeFilter: [STR_SOURCE, STR_READONLY] });\n        }\n        _ensureIO(rootMargin) {\n            if (!FT_EXT_DIRS)\n                return null;\n            if (typeof IntersectionObserver === 'undefined')\n                return null;\n            if (!this._ioObservers)\n                this._ioObservers = new Map();\n            if (!this._ioRegistry)\n                this._ioRegistry = new WkMap();\n            const key = rootMargin || '0px';\n            let io = this._ioObservers.get(key);\n            if (io)\n                return io;\n            const handle = (entries) => {\n                for (const entry of entries) {\n                    const el = entry.target;\n                    const reg = this._ioRegistry.get(el);\n                    if (!reg)\n                        continue;\n                    const now = !!entry.isIntersecting;\n                    const before = !!reg.visible;\n                    reg.visible = now;\n                    if (now && (!before)) {\n                        const arr = reg.enter || [];\n                        for (let i = 0; i < arr.length; i++) {\n                            _se(() => arr[i].cb(entry, { phase: 'enter', visible: now, before }));\n                        }\n                        if (arr.length)\n                            reg.enter = arr.filter(a => !a.once);\n                    }\n                    else if (!now && before) {\n                        const arr = reg.leave || [];\n                        for (let i = 0; i < arr.length; i++) {\n                            _se(() => arr[i].cb(entry, { phase: 'leave', visible: now, before }));\n                        }\n                        if (arr.length)\n                            reg.leave = arr.filter(a => !a.once);\n                    }\n                }\n            };\n            io = new IntersectionObserver(handle, { root: null, rootMargin: key });\n            this._ioObservers.set(key, io);\n            return io;\n        }\n        _ioObserve(el, rootMargin, onEnter, onLeave) {\n            if (!FT_EXT_DIRS)\n                return () => { };\n            const io = this._ensureIO(rootMargin);\n            if (!io)\n                return () => { };\n            if (!this._ioRegistry)\n                this._ioRegistry = new WkMap();\n            let reg = this._ioRegistry.get(el);\n            if (!reg) {\n                reg = { rootMargin };\n                this._ioRegistry.set(el, reg);\n            }\n            if (onEnter && onEnter.cb) {\n                (reg.enter || (reg.enter = [])).push({ cb: onEnter.cb, once: !!onEnter.once });\n            }\n            if (onLeave && onLeave.cb) {\n                (reg.leave || (reg.leave = [])).push({ cb: onLeave.cb, once: !!onLeave.once });\n            }\n            _se(() => io.observe(el));\n            return () => { _se(() => io.unobserve(el)); };\n        }\n        _onComponentSourceChanged(el) {\n            const src = _tr(el.getAttribute('source'));\n            const existing = this._getComponentByElement(el);\n            if (!src) {\n                if (existing && !existing.isDestroyed) {\n                    try {\n                        existing.destroy();\n                    }\n                    catch { }\n                }\n                el.innerHTML = '';\n                return;\n            }\n            if (existing && !existing.isDestroyed) {\n                try {\n                    existing.destroy();\n                }\n                catch { }\n            }\n            el.innerHTML = '';\n            this._instantiateNamedComponent(el);\n        }\n        _finalizeComponentMount(el, comp, opts) {\n            comp.element = el;\n            if (opts?.callBeforeMount) {\n                _se(() => comp.callBeforeMount());\n            }\n            this._registerElement(comp.element, comp);\n            this._pending.push({ el, comp });\n            if (opts?.xInitExpr) {\n                comp._setXInitExpr(opts.xInitExpr);\n            }\n        }\n        _instantiateNamedComponent(el, parentHint) {\n            const source = el.getAttribute('source');\n            if (!source)\n                return;\n            let def = this._getRegisteredComponentDef(source);\n            if (!def) {\n                const name = source.toLowerCase();\n                const lazy = this._lazyComponentSources?.get(name);\n                if (lazy) {\n                    if (lazy.status === LS_PENDING) {\n                        lazy.status = LS_LOADING;\n                        lazy.promise = this._fetchAndEvalComponent(lazy.path)\n                            .then(() => { lazy.status = LS_LOADED; })\n                            .catch(() => { lazy.status = LS_ERROR; });\n                    }\n                    lazy.promise?.then(() => { _se(() => { const again = this._getRegisteredComponentDef(source); if (again)\n                        this._instantiateNamedComponent(el); }); });\n                }\n                return;\n            }\n            let parentComp = parentHint;\n            if (!parentComp) {\n                let par = el.parentElement;\n                while (par && !parentComp) {\n                    const maybe = this._getComponentByElement(par);\n                    if (maybe)\n                        parentComp = maybe;\n                    else\n                        par = par.parentElement;\n                }\n            }\n            let props = null;\n            let dynamicPropObj = null;\n            let rawPropExpression = null;\n            if (!props)\n                props = {};\n            const propExpr = el.getAttribute(attrName('prop'));\n            const propBase = attrName('prop');\n            const propPrefix = propBase + ':';\n            const modifierPropExpressions = {};\n            const resolvePropName = (raw) => {\n                if (!raw)\n                    return raw;\n                const lower = raw.toLowerCase();\n                const tryMatch = (obj) => {\n                    if (!obj)\n                        return null;\n                    for (const k of Object.keys(obj)) {\n                        if (k.toLowerCase() === lower)\n                            return k;\n                    }\n                    return null;\n                };\n                const fromPropEff = tryMatch(def?.propEffects);\n                if (fromPropEff)\n                    return fromPropEff;\n                if (raw.includes('-')) {\n                    return caseKebabToCamel(raw);\n                }\n                return raw;\n            };\n            for (const attr of Array.from(el.attributes)) {\n                const name = attr.name;\n                if (name.startsWith(propPrefix)) {\n                    const rawKey = name.substring(propPrefix.length);\n                    const key = resolvePropName(rawKey);\n                    if (key)\n                        modifierPropExpressions[key] = attr.value;\n                    el.removeAttribute(name);\n                }\n            }\n            if (propExpr) {\n                rawPropExpression = propExpr;\n                if (parentComp) {\n                    try {\n                        const fn = new Function('ctx', 'with(ctx){return (' + propExpr + ')}');\n                        const ctx = parentComp.getContext(true);\n                        dynamicPropObj = fn(ctx);\n                    }\n                    catch {\n                        dynamicPropObj = null;\n                    }\n                }\n                else {\n                    try {\n                        dynamicPropObj = new Function('return (' + propExpr + ')')();\n                    }\n                    catch {\n                        dynamicPropObj = null;\n                    }\n                }\n                if (dynamicPropObj && typeof dynamicPropObj === 'object')\n                    for (const k in dynamicPropObj)\n                        if (!(k in props))\n                            props[k] = dynamicPropObj[k];\n                el.removeAttribute(attrName('prop'));\n            }\n            if (Object.keys(modifierPropExpressions).length) {\n                const evaluated = {};\n                for (const [k, expr] of Object.entries(modifierPropExpressions)) {\n                    let val;\n                    if (parentComp) {\n                        try {\n                            const fn = new Function('ctx', 'with(ctx){return (' + expr + ')}');\n                            val = fn(parentComp.getContext(true));\n                        }\n                        catch {\n                            val = undefined;\n                        }\n                    }\n                    else {\n                        try {\n                            val = new Function('return (' + expr + ')')();\n                        }\n                        catch {\n                            val = undefined;\n                        }\n                    }\n                    evaluated[k] = val;\n                    if (!(k in props))\n                        props[k] = String(val);\n                }\n                const existingDynamic = dynamicPropObj ? { ...dynamicPropObj } : {};\n                dynamicPropObj = { ...existingDynamic };\n                for (const k in evaluated)\n                    if (!(k in existingDynamic))\n                        dynamicPropObj[k] = evaluated[k];\n                const modifierKeysToAppend = Object.keys(evaluated).filter(k => !(k in existingDynamic));\n                if (modifierKeysToAppend.length) {\n                    if (rawPropExpression && /}\\s*$/.test(rawPropExpression.trim())) {\n                        const trimmed = rawPropExpression.trim();\n                        const closeIndex = trimmed.lastIndexOf('}');\n                        if (closeIndex > -1) {\n                            const head = trimmed.slice(0, closeIndex);\n                            const needsComma = /{\\s*$/.test(head) ? false : true;\n                            const appended = modifierKeysToAppend.map(k => `${k}: ${modifierPropExpressions[k]}`).join(', ');\n                            rawPropExpression = head + (needsComma ? ', ' : ' ') + appended + '}';\n                        }\n                    }\n                    else {\n                        rawPropExpression = '{ ' + modifierKeysToAppend.map(k => `${k}: ${modifierPropExpressions[k]}`).join(', ') + ' }';\n                    }\n                }\n                else if (!rawPropExpression) {\n                    const allKeys = Object.keys(modifierPropExpressions);\n                    if (allKeys.length)\n                        rawPropExpression = '{ ' + allKeys.map(k => `${k}: ${modifierPropExpressions[k]}`).join(', ') + ' }';\n                }\n            }\n            let baseData = {};\n            if (def.makeData) {\n                _se(() => { const result = def.makeData(props); if (result)\n                    baseData = result; });\n            }\n            if (def.data) {\n                for (const k in def.data) {\n                    baseData[k] = def.data[k];\n                }\n            }\n            if (dynamicPropObj && typeof dynamicPropObj === 'object') {\n                for (const k in dynamicPropObj) {\n                    baseData[k] = dynamicPropObj[k];\n                }\n            }\n            else {\n                for (const k in props) {\n                    baseData[k] = props[k];\n                }\n            }\n            baseData.$props = props;\n            let initDef;\n            if (typeof def.init === 'function') {\n                try {\n                    const maybe = def.init(props);\n                    initDef = (maybe && typeof maybe === 'object') ? maybe : undefined;\n                }\n                catch {\n                    initDef = undefined;\n                }\n            }\n            const compDef = {\n                data: baseData,\n                methods: { ...(def.methods || {}), ...(initDef?.methods || {}) },\n                computed: { ...(def.computed || {}), ...(initDef?.computed || {}) },\n                propEffects: { ...(def.propEffects || {}), ...(initDef?.propEffects || {}) },\n                mounted: initDef?.mounted || def.mounted,\n                unmounted: initDef?.unmounted || def.unmounted,\n                beforeMount: initDef?.beforeMount || def.beforeMount,\n                beforeUnmount: initDef?.beforeUnmount || def.beforeUnmount,\n                updated: initDef?.updated || def.updated,\n                destroyed: initDef?.destroyed || def.destroyed,\n                beforeDestroy: initDef?.beforeDestroy || def.beforeDestroy\n            };\n            const comp = this.createComponent(compDef);\n            const originalChildren = Array.from(el.childNodes);\n            if (originalChildren.length)\n                el.replaceChildren();\n            if (def.template) {\n                const applyTemplate = (tpl) => {\n                    el.innerHTML = tpl;\n                    const slots = el.querySelectorAll('slot');\n                    if (slots.length) {\n                        for (const slotEl of slots) {\n                            const name = slotEl.getAttribute('name');\n                            const matched = name\n                                ? originalChildren.filter(n => n.nodeType === 1 && n.getAttribute('slot') === name)\n                                : originalChildren.filter(n => n.nodeType !== 1 || !n.hasAttribute('slot'));\n                            if (matched.length)\n                                slotEl.replaceWith(...matched);\n                        }\n                    }\n                };\n                const tplVal = def.template;\n                if (typeof tplVal === 'string') {\n                    applyTemplate(tplVal);\n                }\n                else if (typeof tplVal === 'function') {\n                    try {\n                        const res = tplVal();\n                        if (res && typeof res.then === 'function') {\n                            el.innerHTML = '';\n                            res.then(html => { applyTemplate(html || ''); _se(() => comp._applyAsyncTemplateResolved()); });\n                        }\n                        else {\n                            applyTemplate(String(res || ''));\n                        }\n                    }\n                    catch {\n                        el.innerHTML = '';\n                    }\n                }\n                else if (tplVal && typeof tplVal.then === 'function') {\n                    el.innerHTML = '';\n                    tplVal.then(html => { applyTemplate(html || ''); _se(() => comp._applyAsyncTemplateResolved()); });\n                }\n            }\n            else {\n                if (originalChildren.length)\n                    el.append(...originalChildren);\n            }\n            this._finalizeComponentMount(el, comp, { callBeforeMount: false });\n            try {\n                const nested = el.querySelectorAll(`[${attrName('data')}]`);\n                for (const node of nested) {\n                    if (!this._getComponentByElement(node))\n                        this._bindElementAsComponent(node, comp);\n                }\n            }\n            catch { }\n            try {\n                this._discoverNestedNamed(el, comp);\n            }\n            catch { }\n            if (rawPropExpression && parentComp) {\n                _se(() => comp._initReactiveProps(rawPropExpression, parentComp));\n            }\n            this._processPending();\n        }\n        _getComponentByElement(element) { return this._byEl.get(element); }\n        observe(_element) { }\n        _ensureDelegation(container) {\n            if (this._delegatedRootBound)\n                return;\n            const root = container;\n            const handler = (e) => {\n                let cur = e.target;\n                while (cur && cur !== root.parentElement) {\n                    if (e.cancelBubble)\n                        break;\n                    const map = this._delegated.get(cur);\n                    if (map) {\n                        const list = map.get(e.type);\n                        if (list && list.length) {\n                            for (const h of [...list]) {\n                                try {\n                                    if (h.comp && h.comp.isDestroyed) {\n                                        const i = list.indexOf(h);\n                                        if (i > -1)\n                                            list.splice(i, 1);\n                                        continue;\n                                    }\n                                    if (!h.filter || h.filter(e)) {\n                                        h.run(e);\n                                        if (h.once) {\n                                            const idx = list.indexOf(h);\n                                            if (idx > -1)\n                                                list.splice(idx, 1);\n                                        }\n                                    }\n                                }\n                                catch { }\n                            }\n                        }\n                    }\n                    cur = cur.parentElement;\n                }\n            };\n            const captureEvents = ['keydown', 'keyup'];\n            const bubbleEvents = ['click', 'input', 'change'];\n            for (const ev of captureEvents)\n                root.addEventListener(ev, handler, true);\n            for (const ev of bubbleEvents)\n                root.addEventListener(ev, handler, false);\n            this._delegatedRootBound = true;\n        }\n        _registerDelegated(element, event, entry) {\n            let map = this._delegated.get(element);\n            if (!map) {\n                map = new Map();\n                this._delegated.set(element, map);\n            }\n            let list = map.get(event);\n            if (!list) {\n                list = [];\n                map.set(event, list);\n            }\n            list.push(entry);\n            return () => {\n                try {\n                    const m = this._delegated.get(element);\n                    const l = m?.get(event);\n                    if (!l)\n                        return;\n                    const idx = l.indexOf(entry);\n                    if (idx > -1)\n                        l.splice(idx, 1);\n                }\n                catch { }\n            };\n        }\n    }\n    class ReactiveComponent {\n        attachToParent(parent) {\n            this._parent = parent;\n            parent._addChild(this);\n        }\n        get id() { return this._id; }\n        get framework() { return this._framework; }\n        get element() { return this._element; }\n        set element(el) { this._element = el; }\n        get isBound() { return this._isBound; }\n        set isBound(v) { this._isBound = v; }\n        get isMounted() { return this._isMounted; }\n        set isMounted(v) { this._isMounted = v; }\n        get isDestroyed() { return this._isDestroyed; }\n        set isDestroyed(v) { this._isDestroyed = v; }\n        _abortInvokerResources() {\n            for (const byKind of this._invokerResources.values()) {\n                for (const cleanup of byKind.values()) {\n                    _se(cleanup);\n                }\n            }\n            this._invokerResources.clear();\n        }\n        _cancelUserResources() {\n            this._abortInvokerResources();\n        }\n        _resolveBindingMeta(element, attributeName) {\n            const elAny = element;\n            let propName = attributeName in elAny ? attributeName : null;\n            if (!propName) {\n                const camel = attributeName.replace(/-([a-z])/g, (_, c) => c.toUpperCase());\n                propName = camel in elAny ? camel : (attributeName.toLowerCase() === 'readonly' && 'readOnly' in elAny ? 'readOnly' : null);\n            }\n            const isBooleanProp = !!(propName && typeof elAny[propName] === 'boolean');\n            const hasNonFunctionProp = !!(propName && typeof elAny[propName] !== 'function');\n            const isKnownBooleanAttr = !!ReactiveComponent._BA[attributeName.toLowerCase()];\n            return { elAny, propName, isBooleanProp, hasNonFunctionProp, isKnownBooleanAttr };\n        }\n        _applyGenericBinding(element, attributeName, value, meta) {\n            const { elAny, propName, isBooleanProp, hasNonFunctionProp, isKnownBooleanAttr } = meta;\n            if ((isBooleanProp && propName) || isKnownBooleanAttr) {\n                const boolVal = !!value;\n                if (propName && isBooleanProp)\n                    elAny[propName] = boolVal;\n                if (boolVal)\n                    element.setAttribute(attributeName, '');\n                else\n                    element.removeAttribute(attributeName);\n                return;\n            }\n            let normalized = null;\n            if (value && typeof value === 'object') {\n                const parts = [];\n                for (const k in value) {\n                    if (value[k])\n                        parts.push(k);\n                }\n                normalized = parts.length ? parts.join(' ') : null;\n            }\n            else if (value !== null && value !== undefined) {\n                normalized = String(value);\n            }\n            if (hasNonFunctionProp && propName) {\n                if (normalized !== null) {\n                    try {\n                        elAny[propName] = normalized;\n                    }\n                    catch {\n                        try {\n                            element.setAttribute(attributeName, normalized);\n                        }\n                        catch { }\n                    }\n                }\n                else {\n                    element.removeAttribute(attributeName);\n                }\n                return;\n            }\n            if (normalized !== null) {\n                const cur = element.getAttribute(attributeName);\n                if (cur !== normalized)\n                    element.setAttribute(attributeName, normalized);\n            }\n            else {\n                element.removeAttribute(attributeName);\n            }\n        }\n        _scanDirectiveAttrs(el, opts) {\n            const prefixDash = PFX + '-';\n            const prefixColon = PFX + ':';\n            const namesOut = [];\n            let hasTextOrHtml = false;\n            let forName = null;\n            const names = el.getAttributeNames();\n            for (let i = 0; i < names.length; i++) {\n                const name = names[i];\n                const isDir = name.startsWith(prefixDash) || name.startsWith(prefixColon) || name.startsWith('@');\n                if (!isDir)\n                    continue;\n                if (opts?.skipRootFor && name === attrName('for'))\n                    continue;\n                namesOut.push(name);\n                if (!hasTextOrHtml && (name === attrName('text') || name === attrName('html')))\n                    hasTextOrHtml = true;\n                if (!forName && name === attrName('for'))\n                    forName = name;\n            }\n            return { names: namesOut, hasTextOrHtml, forName };\n        }\n        setFrozen(on) {\n            if (on === this._isFrozen)\n                return;\n            this._isFrozen = on;\n            if (on) {\n                this._sealedBeforeFreeze = this._isSealed;\n                this._isSealed = true;\n                this._cancelUserResources();\n            }\n            else {\n                if (this._sealedBeforeFreeze !== null) {\n                    this._isSealed = this._sealedBeforeFreeze;\n                }\n                else {\n                    this._isSealed = false;\n                }\n                this._sealedBeforeFreeze = null;\n                try {\n                    this._scheduleRender();\n                }\n                catch { }\n            }\n        }\n        _setSealed(on) {\n            if (on === this._isSealed)\n                return;\n            this._isSealed = on;\n            if (on) {\n                this._cancelUserResources();\n            }\n        }\n        _addDirective(element, directive) {\n            const existing = this._directives.get(element) || [];\n            existing.push(directive);\n            this._directives.set(element, existing);\n        }\n        constructor(id, def, framework) {\n            this._propUpdateActive = false;\n            this._runningPropEffect = false;\n            this._element = null;\n            this._isBound = false;\n            this._isMounted = false;\n            this._isDestroyed = false;\n            this._beforeMountCalled = false;\n            this._children = [];\n            this._parent = null;\n            this._computed = {};\n            this._propEffects = {};\n            this._computedCache = new Map();\n            this._computedDeps = new Map();\n            this._computedKeyStack = [];\n            this._isInComputedEvaluation = false;\n            this._isInMethodExecution = false;\n            this._allEffects = new Set();\n            this._hasComputed = false;\n            this._directives = new Map();\n            this._cleanupFunctions = new Set();\n            this._directiveAbort = new AbortController();\n            this._invokerResources = new Map();\n            this._targetIds = new WkMap();\n            this._targetSeq = 0;\n            this._isSealed = false;\n            this._isFrozen = false;\n            this._sealedBeforeFreeze = null;\n            this._isMutationEnabled = true;\n            this._effectsToRun = new Set();\n            this._currentInvoker = null;\n            this._loopScopes = new WkMap();\n            this._expressionCache = new Map();\n            this._propertyDependencies = new Map();\n            this._activeEffect = null;\n            this._renderScheduled = false;\n            this._nextTickQueue = [];\n            this._changeFrameId = null;\n            this._renderFrameId = null;\n            this._initialClassSets = new WkMap();\n            this._rawData = {};\n            this._propParent = null;\n            this._callLifecycleHook = (hookName) => {\n                const hook = this._lifecycle[hookName];\n                if (typeof hook === 'function') {\n                    this._safeExecute(() => this._runWithGlobalInterception(hook, []));\n                }\n                if (hookName === 'mounted' && this._xInitExpr) {\n                    const expr = this._xInitExpr;\n                    if (this.isDestroyed || !this.element || !this.element.isConnected)\n                        return;\n                    const runner = () => {\n                        const trimmed = _tr(expr);\n                        const arrow = this._extractArrowFunction(trimmed);\n                        const ctx = this._createMethodContext();\n                        if (arrow) {\n                            const fn = this._compileArrowForEvent(arrow.paramsList, arrow.body, arrow.isBlock);\n                            const args = arrow.paramsList.length ? [this.element] : [];\n                            const out = fn.call(this._createContextProxy(undefined, this.element || undefined), ctx, ...args.slice(0, arrow.paramsList.length));\n                            if (typeof out === 'function')\n                                this._addCleanupFunction(out);\n                            return;\n                        }\n                        const compiled = this._createEvaluator(trimmed, trimmed.indexOf(';') !== -1);\n                        const result = compiled.call(ctx, this._createContextProxy(undefined, this.element || undefined));\n                        if (typeof result === 'function')\n                            this._addCleanupFunction(result);\n                    };\n                    this._safeExecute(() => this._runWithGlobalInterception(runner, []));\n                }\n            };\n            this._addCleanupFunction = (fn) => {\n                if (typeof fn !== 'function')\n                    return undefined;\n                const wrapped = () => {\n                    try {\n                        fn();\n                    }\n                    catch { }\n                    this._cleanupFunctions.delete(wrapped);\n                };\n                this._cleanupFunctions.add(wrapped);\n                return () => { this._cleanupFunctions.delete(wrapped); };\n            };\n            this._id = id;\n            this._framework = framework;\n            this._originalMethods = def.methods || {};\n            this._computed = this._bindComputed(def.computed || {});\n            this._propEffects = def.propEffects || {};\n            if (this._propEffects && Object.keys(this._propEffects).length) {\n                this._propEffects = this._bindPropEffects();\n            }\n            this._hasComputed = !!(def.computed && Object.keys(def.computed).length);\n            this._lifecycle = {\n                mounted: def.mounted,\n                unmounted: def.unmounted || def.destroyed,\n                updated: def.updated,\n                beforeMount: def.beforeMount,\n                beforeUnmount: def.beforeUnmount || def.beforeDestroy\n            };\n            this._rawData = this._cloneData(def.data || {});\n            this._data = this._createReactiveData(this._rawData || {});\n            this._methods = this._bindMethods();\n        }\n        _cloneData(value, seen) {\n            if (value === null || typeof value !== 'object')\n                return value;\n            const s = seen || new WeakMap();\n            if (s.has(value))\n                return s.get(value);\n            if (ARRAY_ISARRAY(value)) {\n                const arr = [];\n                s.set(value, arr);\n                for (let i = 0; i < value.length; i++)\n                    arr[i] = this._cloneData(value[i], s);\n                return arr;\n            }\n            if (value instanceof Date)\n                return new Date(value.getTime());\n            if (value instanceof RegExp)\n                return new RegExp(value.source, value.flags);\n            if (typeof Map !== 'undefined' && value instanceof Map) {\n                const m = new Map();\n                s.set(value, m);\n                value.forEach((v, k) => { m.set(this._cloneData(k, s), this._cloneData(v, s)); });\n                return m;\n            }\n            if (typeof Set !== 'undefined' && value instanceof Set) {\n                const st = new Set();\n                s.set(value, st);\n                value.forEach(v => st.add(this._cloneData(v, s)));\n                return st;\n            }\n            const proto = Object.getPrototypeOf(value);\n            if (proto === Object.prototype || proto === null) {\n                const out = Object.create(proto);\n                s.set(value, out);\n                for (const key of Object.keys(value)) {\n                    out[key] = this._cloneData(value[key], s);\n                }\n                return out;\n            }\n            return value;\n        }\n        callBeforeMount() {\n            if (!this._beforeMountCalled) {\n                this._callLifecycleHook('beforeMount');\n                this._beforeMountCalled = true;\n            }\n        }\n        _onDataChange(_property) {\n            if (!this.isBound)\n                return;\n            const self = this;\n            if (self._changeFrameId != null) {\n                _se(() => cancelAnimationFrame(self._changeFrameId));\n                self._changeFrameId = null;\n            }\n            if (this._isMutationEnabled === false)\n                return;\n            const effectsToRun = self._effectsToRun;\n            const directDeps = self._propertyDependencies.get(_property);\n            if (directDeps) {\n                for (let i = 0; i < directDeps.length; i++)\n                    effectsToRun.add(directDeps[i]);\n            }\n            if (FT_C && self._computedDeps.size) {\n                const queue = [_property];\n                const visited = new Set();\n                const affectedComputed = new Set();\n                let queueIdx = 0;\n                while (queueIdx < queue.length) {\n                    const base = queue[queueIdx++];\n                    if (visited.has(base))\n                        continue;\n                    visited.add(base);\n                    for (const [compKey, baseDeps] of self._computedDeps.entries()) {\n                        if (baseDeps.has(base) && !affectedComputed.has(compKey)) {\n                            affectedComputed.add(compKey);\n                            queue.push(compKey);\n                        }\n                    }\n                }\n                for (const compKey of affectedComputed) {\n                    const compEffects = self._propertyDependencies.get(compKey);\n                    if (compEffects) {\n                        for (let i = 0; i < compEffects.length; i++)\n                            effectsToRun.add(compEffects[i]);\n                    }\n                    self._computedCache.delete(compKey);\n                }\n            }\n            self._changeFrameId = requestAnimationFrame(() => {\n                if (FT_C)\n                    self._computedCache.clear();\n                self._changeFrameId = null;\n                if (self.isDestroyed || self._isSealed)\n                    return;\n                for (const effect of effectsToRun)\n                    self._safeExecute(effect);\n                effectsToRun.clear();\n                if (!directDeps?.length && (self._hasComputed || !XTOOL_ENABLE_STATIC_DIRECTIVES)) {\n                    self._scheduleRender();\n                }\n                self._callLifecycleHook('updated');\n            });\n        }\n        _bindMethods() {\n            return this._bindFunctionMap(this._originalMethods, 'methods');\n        }\n        _bindComputed(src) {\n            return this._bindFunctionMap(src, 'computed');\n        }\n        _bindPropEffects() {\n            return this._bindFunctionMap(this._propEffects || {}, 'prop');\n        }\n        _bindFunctionMap(src, kind) {\n            const out = {};\n            const isNative = (fn) => /\\[native code\\]/.test(String(fn));\n            const makeNoArgCtxRunner = (fn) => {\n                try {\n                    if (!isNative(fn)) {\n                        let body = String(fn).trim();\n                        if (!/^function[\\s\\(]/.test(body) && !/^[\\w\\$_][\\w\\d\\$_]*\\s*=>/.test(body) && !/^\\(.*?\\)\\s*=>/.test(body)) {\n                            body = 'function ' + body;\n                        }\n                        const compiled = new Function('ctx', `with(ctx){ const f = (${body}); return f.apply(this, []); }`);\n                        return () => { const ctx = this._createMethodContext(); return compiled.call(ctx, ctx); };\n                    }\n                }\n                catch { }\n                return () => fn.call(this._createMethodContext());\n            };\n            for (const key in (src || {})) {\n                const original = src[key];\n                if (typeof original !== 'function')\n                    continue;\n                if (kind === 'computed') {\n                    out[key] = makeNoArgCtxRunner(original);\n                }\n                else if (kind === 'methods') {\n                    out[key] = (...args) => {\n                        const prev = this._isInMethodExecution;\n                        const prevInv = this._currentInvoker;\n                        this._isInMethodExecution = true;\n                        this._currentInvoker = key;\n                        try {\n                            return this._safeExecute(() => this._runWithGlobalInterception(original, args));\n                        }\n                        finally {\n                            this._isInMethodExecution = prev;\n                            this._currentInvoker = prevInv;\n                        }\n                    };\n                }\n                else {\n                    out[key] = (newValue, oldValue) => {\n                        const prevInv = this._currentInvoker;\n                        const prevFlag = this._runningPropEffect;\n                        this._currentInvoker = `prop:${key}`;\n                        this._runningPropEffect = true;\n                        try {\n                            return this._safeExecute(() => this._runWithGlobalInterception(original, [newValue, oldValue]));\n                        }\n                        finally {\n                            this._runningPropEffect = prevFlag;\n                            this._currentInvoker = prevInv;\n                        }\n                    };\n                }\n            }\n            return out;\n        }\n        _getComputedValue(key) {\n            if (!FT_C)\n                return undefined;\n            this._trackDependency(key);\n            if (this._computedCache.has(key))\n                return this._computedCache.get(key);\n            this._isInComputedEvaluation = true;\n            this._computedKeyStack.push(key);\n            this._computedDeps.set(key, new Set());\n            try {\n                const getter = this._computed[key];\n                const value = typeof getter === 'function' ? getter() : undefined;\n                this._computedKeyStack.pop();\n                this._isInComputedEvaluation = this._computedKeyStack.length > 0;\n                this._computedCache.set(key, value);\n                return value;\n            }\n            catch (e) {\n                this._computedKeyStack.pop();\n                this._isInComputedEvaluation = this._computedKeyStack.length > 0;\n                return undefined;\n            }\n        }\n        _trackDependency(propKey) {\n            const activeEff = this._activeEffect;\n            if (!activeEff)\n                return;\n            let deps = this._propertyDependencies.get(propKey);\n            if (!deps) {\n                deps = [];\n                this._propertyDependencies.set(propKey, deps);\n            }\n            if (!deps.includes(activeEff))\n                deps.push(activeEff);\n            const stackLen = this._computedKeyStack.length;\n            if (this._isInComputedEvaluation && stackLen) {\n                const current = this._computedKeyStack[stackLen - 1];\n                let s = this._computedDeps.get(current);\n                if (!s) {\n                    s = new Set();\n                    this._computedDeps.set(current, s);\n                }\n                s.add(propKey);\n            }\n        }\n        _scheduleRender() {\n            if (this._isSealed || this._isFrozen || this._isDestroyed || this._renderScheduled)\n                return;\n            this._renderScheduled = true;\n            requestAnimationFrame(() => {\n                this._renderFrameId = null;\n                this._renderScheduled = false;\n                if (this._isDestroyed || this._isSealed) {\n                    if (this._nextTickQueue?.length)\n                        this._nextTickQueue.length = 0;\n                    return;\n                }\n                this._render();\n                if (this._nextTickQueue?.length) {\n                    const q = this._nextTickQueue.splice(0);\n                    for (const fn of q) {\n                        _se(fn);\n                    }\n                }\n            });\n        }\n        _safeExecute(fn, fallback) {\n            try {\n                return fn();\n            }\n            catch (error) {\n                console.error(error);\n                return fallback;\n            }\n        }\n        bindToElement(element) {\n            if (this._isBound)\n                return;\n            this._element = element;\n            if (!this._beforeMountCalled) {\n                this.callBeforeMount();\n            }\n            this.completeBinding();\n        }\n        getContext(includeComputed = true) {\n            return this._createMethodContext(includeComputed);\n        }\n        _applyAsyncTemplateResolved() {\n            if (!this._element)\n                return;\n            try {\n                this._parseDirectives(this._element);\n            }\n            catch { }\n            this._scheduleRender();\n        }\n        completeBinding() {\n            if (this._isBound || !this._element)\n                return;\n            if (!this._framework._getComponentByElement(this._element))\n                this._framework._registerElement(this._element, this);\n            this._isBound = true;\n            this._isMounted = true;\n            this._parseDirectives(this._element);\n            this._render();\n            this._callLifecycleHook('mounted');\n        }\n        _addChild(child) {\n            if (!this._children.includes(child)) {\n                this._children.push(child);\n            }\n        }\n        _removeChild(child) {\n            const index = this._children.indexOf(child);\n            if (index > -1) {\n                this._children.splice(index, 1);\n            }\n        }\n        _setXInitExpr(expr) { this._xInitExpr = expr || undefined; }\n        _runWithGlobalInterception(fn, args) {\n            try {\n                const src = String(fn);\n                if (!/\\[native code\\]/.test(src)) {\n                    let body = src.trim();\n                    if (!/^function[\\s\\(]/.test(body) && !/^[\\w\\$_][\\w\\d\\$_]*\\s*=>/.test(body) && !/^\\(.*?\\)\\s*=>/.test(body)) {\n                        body = 'function ' + body;\n                    }\n                    const trySrc = 'with(ctx){ const f = (' + body + '); return f.apply(thisArg, argsArray); }';\n                    const wrapper = new Function('thisArg', 'argsArray', 'ctx', trySrc);\n                    const thisArg = this._createMethodContext();\n                    return wrapper.call(thisArg, thisArg, args, this._createContextProxy(undefined, undefined));\n                }\n            }\n            catch {\n            }\n            return fn.apply(this._createMethodContext(), args);\n        }\n        destroy() {\n            const self = this;\n            if (self._isDestroyed)\n                return;\n            self._callLifecycleHook('beforeUnmount');\n            for (const child of self._children) {\n                if (!child.isDestroyed)\n                    child.destroy();\n            }\n            if (self._parent) {\n                self._parent._removeChild(self);\n            }\n            for (const [element, directives] of self._directives) {\n                for (const directive of directives) {\n                    if (directive.type === 'custom' && directive.customDirective?.unbind) {\n                        _se(() => directive.customDirective.unbind(element, self));\n                    }\n                }\n            }\n            self._directives.clear();\n            try {\n                self._directiveAbort.abort();\n            }\n            catch { }\n            self._directiveAbort = new AbortController();\n            self._abortInvokerResources();\n            self._runCleanupCallbacks();\n            self._computedCache.clear();\n            self._expressionCache.clear();\n            self._propertyDependencies.clear();\n            if (self._propParent && self._propEffect) {\n                for (const deps of self._propParent._propertyDependencies.values()) {\n                    const idx = deps.indexOf(self._propEffect);\n                    if (idx > -1)\n                        deps.splice(idx, 1);\n                }\n            }\n            if (self._element)\n                self._framework._unregisterElement(self._element);\n            self._framework._clearComponentRefs(self);\n            if (self._changeFrameId != null) {\n                _se(() => cancelAnimationFrame(self._changeFrameId));\n                self._changeFrameId = null;\n            }\n            if (self._renderFrameId != null) {\n                _se(() => cancelAnimationFrame(self._renderFrameId));\n                self._renderFrameId = null;\n            }\n            self._callLifecycleHook('unmounted');\n            self._isDestroyed = true;\n            self._isMounted = false;\n            self._isBound = false;\n            self._children = [];\n            self._parent = null;\n            self._deepReactiveCache = new WkMap;\n            self._effectsToRun.clear();\n            self._element = null;\n            quMct(() => self._framework._unregisterComponent(self._id));\n            self._data = {};\n            self._rawData = {};\n            self._methods = {};\n            self._computed = {};\n            self._propEffects = {};\n            self._activeEffect = null;\n        }\n        _initReactiveProps(expr, parent) {\n            if (!expr || !parent)\n                return;\n            this._propParent = parent;\n            let evalFn;\n            try {\n                evalFn = new Function('ctx', 'with(ctx){return (' + expr + ')}');\n            }\n            catch {\n                return;\n            }\n            const update = () => {\n                parent._activeEffect = update;\n                let obj;\n                try {\n                    const ctx = parent.getContext(true);\n                    obj = evalFn(ctx);\n                }\n                catch {\n                    obj = null;\n                }\n                parent._activeEffect = null;\n                if (obj && typeof obj === 'object') {\n                    this._data.$props = this._data.$props || {};\n                    this._propUpdateActive = true;\n                    for (const k in obj) {\n                        const v = obj[k];\n                        if (this._data[k] !== v)\n                            this._data[k] = v;\n                    }\n                    this._propUpdateActive = false;\n                }\n            };\n            this._propEffect = update;\n            update();\n        }\n        _runCleanupCallbacks() {\n            for (const fn of this._cleanupFunctions) {\n                _se(fn);\n            }\n            this._cleanupFunctions.clear();\n        }\n        _listen(element, event, handler, options) {\n            const signal = this._directiveAbort.signal;\n            if (typeof options === 'boolean') {\n                element.addEventListener(event, handler, { capture: options, signal });\n            }\n            else if (options) {\n                const merged = options.signal && options.signal !== signal\n                    ? options\n                    : { ...options, signal };\n                element.addEventListener(event, handler, merged);\n            }\n            else {\n                element.addEventListener(event, handler, { signal });\n            }\n        }\n        _targetKey(target) {\n            let id = this._targetIds.get(target);\n            if (!id) {\n                id = (++this._targetSeq).toString(36);\n                this._targetIds.set(target, id);\n            }\n            return id;\n        }\n        _parseDirectives(element) {\n            const self = this;\n            let processedElements = 0;\n            const processElement = (el, isRoot = false) => {\n                if (!isRoot && (el.hasAttribute(attrName('data')) || this._framework._getComponentByElement(el))) {\n                    return false;\n                }\n                const isComponentTag = el[STR_TAGNAME] === 'COMPONENT';\n                const { names: directiveNames, hasTextOrHtml, forName } = self._scanDirectiveAttrs(el);\n                if (directiveNames.length > 0) {\n                    processedElements++;\n                    if (forName) {\n                        self._bindDirective(el, forName, el.getAttribute(forName) || '');\n                        return false;\n                    }\n                    for (const attr of directiveNames) {\n                        self._bindDirective(el, attr, el.getAttribute(attr) || '');\n                    }\n                }\n                if (FT_TI && !hasTextOrHtml)\n                    self._bindTextInterpolationsIn(el);\n                return isRoot || !isComponentTag;\n            };\n            processElement(element, true);\n            self._walkElements(element, processElement);\n        }\n        _bindTextInterpolationsIn(el) {\n            if (!FT_EXT_DIRS)\n                return;\n            const nodes = Array.from(el.childNodes);\n            for (const node of nodes) {\n                if (node.nodeType !== Node.TEXT_NODE)\n                    continue;\n                const textNode = node;\n                const raw = textNode.nodeValue || '';\n                if (textNode.__x_ti_bound || raw.indexOf('{{') === -1)\n                    continue;\n                const segs = [];\n                let i = 0;\n                while (i < raw.length) {\n                    const ch = raw.charCodeAt(i);\n                    if (ch === 92) {\n                        let run = 0;\n                        const start = i;\n                        while (i < raw.length && raw.charCodeAt(i) === 92) {\n                            run++;\n                            i++;\n                        }\n                        if (raw.startsWith('{{', i)) {\n                            const close = raw.indexOf('}}', i + 2);\n                            if (close === -1) {\n                                segs.push({ type: 'lit', text: raw.slice(start) });\n                                break;\n                            }\n                            if (run > 1)\n                                segs.push({ type: 'lit', text: '\\\\'.repeat(run - 1) });\n                            segs.push({ type: 'lit', text: raw.slice(i, close + 2) });\n                            i = close + 2;\n                            continue;\n                        }\n                        segs.push({ type: 'lit', text: raw.slice(start, i) });\n                        continue;\n                    }\n                    if (raw.startsWith('{{', i)) {\n                        const close = raw.indexOf('}}', i + 2);\n                        if (close === -1) {\n                            segs.push({ type: 'lit', text: raw.slice(i) });\n                            break;\n                        }\n                        const expr = raw.slice(i + 2, close).trim();\n                        if (expr.length === 0)\n                            segs.push({ type: 'lit', text: '{{}}' });\n                        else\n                            segs.push({ type: 'expr', code: expr });\n                        i = close + 2;\n                        continue;\n                    }\n                    const nextEsc = raw.indexOf('\\\\', i);\n                    const nextOpen = raw.indexOf('{{', i);\n                    let end = raw.length;\n                    if (nextEsc !== -1 && nextEsc < end)\n                        end = nextEsc;\n                    if (nextOpen !== -1 && nextOpen < end)\n                        end = nextOpen;\n                    segs.push({ type: 'lit', text: raw.slice(i, end) });\n                    i = end;\n                }\n                const hasExpr = segs.some(s => s.type === 'expr');\n                if (!hasExpr) {\n                    textNode.__x_ti_bound = true;\n                    const literalOut = segs.map(s => s.text || '').join('');\n                    if (textNode.textContent !== literalOut)\n                        textNode.textContent = literalOut;\n                    continue;\n                }\n                const evaluators = [];\n                for (const s of segs)\n                    if (s.type === 'expr')\n                        evaluators.push(this._createElementEvaluator(s.code, el));\n                textNode.__x_ti_bound = true;\n                const update = () => {\n                    let out = '';\n                    let ei = 0;\n                    for (const s of segs) {\n                        if (s.type === 'lit')\n                            out += s.text;\n                        else {\n                            const v = evaluators[ei++]();\n                            out += (v == null ? '' : String(v));\n                        }\n                    }\n                    if (textNode.textContent !== out)\n                        textNode.textContent = out;\n                };\n                const dirInfo = { type: 'text-interpolation', expression: raw, update: undefined };\n                this._addDirective(el, dirInfo);\n                const effect = this._createEffect(update, dirInfo);\n                dirInfo.update = effect;\n            }\n        }\n        _walkElements(parent, processor) {\n            let child = parent.firstElementChild;\n            while (child) {\n                const next = child.nextElementSibling;\n                if (processor(child))\n                    this._walkElements(child, processor);\n                child = next;\n            }\n        }\n        _bindDirective(element, directiveName, expression) {\n            const self = this;\n            const isAtEvent = directiveName.startsWith('@');\n            const isShortBind = directiveName.startsWith(PFX + ':');\n            const type = isAtEvent ? ('on:' + directiveName.slice(1)) : directiveName.slice(PFX.length + 1);\n            if (!isAtEvent && (isShortBind || type === 'class' || type === STR_STYLE)) {\n                element.removeAttribute(directiveName);\n                return self._bindAttributeDirective(element, type, expression);\n            }\n            if (FT_EXT_DIRS && !isAtEvent && (type === 'transition' || type.startsWith('transition.'))) {\n                let modifiers;\n                if (type.startsWith('transition.')) {\n                    const modList = type.slice('transition.'.length).split('.').filter(Boolean);\n                    modifiers = modList.reduce((acc, m) => { acc[m] = true; return acc; }, {});\n                }\n                element.removeAttribute(directiveName);\n                return self._bindTransitionDirective(element, expression, undefined, modifiers);\n            }\n            if (!isAtEvent && (type === 'text' || type === 'html' || type === 'show')) {\n                return self._bindSimpleDirective(element, expression, type, directiveName);\n            }\n            if (!isAtEvent && type === 'ref') {\n                element.removeAttribute(directiveName);\n                return self._bindRefDirective(element, expression);\n            }\n            const handled = (!isAtEvent && type === 'model') ? (element.removeAttribute(directiveName), self._bindModelDirective(element, expression), true)\n                : type === 'if' ? (element.removeAttribute(directiveName), self._bindIfDirective(element, expression), true)\n                    : type === 'for' ? (element.removeAttribute(directiveName), self._bindForDirective(element, expression), true)\n                        : false;\n            if (handled)\n                return;\n            if (isAtEvent || type.indexOf(':') > -1) {\n                const [prefix, rest] = type.split(':', 2);\n                const [suffix, ...mods] = rest.split('.');\n                const modifiers = mods.reduce((acc, m) => { if (m)\n                    acc[m] = true; return acc; }, {});\n                if (!isAtEvent && element[STR_TAGNAME] === 'COMPONENT' && prefix === 'prop') {\n                    return;\n                }\n                if (prefix === 'on') {\n                    element.removeAttribute(directiveName);\n                    const customDirective = self.framework._getCustomDirective(suffix);\n                    return customDirective\n                        ? self._bindCustomDirective(element, suffix, expression, customDirective, modifiers)\n                        : self._bindEventDirective(element, suffix, expression, modifiers);\n                }\n                if (prefix === 'transition' && FT_EXT_DIRS) {\n                    element.removeAttribute(directiveName);\n                    const map = {\n                        'enter': 'enter', 'enter-from': 'enterFrom', 'enter-to': 'enterTo',\n                        'leave': 'leave', 'leave-from': 'leaveFrom', 'leave-to': 'leaveTo',\n                        'enter-start': 'enterFrom', 'enter-end': 'enterTo',\n                        'leave-start': 'leaveFrom', 'leave-end': 'leaveTo',\n                    };\n                    const part = map[suffix] || 'toggle';\n                    return self._bindTransitionDirective(element, expression, part, modifiers);\n                }\n                if (prefix === 'intersect' && FT_EXT_DIRS) {\n                    element.removeAttribute(directiveName);\n                    return self._bindIntersectDirective(element, expression, modifiers, suffix);\n                }\n                element.removeAttribute(directiveName);\n                return self._bindAttributeDirective(element, suffix, expression);\n            }\n        }\n        _bindRefDirective(element, expression) {\n            if (!FT_EXT_DIRS)\n                return;\n            const refName = _tr(expression);\n            if (!refName)\n                return;\n            const self = this;\n            self.framework._registerComponentRef(self, refName, element);\n            const dir = { type: 'ref', expression };\n            this._addDirective(element, dir);\n        }\n        _getSharedRef(refName) {\n            if (!refName || !FT_EXT_DIRS)\n                return undefined;\n            let ref = this.framework._getComponentRefs(this, refName);\n            if (!ref && this._parent) {\n                let parent = this._parent;\n                while (parent) {\n                    ref = parent.framework._getComponentRefs(parent, refName);\n                    if (ref || !parent._parent)\n                        break;\n                    parent = parent._parent;\n                }\n            }\n            if (ref) {\n                if (ref.size > 1) {\n                    const arr = [];\n                    ref.forEach((el) => arr.push(el));\n                    return arr;\n                }\n                else {\n                    return ref.values().next().value;\n                }\n            }\n        }\n        _bindIntersectDirective(element, expression, modifiers, phase) {\n            if (!FT_EXT_DIRS)\n                return;\n            const self = this;\n            const trimmed = _tr(expression);\n            const runExpr = self._compileHandler(trimmed, element, (payload) => [payload, element]);\n            const run = (payload) => { if (runExpr)\n                runExpr(payload); };\n            const once = !!modifiers['once'];\n            let rootMargin = '0px';\n            for (const m in modifiers) {\n                if (m.startsWith('rootMargin-')) {\n                    rootMargin = m.slice('rootMargin-'.length);\n                    break;\n                }\n            }\n            const onEnter = phase === 'enter' ? { cb: (entry, info) => run({ entry, ...info }), once } : undefined;\n            const onLeave = phase === 'leave' ? { cb: (entry, info) => run({ entry, ...info }), once } : undefined;\n            const unobserve = this.framework._ioObserve(element, rootMargin, onEnter, onLeave);\n            const dir = { type: 'intersect', expression };\n            this._addDirective(element, dir);\n            this._addCleanupFunction(() => { try {\n                unobserve();\n            }\n            catch { } });\n        }\n        _createEffect(updateFn, directiveRef) {\n            const effect = () => {\n                this._activeEffect = effect;\n                try {\n                    updateFn();\n                }\n                finally {\n                    this._activeEffect = null;\n                }\n            };\n            effect();\n            this._allEffects.add(effect);\n            if (XTOOL_ENABLE_STATIC_DIRECTIVES && directiveRef && directiveRef._static === undefined) {\n                let found = false;\n                for (const deps of this._propertyDependencies.values()) {\n                    if (deps.includes(effect)) {\n                        found = true;\n                        break;\n                    }\n                }\n                directiveRef._static = !found;\n            }\n            return effect;\n        }\n        _bindTransitionDirective(element, expression, part, modifiers) {\n            if (!FT_EXT_DIRS)\n                return;\n            let config = element.__x_transition || null;\n            const trimmed = _tr(expression);\n            if (trimmed) {\n                try {\n                    const evalFn = this._createElementEvaluator(trimmed, element);\n                    const val = this._safeExecute(() => evalFn());\n                    if (!config)\n                        config = {};\n                    if (val && typeof val === 'object') {\n                        for (const k in val)\n                            config[k] = val[k];\n                    }\n                    else if (typeof val === 'string') {\n                        if (part)\n                            config[part] = val;\n                        else\n                            config.toggle = val;\n                    }\n                }\n                catch { }\n            }\n            if (modifiers && (modifiers.after || modifiers.end)) {\n                const exprStr = trimmed;\n                if (exprStr) {\n                    const runExpr = this._compileHandler(exprStr, element, (payload) => [payload, element]);\n                    const call = (payload) => { if (runExpr)\n                        this._safeExecute(() => runExpr(payload)); };\n                    if (part === 'enter' || part === 'enterFrom' || part === 'enterTo')\n                        config.afterEnterRunner = call;\n                    else if (part === 'leave' || part === 'leaveFrom' || part === 'leaveTo')\n                        config.afterLeaveRunner = call;\n                    else\n                        config.afterRunner = call;\n                }\n            }\n            if (!config)\n                config = {};\n            element.__x_transition = config;\n            this._addDirective(element, { type: 'transition', expression });\n        }\n        _applyShowWithTransition(el, show, originalDisplay, onDone) {\n            if (!FT_EXT_DIRS) {\n                if (show) {\n                    if (originalDisplay)\n                        el.style.setProperty('display', originalDisplay, 'important');\n                    else\n                        el.style.removeProperty('display');\n                }\n                else {\n                    el.style.setProperty('display', STR_NONE, 'important');\n                }\n                if (onDone)\n                    onDone();\n                return;\n            }\n            const cfg = el.__x_transition;\n            const imp = 'important';\n            if (!cfg) {\n                if (show) {\n                    if (originalDisplay)\n                        el.style.setProperty('display', originalDisplay, imp);\n                    else\n                        el.style.removeProperty('display');\n                }\n                else {\n                    el.style.setProperty('display', STR_NONE, imp);\n                }\n                if (onDone)\n                    onDone();\n                return;\n            }\n            const prev = el.__x_t;\n            if (prev && typeof prev.cancel === 'function') {\n                try {\n                    prev.cancel();\n                }\n                catch { }\n            }\n            const duration = typeof cfg.duration === 'number' ? cfg.duration : 150;\n            const easing = typeof cfg.easing === 'string' ? cfg.easing : 'ease';\n            const add = (cls) => { if (!cls)\n                return; cls.split(/\\s+/).forEach(c => c && el.classList.add(c)); };\n            const rm = (cls) => { if (!cls)\n                return; cls.split(/\\s+/).forEach(c => c && el.classList.remove(c)); };\n            const effectiveMs = (fallbackMs) => {\n                try {\n                    const cs = (typeof window !== 'undefined' && window.getComputedStyle) ? window.getComputedStyle(el) : null;\n                    if (!cs)\n                        return fallbackMs;\n                    const parseTimes = (s) => {\n                        if (!s)\n                            return [];\n                        return s.split(',').map(x => x.trim()).filter(Boolean).map(x => {\n                            if (x.endsWith('ms'))\n                                return parseFloat(x);\n                            if (x.endsWith('s'))\n                                return parseFloat(x) * 1000;\n                            const n = parseFloat(x);\n                            return isNaN(n) ? 0 : n;\n                        });\n                    };\n                    const sumMax = (durations, delays) => {\n                        const n = Math.max(durations.length, delays.length);\n                        let max = 0;\n                        for (let i = 0; i < n; i++) {\n                            const d = durations[i % durations.length] || 0;\n                            const dl = delays[i % delays.length] || 0;\n                            const t = d + dl;\n                            if (t > max)\n                                max = t;\n                        }\n                        return max;\n                    };\n                    const tDur = parseTimes(cs.transitionDuration || '');\n                    const tDel = parseTimes(cs.transitionDelay || '');\n                    let maxT = sumMax(tDur, tDel);\n                    const aDur = parseTimes(cs.animationDuration || '');\n                    const aDel = parseTimes(cs.animationDelay || '');\n                    const itersRaw = (cs.animationIterationCount || '').split(',').map(s => s.trim());\n                    const iters = itersRaw.map(v => (v === 'infinite' ? 0 : (parseFloat(v) || 1)));\n                    const nA = Math.max(aDur.length, aDel.length, iters.length);\n                    let maxA = 0;\n                    for (let i = 0; i < nA; i++) {\n                        const d = aDur[i % aDur.length] || 0;\n                        const dl = aDel[i % aDel.length] || 0;\n                        const it = iters[i % iters.length] || 1;\n                        if (it === 0)\n                            continue;\n                        const t = dl + d * it;\n                        if (t > maxA)\n                            maxA = t;\n                    }\n                    const eff = Math.max(maxT, maxA);\n                    return eff > 0 ? eff : fallbackMs;\n                }\n                catch {\n                    return fallbackMs;\n                }\n            };\n            const finishers = [];\n            const addFinish = (cb) => finishers.push(cb);\n            const cleanup = () => { while (finishers.length) {\n                try {\n                    finishers.pop()();\n                }\n                catch { }\n            } };\n            const waitEnd = (fallbackMs, done) => {\n                let ended = false;\n                const off = () => {\n                    if (ended)\n                        return;\n                    ended = true;\n                    done();\n                    cleanup();\n                };\n                const onEnd = () => off();\n                el.addEventListener('transitionend', onEnd, { once: true, capture: true });\n                el.addEventListener('animationend', onEnd, { once: true, capture: true });\n                const to = setTimeout(off, fallbackMs + 50);\n                addFinish(() => {\n                    try {\n                        el.removeEventListener('transitionend', onEnd);\n                    }\n                    catch { }\n                    try {\n                        el.removeEventListener('animationend', onEnd);\n                    }\n                    catch { }\n                    clearTimeout(to);\n                });\n            };\n            const invokeAfter = (phase, msUsed) => {\n                const payload = { el, phase, config: { ...cfg, duration: msUsed ?? effectiveMs(duration), easing } };\n                try {\n                    if (phase === 'enter') {\n                        if (typeof cfg.afterEnterRunner === 'function')\n                            cfg.afterEnterRunner(payload);\n                        else if (typeof cfg.afterRunner === 'function')\n                            cfg.afterRunner(payload);\n                    }\n                    else {\n                        if (typeof cfg.afterLeaveRunner === 'function')\n                            cfg.afterLeaveRunner(payload);\n                        else if (typeof cfg.afterRunner === 'function')\n                            cfg.afterRunner(payload);\n                    }\n                }\n                catch { }\n            };\n            const startClassBased = (phase) => {\n                const enter = phase === 'enter';\n                const A = enter ? cfg.enter : cfg.leave;\n                const F = enter ? cfg.enterFrom : cfg.leaveFrom;\n                const T = enter ? cfg.enterTo : cfg.leaveTo;\n                if (enter) {\n                    if (originalDisplay)\n                        el.style.setProperty('display', originalDisplay, imp);\n                    else\n                        el.style.removeProperty('display');\n                }\n                if (!A && !F && !T)\n                    return false;\n                add(A);\n                add(F);\n                el.offsetWidth;\n                rm(F);\n                add(T);\n                const ms = effectiveMs(duration);\n                waitEnd(ms, () => {\n                    rm(A);\n                    rm(T);\n                    if (!enter)\n                        el.style.setProperty('display', STR_NONE, imp);\n                    if (onDone)\n                        onDone();\n                    invokeAfter(phase, ms);\n                });\n                el.__x_t = { cancel: () => { rm(A); rm(F); rm(T); if (!enter)\n                        el.style.setProperty('display', STR_NONE, imp); if (onDone)\n                        onDone(); } };\n                return true;\n            };\n            const startStyleFade = (phase) => {\n                const enter = phase === 'enter';\n                const prevTransition = el.style.transition;\n                const prevOpacity = el.style.opacity;\n                if (enter) {\n                    if (originalDisplay)\n                        el.style.setProperty('display', originalDisplay, imp);\n                    else\n                        el.style.removeProperty('display');\n                    el.style.setProperty('opacity', '0', imp);\n                }\n                else {\n                    el.style.setProperty('opacity', '1', imp);\n                }\n                el.offsetWidth;\n                const ms = effectiveMs(duration);\n                el.style.setProperty('transition', `opacity ${ms}ms ${easing}`, imp);\n                if (enter)\n                    el.style.setProperty('opacity', '1', imp);\n                else\n                    el.style.setProperty('opacity', '0', imp);\n                waitEnd(ms, () => {\n                    if (prevTransition)\n                        el.style.setProperty('transition', prevTransition, imp);\n                    else\n                        el.style.removeProperty('transition');\n                    if (prevOpacity)\n                        el.style.setProperty('opacity', prevOpacity, imp);\n                    else\n                        el.style.removeProperty('opacity');\n                    if (!enter)\n                        el.style.setProperty('display', STR_NONE, imp);\n                    if (onDone)\n                        onDone();\n                    invokeAfter(phase, ms);\n                });\n                el.__x_t = { cancel: () => { if (prevTransition)\n                        el.style.setProperty('transition', prevTransition, imp);\n                    else\n                        el.style.removeProperty('transition'); if (prevOpacity)\n                        el.style.setProperty('opacity', prevOpacity, imp);\n                    else\n                        el.style.removeProperty('opacity'); if (!enter)\n                        el.style.setProperty('display', STR_NONE, imp); if (onDone)\n                        onDone(); } };\n            };\n            if (typeof cfg.toggle === 'string') {\n                if (show) {\n                    if (originalDisplay)\n                        el.style.setProperty('display', originalDisplay, imp);\n                    else\n                        el.style.removeProperty('display');\n                    add(cfg.toggle);\n                    const ms = effectiveMs(duration);\n                    waitEnd(ms, () => { if (onDone)\n                        onDone(); invokeAfter('enter', ms); });\n                    el.__x_t = { cancel: () => { if (onDone)\n                            onDone(); } };\n                }\n                else {\n                    rm(cfg.toggle);\n                    const ms = effectiveMs(duration);\n                    waitEnd(ms, () => { el.style.setProperty('display', STR_NONE, imp); if (onDone)\n                        onDone(); invokeAfter('leave', ms); });\n                    el.__x_t = { cancel: () => { el.style.setProperty('display', STR_NONE, imp); if (onDone)\n                            onDone(); } };\n                }\n                return;\n            }\n            if (show) {\n                if (!startClassBased('enter'))\n                    startStyleFade('enter');\n            }\n            else {\n                if (!startClassBased('leave'))\n                    startStyleFade('leave');\n            }\n        }\n        _bindSimpleDirective(element, expression, type, directiveName) {\n            if (type === 'class' || type === STR_STYLE) {\n                return this._bindAttributeDirective(element, type, expression);\n            }\n            const evaluator = this._createElementEvaluator(expression, element);\n            let isDirty = directiveName ? element.getAttribute(directiveName) !== null : false;\n            let originalDisplay;\n            if (type === 'show') {\n                const el = element;\n                originalDisplay = el.style[STR_DISPLAY] !== STR_NONE ? el.style[STR_DISPLAY] : undefined;\n            }\n            let _prevShown = undefined;\n            const update = () => {\n                const value = evaluator();\n                const el = element;\n                if (isDirty && directiveName) {\n                    element.removeAttribute(directiveName);\n                    isDirty = false;\n                }\n                switch (type) {\n                    case 'text':\n                        el.textContent = String(value);\n                        break;\n                    case 'html':\n                        el.innerHTML = String(value || '');\n                        break;\n                    case 'show':\n                        const next = !!value;\n                        if (_prevShown === next)\n                            return;\n                        _prevShown = next;\n                        this._applyShowWithTransition(el, next, originalDisplay);\n                        break;\n                }\n            };\n            const dirInfo = { type, expression, update: undefined, originalDisplay };\n            this._addDirective(element, dirInfo);\n            const effect = this._createEffect(update, dirInfo);\n            dirInfo.update = effect;\n        }\n        _bindModelDirective(element, property) {\n            const isCheckbox = element.type === 'checkbox';\n            const isNumeric = element.type === 'number' || element.type === 'range';\n            const isMultiSelect = element.tagName === 'SELECT' && element.multiple === true;\n            if (!(property in this._data)) {\n                this._data[property] = undefined;\n            }\n            const getValueEvaluator = this._createElementEvaluator(property, element);\n            const setValueEvaluator = this._createEvaluator(`${property} = $value`, true);\n            const inferCheckboxValue = () => {\n                if (element.hasAttribute('value'))\n                    return element.value;\n                const loopScope = this._collectLoopScope(element);\n                if (loopScope) {\n                    const keys = Object.keys(loopScope);\n                    if (keys.length === 1)\n                        return loopScope[keys[0]];\n                }\n                return element.value;\n            };\n            const checkboxValue = isCheckbox ? inferCheckboxValue() : undefined;\n            const getInputValue = () => {\n                if (isCheckbox) {\n                    const currentData = getValueEvaluator();\n                    if (Array.isArray(currentData) && checkboxValue !== undefined) {\n                        return element.checked ? checkboxValue : undefined;\n                    }\n                    return element.hasAttribute('value') ? (element.checked ? element.value : undefined) : element.checked;\n                }\n                if (isMultiSelect) {\n                    const sel = element;\n                    const values = [];\n                    const opts = sel.options;\n                    for (let i = 0; i < opts.length; i++) {\n                        if (opts[i].selected)\n                            values.push(opts[i].value);\n                    }\n                    return values;\n                }\n                return isNumeric ? parseFloat(element.value) || 0 : element.value;\n            };\n            const setInputValue = (value) => {\n                if (isCheckbox) {\n                    if (Array.isArray(value)) {\n                        const member = element.hasAttribute('value') ? element.value : checkboxValue;\n                        element.checked = member != null ? value.includes(member) : false;\n                    }\n                    else {\n                        element.checked = !!value;\n                    }\n                    return;\n                }\n                if (isMultiSelect) {\n                    const sel = element;\n                    const arr = Array.isArray(value) ? value : [];\n                    const opts = sel.options;\n                    for (let i = 0; i < opts.length; i++) {\n                        opts[i].selected = arr.includes(opts[i].value);\n                    }\n                    return;\n                }\n                element.value = String(value ?? (isNumeric ? 0 : ''));\n            };\n            this._createEffect(() => setInputValue(getValueEvaluator()));\n            const ctx = this._createContextProxy(undefined, element);\n            const updateData = () => {\n                const raw = getInputValue();\n                const currentVal = this._safeExecute(() => getValueEvaluator());\n                if (isCheckbox && Array.isArray(currentVal)) {\n                    const member = element.hasAttribute('value') ? element.value : checkboxValue;\n                    if (member !== undefined) {\n                        const idx = currentVal.indexOf(member);\n                        if (element.checked) {\n                            if (idx === -1)\n                                currentVal.push(member);\n                        }\n                        else if (idx > -1) {\n                            currentVal.splice(idx, 1);\n                        }\n                    }\n                }\n                else if (isMultiSelect && Array.isArray(currentVal)) {\n                    currentVal.splice(0, currentVal.length, ...raw);\n                }\n                else {\n                    ctx.$value = raw;\n                    this._safeExecute(() => { setValueEvaluator.call(this._createMethodContext(), ctx); });\n                }\n            };\n            const t = element.type;\n            const eventType = (element[STR_TAGNAME] === 'SELECT' || t === 'checkbox' || t === 'radio' || t === 'file') ? 'change' : 'input';\n            this._listen(element, eventType, updateData);\n            this._addDirective(element, { type: 'model', property });\n        }\n        _bindIfDirective(element, expression) {\n            const self = this;\n            const placeholder = d.createComment('x-if');\n            element.parentNode?.insertBefore(placeholder, element);\n            element.__x_if_anchorParent = placeholder.parentElement || null;\n            const branches = [];\n            const makeActualElement = (el) => {\n                if (el[STR_TAGNAME] === STR_TEMPLATE) {\n                    const wrapper = d.createElement('div');\n                    wrapper.style[STR_DISPLAY] = STR_CONTENTS;\n                    wrapper.appendChild(el.content.cloneNode(true));\n                    return { el: wrapper, isTemplate: true };\n                }\n                return { el: el, isTemplate: false };\n            };\n            const first = makeActualElement(element);\n            const firstOD = (first.el.style[STR_DISPLAY] !== STR_NONE) ? first.el.style[STR_DISPLAY] : undefined;\n            const firstEval = self._createElementEvaluator(expression, element);\n            branches.push({ el: first.el, test: firstEval, isTemplate: first.isTemplate, originalDisplay: firstOD });\n            if (!first.isTemplate)\n                first.el.__x_tool_bound = true;\n            const originalNodes = [element];\n            if (FT_IFB) {\n                let sib = element.nextElementSibling;\n                while (sib) {\n                    const isElse = sib.hasAttribute(attrName('else'));\n                    const isElseIf = sib.hasAttribute(attrName('else-if'));\n                    if (!isElse && !isElseIf)\n                        break;\n                    if (sib.hasAttribute(attrName('else-if'))) {\n                        const attr = sib.getAttribute(attrName('else-if')) || '';\n                        const branch = makeActualElement(sib);\n                        const od = (branch.el.style[STR_DISPLAY] !== STR_NONE) ? branch.el.style[STR_DISPLAY] : undefined;\n                        const evalFn = self._createElementEvaluator(_tr(attr), sib);\n                        branches.push({ el: branch.el, test: evalFn, isTemplate: branch.isTemplate, originalDisplay: od });\n                        if (!branch.isTemplate)\n                            branch.el.__x_tool_bound = true;\n                    }\n                    else {\n                        const branch = makeActualElement(sib);\n                        const od = (branch.el.style[STR_DISPLAY] !== STR_NONE) ? branch.el.style[STR_DISPLAY] : undefined;\n                        branches.push({ el: branch.el, test: null, isTemplate: branch.isTemplate, originalDisplay: od });\n                        if (!branch.isTemplate)\n                            branch.el.__x_tool_bound = true;\n                    }\n                    sib.removeAttribute(attrName('else'));\n                    sib.removeAttribute(attrName('else-if'));\n                    originalNodes.push(sib);\n                    sib = sib.nextElementSibling;\n                }\n            }\n            let active = -1;\n            for (const orig of originalNodes) {\n                if (orig.parentNode)\n                    orig.parentNode.removeChild(orig);\n            }\n            const mountBranch = (idx) => {\n                if (idx < 0)\n                    return;\n                const b = branches[idx];\n                if (!b.el.__x_tool_bound) {\n                    self._parseDirectives(b.el);\n                    b.el.__x_tool_bound = true;\n                }\n                element.__x_if_current?.parentNode?.removeChild(element.__x_if_current);\n                if (!b.el.parentNode) {\n                    placeholder.parentNode?.insertBefore(b.el, placeholder.nextSibling);\n                }\n                element.__x_if_current = b.el;\n                self._applyShowWithTransition(b.el, true, b.originalDisplay);\n                try {\n                    self.framework._discoverNestedNamed(b.el, self);\n                }\n                catch { }\n                active = idx;\n            };\n            const unmountBranch = (idx, cb) => {\n                if (idx < 0) {\n                    if (cb)\n                        cb();\n                    return;\n                }\n                const b = branches[idx];\n                if (b.el.parentNode) {\n                    self._applyShowWithTransition(b.el, false, b.originalDisplay, () => {\n                        if (b.el.parentNode)\n                            b.el.parentNode.removeChild(b.el);\n                        if (cb)\n                            cb();\n                    });\n                }\n                else if (cb)\n                    cb();\n                active = -1;\n            };\n            const update = () => {\n                let next = -1;\n                for (let i = 0; i < branches[STR_LENGTH]; i++) {\n                    const b = branches[i];\n                    const pass = b.test ? !!b.test() : true;\n                    if (pass) {\n                        next = i;\n                        break;\n                    }\n                }\n                if (next === active)\n                    return;\n                if (active !== -1) {\n                    unmountBranch(active, () => mountBranch(next));\n                }\n                else {\n                    mountBranch(next);\n                }\n            };\n            const effect = self._createEffect(update);\n            self._addDirective(element, { type: 'if', expression, update: effect });\n        }\n        _bindEventDirective(element, eventName, expression, modifiers) {\n            const self = this;\n            const trimmed = _tr(expression);\n            const opts = modifiers ? {\n                once: !!modifiers.once,\n                passive: !!modifiers.passive,\n                capture: !!modifiers.capture,\n            } : undefined;\n            const onlySelf = !!modifiers?.self;\n            const shouldPrevent = !!modifiers?.prevent;\n            const shouldStop = !!modifiers?.stop;\n            const isOutside = !!modifiers?.outside;\n            const isWindow = !!modifiers?.window;\n            const deferExec = !!modifiers?.defer;\n            const keyAliasMap = { enter: ['enter'], esc: ['escape', 'esc'], escape: ['escape', 'esc'], space: [' ', 'space', 'spacebar'], tab: ['tab'], backspace: ['backspace'], delete: ['delete', 'del'], del: ['delete', 'del'], arrowup: ['arrowup', 'up'], arrowdown: ['arrowdown', 'down'], arrowleft: ['arrowleft', 'left'], arrowright: ['arrowright', 'right'], home: ['home'], end: ['end'], pageup: ['pageup'], pagedown: ['pagedown'] };\n            const comboRequirements = {\n                ctrl: !!modifiers?.ctrl,\n                alt: !!modifiers?.alt,\n                shift: !!modifiers?.shift,\n                meta: !!modifiers?.meta,\n            };\n            const buttonMap = { left: 0, middle: 1, right: 2 };\n            const touchSingle = !!modifiers?.single;\n            const touchMulti = !!modifiers?.multi;\n            const modifierKeys = modifiers ? _Okeys(modifiers) : [];\n            const allowedKeys = [];\n            for (const m of modifierKeys) {\n                const aliases = keyAliasMap[m.toLowerCase()];\n                if (aliases)\n                    allowedKeys.push(...aliases);\n            }\n            const allowedButtons = [];\n            for (const m of modifierKeys) {\n                const btn = buttonMap[m.toLowerCase()];\n                if (btn !== undefined)\n                    allowedButtons.push(btn);\n            }\n            const needKeyCheck = allowedKeys.length > 0 || comboRequirements.ctrl || comboRequirements.alt || comboRequirements.shift || comboRequirements.meta;\n            const needButtonCheck = allowedButtons.length > 0;\n            const needTouchCheck = touchSingle || touchMulti;\n            const passesFilters = (event) => {\n                const path = event.composedPath ? event.composedPath() : null;\n                const tgt = (path && path.length ? path[0] : event.target);\n                if (isOutside) {\n                    if (!tgt)\n                        return false;\n                    if (element instanceof Node && (element === tgt || element.contains(tgt)))\n                        return false;\n                }\n                if (onlySelf && event.target !== element)\n                    return false;\n                if (needTouchCheck) {\n                    if (event instanceof TouchEvent) {\n                        const tCount = event.touches.length;\n                        if (touchSingle && tCount !== 1)\n                            return false;\n                        if (touchMulti && tCount < 2)\n                            return false;\n                    }\n                    else\n                        return false;\n                }\n                if (needButtonCheck) {\n                    if (event instanceof MouseEvent) {\n                        if (!allowedButtons.includes(event.button))\n                            return false;\n                    }\n                    else\n                        return false;\n                }\n                if (needKeyCheck) {\n                    if (!(event instanceof KeyboardEvent))\n                        return false;\n                    const k = (event.key || '').toLowerCase();\n                    if (allowedKeys.length > 0 && !allowedKeys.includes(k))\n                        return false;\n                    const { ctrlKey, altKey, shiftKey, metaKey } = event;\n                    if ((comboRequirements.ctrl && !ctrlKey) || (comboRequirements.alt && !altKey) ||\n                        (comboRequirements.shift && !shiftKey) || (comboRequirements.meta && !metaKey))\n                        return false;\n                }\n                return true;\n            };\n            const runExpr = self._compileHandler(trimmed, element, (ev) => [ev, element]);\n            const createEventHandler = (event) => {\n                if (!passesFilters(event))\n                    return;\n                if (shouldPrevent)\n                    event.preventDefault();\n                if (shouldStop)\n                    event.stopPropagation();\n                if (!runExpr)\n                    return;\n                if (deferExec && typeof quMct === 'function') {\n                    const ev = event;\n                    quMct(() => self._safeExecute(() => runExpr(ev)));\n                    return;\n                }\n                self._safeExecute(() => runExpr(event));\n            };\n            const cfg = this.framework._getConfig();\n            const canDelegate = !!cfg.delegate && EV_DELEGATED.includes(eventName);\n            if (!isOutside && !isWindow && canDelegate) {\n                const remover = this.framework._registerDelegated(element, eventName, { filter: (e) => passesFilters(e), run: (e) => createEventHandler(e), once: !!modifiers?.once, comp: this });\n                this._addCleanupFunction(remover);\n            }\n            else {\n                const target = isWindow ? (typeof window !== 'undefined' ? window : element) : (isOutside ? (element?.ownerDocument || d || document) : element);\n                self._listen(target, eventName, createEventHandler, opts);\n            }\n        }\n        _createEvaluator(expression, isStatement = false) {\n            const key = `${isStatement ? 's' : 'r'}:${expression}`;\n            let fn = this._expressionCache.get(key);\n            if (!fn) {\n                try {\n                    fn = new Function('ctx', `with(ctx){${isStatement ? expression : `return (${expression})`}}`);\n                }\n                catch {\n                    expression = JSON.stringify(expression);\n                    fn = new Function('ctx', `with(ctx){${isStatement ? expression : `return (${expression})`}}`);\n                }\n                this._expressionCache.set(key, fn);\n            }\n            return fn;\n        }\n        _createElementEvaluator(expression, element) {\n            const self = this;\n            const compiled = self._createEvaluator(expression);\n            return () => this._safeExecute(() => compiled.call(self._createMethodContext(), self._createContextProxy(undefined, element)));\n        }\n        _extractArrowFunction(expression) {\n            let m = expression.match(/^\\s*\\(\\s*([^)]*?)\\s*\\)\\s*=>\\s*([\\s\\S]+)$/);\n            if (!m)\n                m = expression.match(/^\\s*([a-zA-Z_$][a-zA-Z0-9_$]*)\\s*=>\\s*([\\s\\S]+)$/);\n            if (!m)\n                return null;\n            const params = (m[1] || '')\n                .split(',')\n                .map(p => p.trim())\n                .filter(Boolean);\n            const body = _tr(m[2]);\n            const isBlock = body.startsWith('{') && body.endsWith('}');\n            const finalBody = isBlock ? body.slice(1, -1) : body;\n            return { paramsList: params, body: finalBody, isBlock };\n        }\n        _compileArrowForEvent(params, body, isBlock) {\n            const content = isBlock ? body : 'return ( ' + body + ' );';\n            return new Function('ctx', ...params, 'with(ctx){ ' + content + ' }');\n        }\n        _compileHandler(expression, element, mapArgs) {\n            const self = this;\n            const trimmed = _tr(expression);\n            if (!trimmed)\n                return null;\n            const arrow = self._extractArrowFunction(trimmed);\n            const thisCtx = self._createMethodContext();\n            if (arrow) {\n                const { paramsList, body, isBlock } = arrow;\n                const compiledArrow = self._compileArrowForEvent(paramsList, body, isBlock);\n                return (payload) => {\n                    const ctx = self._createContextProxy(payload, element);\n                    const args = mapArgs(payload);\n                    self._safeExecute(() => compiledArrow.call(thisCtx, ctx, ...args.slice(0, paramsList.length)));\n                };\n            }\n            const isStatement = trimmed.includes(';');\n            const executor = self._createEvaluator(trimmed, isStatement);\n            return (payload) => {\n                const ctx = self._createContextProxy(payload, element);\n                const result = executor.call(thisCtx, ctx);\n                if (typeof result === 'function') {\n                    try {\n                        result.call(thisCtx, payload);\n                    }\n                    catch { }\n                }\n            };\n        }\n        _assertMutable(parentKey, method) {\n            if (this._isInComputedEvaluation) {\n                throw new Error(`[x-tool] Mutation via '${String(parentKey)}.${method}()' is not allowed during computed evaluation.`);\n            }\n            if (this._isFrozen) {\n                throw new Error(`[x-tool] Mutation via '${String(parentKey)}.${method}()' is not allowed while component is frozen.`);\n            }\n        }\n        _wrapData(data, parentKey) {\n            if (!_FT_DR)\n                return data;\n            const isArr = ARRAY_ISARRAY(data);\n            const isSet = (typeof Set !== 'undefined') && (data instanceof Set);\n            const isMap = (typeof Map !== 'undefined') && (data instanceof Map);\n            if (!(Object.getPrototypeOf(data) === Object.prototype || isArr || isSet || isMap))\n                return data;\n            const self = this;\n            if (!this._deepReactiveCache)\n                this._deepReactiveCache = new WkMap();\n            if (this._deepReactiveCache.has(data))\n                return this._deepReactiveCache.get(data);\n            const makeCollectionWrapper = (name, fn, isArray) => function (...args) {\n                self._assertMutable(parentKey, name);\n                if (isArray) {\n                    const arr = this;\n                    const beforeLen = arr.length;\n                    const beforeFirst = arr[0];\n                    const beforeLast = arr[beforeLen - 1];\n                    const result = fn.apply(this, args);\n                    if (!self._isSealed && (arr.length !== beforeLen || arr[0] !== beforeFirst || arr[arr.length - 1] !== beforeLast)) {\n                        self._onDataChange(parentKey);\n                    }\n                    return result;\n                }\n                else {\n                    const before = this.size;\n                    const existed = (name === 'set') ? this.has(args[0]) : false;\n                    const result = fn.apply(this, args);\n                    if (!self._isSealed && (this.size !== before || (name === 'set' && !existed)))\n                        self._onDataChange(parentKey);\n                    return result;\n                }\n            };\n            const proxy = new Proxy(data, {\n                get: (target, p, receiver) => {\n                    const isCollection = isSet || isMap;\n                    if (isArr) {\n                        if (p === Symbol.iterator || p === 'length' || (typeof p === 'string' && /^\\d+$/.test(p))) {\n                            self._trackDependency(parentKey);\n                            if (p === Symbol.iterator)\n                                return Reflect.get(target, p, receiver);\n                        }\n                    }\n                    else if (isCollection) {\n                        if (p === 'size' || p === Symbol.iterator || p === 'keys' || p === 'values' || p === 'entries') {\n                            self._trackDependency(parentKey);\n                        }\n                    }\n                    else {\n                        self._trackDependency(parentKey);\n                    }\n                    const value = Reflect.get(target, p, receiver);\n                    if (isCollection && typeof value === 'function' && (p === Symbol.iterator || p === 'keys' || p === 'values' || p === 'entries')) {\n                        return function (...args) { return value.apply(target, args); };\n                    }\n                    if (typeof value === 'function') {\n                        if (isArr && ['push', 'pop', 'shift', 'unshift', 'splice', 'reverse', 'copyWithin', 'fill', 'sort'].includes(p)) {\n                            return makeCollectionWrapper(String(p), value, true).bind(target);\n                        }\n                        if (isSet && (p === 'add' || p === 'delete' || p === 'clear')) {\n                            return makeCollectionWrapper(String(p), value, false).bind(target);\n                        }\n                        if (isMap && (p === 'set' || p === 'delete' || p === 'clear')) {\n                            return makeCollectionWrapper(String(p), value, false).bind(target);\n                        }\n                    }\n                    return (value && typeof value === 'object') ? self._wrapData(value, parentKey) : value;\n                },\n                ownKeys: Reflect.ownKeys,\n                has: Reflect.has,\n                set: (target, p, value) => {\n                    if (self._isDestroyed || typeof p === 'symbol')\n                        return true;\n                    const key = String(parentKey) + '.' + String(p);\n                    if (self._isInComputedEvaluation)\n                        throw new Error(`[x-tool] Mutation of '${key}' is not allowed during computed evaluation.`);\n                    if (self._isFrozen)\n                        throw new Error(`[x-tool] Mutation of '${key}' is not allowed while component is frozen.`);\n                    const had = Reflect.has(target, p);\n                    const oldValue = had ? Reflect.get(target, p) : undefined;\n                    if (value && typeof value === 'object') {\n                        value = self._wrapData(value, (String(parentKey) + '.' + String(p)));\n                    }\n                    if (!had) {\n                        _se(() => Reflect.defineProperty(target, p, { configurable: true, enumerable: true, writable: true, value }));\n                        if (!Reflect.has(target, p))\n                            Reflect.set(target, p, value);\n                        self._onDataChange(parentKey);\n                        return true;\n                    }\n                    if (oldValue === value)\n                        return true;\n                    Reflect.set(target, p, value);\n                    if (!self._isSealed)\n                        self._onDataChange(parentKey);\n                    return true;\n                },\n                deleteProperty: (target, p) => {\n                    const key = String(parentKey) + (typeof p === 'symbol' ? '' : '.' + String(p));\n                    if (self._isInComputedEvaluation)\n                        throw new Error(`[x-tool] Deletion of '${key}' is not allowed during computed evaluation.`);\n                    if (self._isFrozen)\n                        throw new Error(`[x-tool] Deletion of '${key}' is not allowed while component is frozen.`);\n                    const ok = Reflect.deleteProperty(target, p);\n                    if (ok && !self._isSealed)\n                        self._onDataChange(parentKey);\n                    return ok;\n                }\n            });\n            this._deepReactiveCache.set(data, proxy);\n            return proxy;\n        }\n        _createReactiveData(data) {\n            const self = this;\n            return new Proxy(data, {\n                get: (target, property, receiver) => {\n                    const value = Reflect.get(target, property, receiver);\n                    if (property === Symbol.iterator)\n                        return value;\n                    if (typeof property !== 'symbol') {\n                        self._trackDependency(property);\n                    }\n                    if (value && typeof value === 'object' && _FT_DR) {\n                        return self._wrapData(value, property);\n                    }\n                    return value;\n                },\n                ownKeys: (target) => Reflect.ownKeys(target),\n                has: (target, key) => Reflect.has(target, key),\n                set: (target, property, value, receiver) => {\n                    if (self._isDestroyed)\n                        return true;\n                    if (self._isFrozen)\n                        return true;\n                    if (self._isInComputedEvaluation) {\n                        throw new Error(`[x-tool] Mutation of '${String(property)}' is not allowed during computed evaluation.`);\n                    }\n                    if (property === Symbol.iterator && ARRAY_ISARRAY(target))\n                        return value;\n                    const oldValue = Reflect.get(target, property);\n                    const had = Reflect.has(target, property);\n                    if (!had) {\n                        try {\n                            Reflect.defineProperty(target, property, {\n                                configurable: true,\n                                enumerable: true,\n                                writable: true,\n                                value\n                            });\n                        }\n                        catch {\n                            Reflect.set(target, property, value, receiver);\n                        }\n                    }\n                    else {\n                        Reflect.set(target, property, value, receiver);\n                    }\n                    if (!this._isSealed)\n                        this._onDataChange(property);\n                    if (this._propUpdateActive && property !== '$props') {\n                        const pc = target.$props;\n                        if (pc)\n                            pc[property] = value;\n                        const eff = this._propEffects[property];\n                        if (eff && !this._isSealed) {\n                            eff(value, oldValue);\n                        }\n                    }\n                    return true;\n                }\n            });\n        }\n        _createMethodContext(_includeComputed = true) {\n            const self = this;\n            const specials = {\n                '$log': (..._args) => { },\n                '$destroy': () => self.destroy(),\n                '$forceUpdate': () => self._scheduleRender(),\n                '$addCleanupFunction': (fn) => self._addCleanupFunction(fn),\n                '$nextTick': (cb) => {\n                    if (cb) {\n                        self._nextTickQueue.push(cb);\n                        if (!self._renderScheduled)\n                            quMct(() => {\n                                if (!self._renderScheduled && self._nextTickQueue.length) {\n                                    const q = self._nextTickQueue.splice(0, self._nextTickQueue.length);\n                                    for (const fn of q) {\n                                        self._safeExecute(() => fn());\n                                    }\n                                }\n                            });\n                        return;\n                    }\n                    return new Promise(resolve => {\n                        self._nextTickQueue.push(() => resolve());\n                        if (!self._renderScheduled)\n                            quMct(() => {\n                                if (!self._renderScheduled && self._nextTickQueue.length) {\n                                    const q = self._nextTickQueue.splice(0, self._nextTickQueue.length);\n                                    for (const fn of q) {\n                                        self._safeExecute(() => fn());\n                                    }\n                                }\n                            });\n                    });\n                },\n                '$el': self._element,\n                '$id': self._id,\n                ...(FT_EXT_DIRS ? {\n                    '$refs': new Proxy({}, {\n                        get: (_t, refName) => {\n                            if (!refName)\n                                return null;\n                            return self._getSharedRef(refName);\n                        }\n                    }),\n                    '$ref': (refName, value) => {\n                        if (value === undefined)\n                            return self._getSharedRef(refName);\n                        self._framework._registerComponentRef(self, refName, value);\n                    }\n                } : {}),\n                '$isMounted': self._isMounted,\n                '$isDestroyed': self._isDestroyed,\n                '$isSealed': self._isSealed,\n                '$isFrozen': self._isFrozen,\n                '$parent': self._parent,\n                '$children': self._children,\n                '$seal': (on = true) => { self._setSealed(!!on); },\n                '$mutate': (fn) => {\n                    const prevMethod = self._isInMethodExecution;\n                    self._isMutationEnabled = false;\n                    if (self._isInComputedEvaluation) {\n                        throw new Error('[x-tool] $mutate cannot be used inside computed evaluation; computed getters must be pure.');\n                    }\n                    self._isInMethodExecution = false;\n                    try {\n                        return typeof fn === 'function' ? fn() : undefined;\n                    }\n                    finally {\n                        self._isInMethodExecution = prevMethod;\n                        self._isMutationEnabled = true;\n                        self._scheduleRender();\n                    }\n                }\n            };\n            let data = self._data;\n            if (self._isInComputedEvaluation) {\n                data = (self._rawData);\n            }\n            return new Proxy(data, {\n                get: (target, propStr) => {\n                    if (propStr in target) {\n                        self._trackDependency(propStr);\n                        const v = target[propStr];\n                        return v;\n                    }\n                    if (FT_C && (propStr in self._computed)) {\n                        return self._getComputedValue(propStr);\n                    }\n                    if (propStr in specials)\n                        return specials[propStr];\n                    return self._methods[propStr];\n                },\n                set: (_target, propStr, value) => {\n                    if (self._isInComputedEvaluation) {\n                        throw new Error(`[x-tool] Mutation of '${String(propStr)}' is not allowed during computed evaluation.`);\n                    }\n                    if (self._isFrozen) {\n                        throw new Error(`[x-tool] Mutation of '${String(propStr)}' is not allowed while component is frozen.`);\n                    }\n                    self._data[propStr] = value;\n                    return true;\n                }\n            });\n        }\n        _createContextProxy(event, targetElement) {\n            const component = this;\n            const mergedScope = targetElement ? this._collectLoopScope(targetElement) : null;\n            const gWindow = (typeof window !== 'undefined' ? window : undefined);\n            const gDocument = (typeof document !== 'undefined' ? document : undefined);\n            const cfg = this.framework._getConfig();\n            const sandbox = !!cfg.sandboxExpressions;\n            const allow = new Set((cfg.allowGlobals || []).map(s => String(s)));\n            const ensureInvoker = () => this._currentInvoker || '__anonymous__';\n            const registerResource = (kind, setup) => {\n                const inv = ensureInvoker();\n                let byKind = this._invokerResources.get(inv);\n                if (!byKind) {\n                    byKind = new Map();\n                    this._invokerResources.set(inv, byKind);\n                }\n                const prev = byKind.get(kind);\n                if (prev) {\n                    try {\n                        prev();\n                    }\n                    catch { }\n                    byKind.delete(kind);\n                }\n                const cleanup = setup();\n                if (typeof cleanup === 'function') {\n                    const wrapped = () => {\n                        try {\n                            cleanup();\n                        }\n                        finally {\n                            byKind?.delete(kind);\n                        }\n                    };\n                    byKind.set(kind, wrapped);\n                    this._addCleanupFunction(wrapped);\n                }\n            };\n            const wrapTarget = (target) => {\n                if (!target || typeof target.addEventListener !== 'function')\n                    return target;\n                return new Proxy(target, {\n                    get: (obj, prop) => {\n                        if (prop === 'addEventListener') {\n                            return (eventName, handler, options) => {\n                                if (this._isSealed || this._isFrozen)\n                                    return;\n                                obj.addEventListener(eventName, handler, options);\n                                const optSig = typeof options === 'boolean' ? options : options?.capture ? '1' : '0';\n                                const key = 'listener:' + this._targetKey(obj) + ':' + eventName + ':' + optSig;\n                                registerResource(key, () => () => {\n                                    try {\n                                        obj.removeEventListener(eventName, handler, options);\n                                    }\n                                    catch { }\n                                });\n                            };\n                        }\n                        if (prop === 'removeEventListener') {\n                            return (eventName, handler, options) => {\n                                try {\n                                    obj.removeEventListener(eventName, handler, options);\n                                }\n                                catch { }\n                            };\n                        }\n                        if (prop === 'querySelector') {\n                            return (sel) => wrapTarget(obj.querySelector(sel));\n                        }\n                        if (prop === 'querySelectorAll') {\n                            return (sel) => Array.from(obj.querySelectorAll(sel)).map(wrapTarget);\n                        }\n                        if (prop === 'getElementById') {\n                            return (id) => wrapTarget(obj.getElementById(id));\n                        }\n                        if (prop === 'document') {\n                            const doc = obj.document;\n                            return wrapTarget(doc) || doc;\n                        }\n                        if (prop === 'defaultView') {\n                            const win = obj.defaultView;\n                            return wrapTarget(win) || win;\n                        }\n                        if (prop === 'body') {\n                            const body = obj.body;\n                            return wrapTarget(body) || body;\n                        }\n                        const value = obj[prop];\n                        if (typeof value === 'function') {\n                            try {\n                                return value.bind(obj);\n                            }\n                            catch {\n                                return value;\n                            }\n                        }\n                        return value;\n                    }\n                });\n            };\n            const ctxSetTimeout = (fn, ms, ...args) => {\n                if (this._isSealed || this._isFrozen || this._isDestroyed)\n                    return undefined;\n                const id = gWindow?.setTimeout?.(fn, ms, ...args);\n                if (id != null)\n                    registerResource('timeout', () => () => { try {\n                        gWindow?.clearTimeout?.(id);\n                    }\n                    catch { } });\n                return id;\n            };\n            const ctxSetInterval = (fn, ms, ...args) => {\n                if (this._isSealed || this._isFrozen)\n                    return undefined;\n                const id = gWindow?.setInterval?.(fn, ms, ...args);\n                if (id != null)\n                    registerResource('interval', () => () => { try {\n                        gWindow?.clearInterval?.(id);\n                    }\n                    catch { } });\n                return id;\n            };\n            const ctxRequestAnimationFrame = (cb) => {\n                if (this._isSealed || this._isFrozen)\n                    return undefined;\n                const id = gWindow?.requestAnimationFrame?.(cb);\n                if (id != null)\n                    registerResource('raf', () => () => { try {\n                        gWindow?.cancelAnimationFrame?.(id);\n                    }\n                    catch { } });\n                return id;\n            };\n            const wrapObserverCtor = (Orig, kind) => {\n                if (!Orig)\n                    return undefined;\n                return function (...observerArgs) {\n                    if (component._isSealed || component._isFrozen)\n                        return { observe() { }, disconnect() { }, unobserve() { } };\n                    const inst = new Orig(...observerArgs);\n                    registerResource('observer:' + kind, () => () => { try {\n                        inst.disconnect();\n                    }\n                    catch { } });\n                    return inst;\n                };\n            };\n            const specials = {\n                '$target': targetElement || null,\n                '$event': event || null,\n                ...(FT_EXT_DIRS ? {\n                    '$refs': new Proxy({}, {\n                        get: (_t, refName) => {\n                            if (!refName)\n                                return null;\n                            return component._getSharedRef(refName);\n                        }\n                    }),\n                    '$ref': (refName, value) => {\n                        if (value === undefined)\n                            return component._getSharedRef(refName);\n                        component._framework._registerComponentRef(component, refName, value);\n                    }\n                } : {}),\n                ...(FT_RT && this.framework._routerEnabled() ? {\n                    'location': new Proxy(gWindow?.location || location, {\n                        get: (t, p) => t[p],\n                        set: (_t, p, v) => {\n                            const key = String(p);\n                            if (key === 'href') {\n                                try {\n                                    this.framework._navigate(String(v), true, 'program');\n                                }\n                                catch {\n                                    location.href = String(v);\n                                }\n                                return true;\n                            }\n                            try {\n                                location[p] = v;\n                            }\n                            catch { }\n                            return true;\n                        }\n                    })\n                } : {}),\n                ...(sandbox && !allow.has('setTimeout') ? {} : { 'setTimeout': ctxSetTimeout }),\n                ...(sandbox && !allow.has('clearTimeout') ? {} : { 'clearTimeout': (id) => { try {\n                        gWindow?.clearTimeout?.(id);\n                    }\n                    catch { } } }),\n                ...(sandbox && !allow.has('setInterval') ? {} : { 'setInterval': ctxSetInterval }),\n                ...(sandbox && !allow.has('clearInterval') ? {} : { 'clearInterval': (id) => { try {\n                        gWindow?.clearInterval?.(id);\n                    }\n                    catch { } } }),\n                ...(sandbox && !allow.has('requestAnimationFrame') ? {} : { 'requestAnimationFrame': ctxRequestAnimationFrame }),\n                ...(sandbox && !allow.has('cancelAnimationFrame') ? {} : { 'cancelAnimationFrame': (id) => { try {\n                        gWindow?.cancelAnimationFrame?.(id);\n                    }\n                    catch { } } }),\n                ...(sandbox && !allow.has('MutationObserver') ? {} : { 'MutationObserver': wrapObserverCtor(gWindow?.MutationObserver, 'mutation') }),\n                ...(sandbox && !allow.has('ResizeObserver') ? {} : { 'ResizeObserver': wrapObserverCtor(gWindow?.ResizeObserver, 'resize') }),\n                ...(sandbox && !allow.has('IntersectionObserver') ? {} : { 'IntersectionObserver': wrapObserverCtor(gWindow?.IntersectionObserver, 'intersection') }),\n                ...(sandbox && !allow.has('window') ? {} : { 'window': wrapTarget(gWindow) }),\n                ...(sandbox && !allow.has('document') ? {} : { 'document': wrapTarget(gDocument) })\n            };\n            return new Proxy({}, {\n                get: (_t, propStr) => {\n                    if (mergedScope && propStr in mergedScope)\n                        return mergedScope[propStr];\n                    if (propStr in component._data)\n                        return component._data[propStr];\n                    if (propStr in component._computed)\n                        return component._getComputedValue(propStr);\n                    if (propStr in component._methods)\n                        return component._methods[propStr];\n                    if (propStr in specials)\n                        return specials[propStr];\n                    return undefined;\n                },\n                set: (_t, propStr, value) => {\n                    if (mergedScope) {\n                        let s = mergedScope;\n                        while (s) {\n                            if (Object.prototype.hasOwnProperty.call(s, propStr)) {\n                                s[propStr] = value;\n                                return true;\n                            }\n                            s = Object.getPrototypeOf(s);\n                        }\n                    }\n                    component._data[propStr] = value;\n                    return true;\n                },\n                has: (_t, propStr) => !!(mergedScope && propStr in mergedScope) ||\n                    propStr in component._data ||\n                    propStr in component._computed ||\n                    propStr in component._methods ||\n                    propStr in specials\n            });\n        }\n        _bindCustomDirective(element, _name, expression, directive, modifiers) {\n            const self = this;\n            const evaluator = self._createElementEvaluator(expression, element);\n            const directiveInfo = { type: 'custom', expression, customDirective: directive };\n            if (directive.bind) {\n                self._safeExecute(() => directive.bind(element, evaluator(), expression, self, modifiers, evaluator));\n            }\n            const update = () => {\n                if (directive.update)\n                    self._safeExecute(() => directive.update(element, evaluator(), expression, self, modifiers, evaluator));\n            };\n            const effect = self._createEffect(update);\n            directiveInfo.update = effect;\n            self._addDirective(element, directiveInfo);\n        }\n        _bindAttributeDirective(element, attributeName, expression) {\n            const self = this;\n            const evaluator = self._createElementEvaluator(expression, element);\n            const isSvg = element.namespaceURI === 'http://www.w3.org/2000/svg';\n            if (attributeName === 'class') {\n                const el = element;\n                if (!self._initialClassSets.get(el)) {\n                    const baseSet = new Set();\n                    const oc = isSvg ? (element.getAttribute('class') || '') : (element.className || '');\n                    if (oc)\n                        for (const cls of oc.split(/\\s+/)) {\n                            if (cls)\n                                baseSet.add(cls);\n                        }\n                    self._initialClassSets.set(el, baseSet);\n                }\n            }\n            const meta = self._resolveBindingMeta(element, attributeName);\n            const update = () => {\n                const value = evaluator();\n                if (attributeName === 'class') {\n                    const base = self._initialClassSets.get(element);\n                    if (typeof value === 'string') {\n                        const finalCls = base && base.size ? [...base].join(' ') + (value ? ' ' + value : '') : value || '';\n                        if (isSvg) {\n                            if (finalCls)\n                                element.setAttribute('class', finalCls);\n                            else\n                                element.removeAttribute('class');\n                        }\n                        else {\n                            element.className = finalCls;\n                        }\n                    }\n                    else if (ARRAY_ISARRAY(value)) {\n                        const tokens = value.filter(Boolean);\n                        const finalList = base && base.size ? [...base, ...tokens] : tokens;\n                        const finalStr = finalList.join(' ');\n                        if (isSvg) {\n                            if (finalStr)\n                                element.setAttribute('class', finalStr);\n                            else\n                                element.removeAttribute('class');\n                        }\n                        else {\n                            element.className = finalStr;\n                        }\n                    }\n                    else if (value && typeof value === 'object') {\n                        if (base && base.size) {\n                            const baseStr = [...base].join(' ');\n                            if (isSvg) {\n                                if (baseStr)\n                                    element.setAttribute('class', baseStr);\n                                else\n                                    element.removeAttribute('class');\n                            }\n                            else {\n                                element.className = baseStr;\n                            }\n                        }\n                        const elAny = element;\n                        for (const raw in value) {\n                            const on = !!value[raw];\n                            if (!raw)\n                                continue;\n                            const tokens = raw.split(/\\s+/);\n                            for (let i = 0; i < tokens.length; i++) {\n                                const tk = tokens[i];\n                                if (!tk)\n                                    continue;\n                                elAny.classList?.toggle(tk, on);\n                            }\n                        }\n                    }\n                    else if (value == null && base && base.size) {\n                        const baseStr = [...base].join(' ');\n                        if (isSvg) {\n                            if (baseStr)\n                                element.setAttribute('class', baseStr);\n                            else\n                                element.removeAttribute('class');\n                        }\n                        else {\n                            element.className = baseStr;\n                        }\n                    }\n                    else if (value == null) {\n                        element.removeAttribute('class');\n                    }\n                    return;\n                }\n                if (attributeName === STR_STYLE) {\n                    const el = element;\n                    if (typeof value === 'string') {\n                        el.style.cssText = value;\n                        return;\n                    }\n                    if (value && typeof value === 'object') {\n                        for (const k in value) {\n                            const v = value[k];\n                            const cssProp = k.startsWith('--') ? k : k.replace(/[A-Z]/g, m => '-' + m.toLowerCase());\n                            if (v != null)\n                                el.style.setProperty(cssProp, String(v));\n                            else\n                                el.style.removeProperty(cssProp);\n                        }\n                        return;\n                    }\n                    if (value == null)\n                        el.removeAttribute('style');\n                    return;\n                }\n                self._applyGenericBinding(element, attributeName, value, meta);\n            };\n            const effect = self._createEffect(update);\n            self._addDirective(element, { type: 'bind', expression, update: effect });\n        }\n        _collectLoopScope(el) {\n            if (!el)\n                return null;\n            if (!el.parentElement) {\n                const cur = el.__x_if_current;\n                if (cur && cur.parentElement) {\n                    el = cur;\n                }\n                else {\n                    const anchorParent = el.__x_if_anchorParent;\n                    if (anchorParent)\n                        el = anchorParent;\n                }\n            }\n            let node = el;\n            while (node) {\n                const s = node.__x_scope;\n                if (s)\n                    return s;\n                node = node.parentElement;\n            }\n            const merged = {};\n            node = el;\n            while (node) {\n                const scope = this._loopScopes.get(node);\n                if (scope)\n                    Object.assign(merged, scope);\n                if (node === this.element)\n                    break;\n                node = node.parentElement;\n            }\n            return _Okeys(merged).length ? merged : null;\n        }\n        _updateElementDirectives(root, force) {\n            if (!FT_EXT_DIRS)\n                return;\n            for (const [element, directives] of this._directives) {\n                for (const directive of directives) {\n                    if ((root === element || (element instanceof Element && root.contains(element))) && directive.update) {\n                        if (XTOOL_ENABLE_STATIC_DIRECTIVES && directive._static && !force)\n                            continue;\n                        directive.update();\n                    }\n                }\n            }\n        }\n        _updateElementDirectivesForVar(root, varName) {\n            const re = new RegExp('(^|[^$\\\\w])' + varName.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&') + '([^$\\\\w]|$)');\n            for (const [element, directives] of this._directives) {\n                if (!(root === element || (element instanceof Element && root.contains(element))))\n                    continue;\n                for (const directive of directives) {\n                    if (!directive.update)\n                        continue;\n                    const expr = directive.expression || '';\n                    if (re.test(expr)) {\n                        directive.update();\n                    }\n                }\n            }\n        }\n        _cleanupElementSubtree(root) {\n            if (!FT_EXT_DIRS)\n                return;\n            const toDelete = [];\n            for (const [element, directives] of this._directives) {\n                if (root === element || (element instanceof Element && root.contains(element))) {\n                    for (const directive of directives) {\n                        if (directive.type === 'custom' && directive.customDirective?.unbind) {\n                            try {\n                                directive.customDirective.unbind(element, this);\n                            }\n                            catch { }\n                        }\n                    }\n                    toDelete.push(element);\n                }\n            }\n            if (toDelete.length) {\n                for (const el of toDelete)\n                    this._directives.delete(el);\n            }\n        }\n        _bindForDirective(element, expression) {\n            if (!FT_EXT_DIRS)\n                return;\n            const self = this;\n            const match = expression.trim().match(/^(?:\\(\\s*([^,\\s]+)\\s*(?:,\\s*([^\\)]+))?\\s*\\)|([^,\\s]+))\\s+(in|of)\\s+(.+)$/);\n            if (!match) {\n                return;\n            }\n            const itemVar = match[1] || match[3];\n            const indexVar = match[2];\n            const listCode = match[5];\n            const keyAttrName = attrName('key');\n            const keyExpr = element.getAttribute(keyAttrName) || null;\n            if (keyExpr)\n                element.removeAttribute(keyAttrName);\n            const placeholder = d.createComment('x-for');\n            element.parentNode?.insertBefore(placeholder, element);\n            let templateToClone;\n            if (element[STR_TAGNAME] === STR_TEMPLATE) {\n                templateToClone = d.createElement('div');\n                templateToClone.style[STR_DISPLAY] = STR_CONTENTS;\n                templateToClone.appendChild(element.content.cloneNode(true));\n                element.parentNode?.removeChild(element);\n            }\n            else {\n                templateToClone = element;\n                element.parentNode?.removeChild(element);\n            }\n            const contextAnchor = placeholder.parentElement || self.element;\n            const listEval = self._createElementEvaluator(listCode.trim(), contextAnchor);\n            const keyEval = keyExpr ? self._createEvaluator(keyExpr) : null;\n            const BP_FOR = attrName('for');\n            const BP_KEY = attrName('key');\n            const BP_TEXT = attrName('text');\n            const BP_HTML = attrName('html');\n            const BP_DATA = attrName('data');\n            const buildBlueprint = (root) => {\n                const bp = [];\n                const walk = (el, path, isRootEl) => {\n                    if (!isRootEl && el.hasAttribute(BP_DATA))\n                        return;\n                    const isComponentTag = el[STR_TAGNAME] === 'COMPONENT';\n                    const scan = self._scanDirectiveAttrs(el, { skipRootFor: isRootEl });\n                    const dnames = scan.names.filter(n => n !== BP_KEY && (!isRootEl || n !== BP_FOR));\n                    const hasTextOrHtml = scan.names.includes(BP_TEXT) || scan.names.includes(BP_HTML);\n                    const forName = scan.forName;\n                    if (dnames.length) {\n                        if (forName) {\n                            bp.push({ path, directiveNames: [forName], hasTextOrHtml: hasTextOrHtml, forName });\n                            return;\n                        }\n                        bp.push({ path, directiveNames: dnames, hasTextOrHtml });\n                    }\n                    else {\n                        if (FT_TI && !hasTextOrHtml) {\n                            bp.push({ path, directiveNames: [], hasTextOrHtml });\n                        }\n                    }\n                    if (isComponentTag)\n                        return;\n                    let idx = 0;\n                    let child = el.firstElementChild;\n                    while (child) {\n                        const next = child.nextElementSibling;\n                        walk(child, path.concat(idx), false);\n                        idx++;\n                        child = next;\n                    }\n                };\n                walk(root, [], true);\n                return bp;\n            };\n            const hydrateFromBlueprint = (cloneRoot, bp) => {\n                for (let i = 0; i < bp.length; i++) {\n                    const instr = bp[i];\n                    const target = this._resolveNodeByPath(cloneRoot, instr.path);\n                    if (instr.forName) {\n                        const expr = target.getAttribute(instr.forName) || '';\n                        self._bindDirective(target, instr.forName, expr);\n                        continue;\n                    }\n                    for (let j = 0; j < instr.directiveNames.length; j++) {\n                        const dn = instr.directiveNames[j];\n                        const expr = target.getAttribute(dn) || '';\n                        if (dn === BP_KEY)\n                            continue;\n                        self._bindDirective(target, dn, expr);\n                    }\n                    if (FT_TI && !instr.hasTextOrHtml)\n                        self._bindTextInterpolationsIn(target);\n                }\n            };\n            const blueprint = buildBlueprint(templateToClone);\n            const instances = [];\n            const createScope = (item, idxOrKey, existing) => {\n                const scope = existing || {};\n                scope[itemVar] = item;\n                if (indexVar)\n                    scope[indexVar] = idxOrKey;\n                return scope;\n            };\n            const objIds = new WeakMap();\n            let objSeq = 0;\n            const extractId = (o) => {\n                if (!o || typeof o !== 'object')\n                    return null;\n                const v = o.id ?? o._id ?? o.key;\n                if (v == null)\n                    return null;\n                const t = typeof v;\n                return (t === 'string' || t === 'number') ? ('id:' + String(v)) : null;\n            };\n            const keyFor = (item) => {\n                if (item && typeof item === 'object') {\n                    const explicit = extractId(item);\n                    if (explicit)\n                        return explicit;\n                    let id = objIds.get(item);\n                    if (!id) {\n                        id = 'o#' + (++objSeq);\n                        objIds.set(item, id);\n                    }\n                    return id;\n                }\n                return 'p#' + (typeof item) + ':' + String(item);\n            };\n            const evalKeyExpr = (item, idxOrKey) => {\n                if (!keyEval)\n                    return null;\n                try {\n                    const base = self._createContextProxy(undefined, contextAnchor);\n                    const ctx = Object.create(base);\n                    ctx[itemVar] = item;\n                    if (indexVar)\n                        ctx[indexVar] = idxOrKey;\n                    const v = keyEval.call(self._createMethodContext(), ctx);\n                    const t = typeof v;\n                    return (t === 'string' || t === 'number') ? v : (v != null ? String(v) : null);\n                }\n                catch {\n                    return null;\n                }\n            };\n            const update = () => {\n                const norm = self._safeExecute(() => {\n                    const result = listEval();\n                    if (_AisArr(result))\n                        return { list: result, keys: null, src: result };\n                    const tag = result && Object.prototype.toString.call(result);\n                    const isMap = typeof Map !== 'undefined' && (result instanceof Map || tag === '[object Map]' || (result && typeof result.get === 'function' && typeof result.set === 'function' && typeof result.keys === 'function'));\n                    if (isMap) {\n                        return { list: _Afrom(result.values()), keys: _Afrom(result.keys()), src: result };\n                    }\n                    const isSet = typeof Set !== 'undefined' && (result instanceof Set || tag === '[object Set]' || (result && typeof result.add === 'function' && typeof result.has === 'function' && typeof result.values === 'function'));\n                    if (isSet) {\n                        return { list: _Afrom(result.values()), keys: null, src: result };\n                    }\n                    if (result && typeof result[Symbol.iterator] === 'function') {\n                        return { list: _Afrom(result), keys: null, src: result };\n                    }\n                    if (result && typeof result === 'object') {\n                        const keys = Object.keys(result);\n                        const list = keys.map(k => result[k]);\n                        return { list, keys, src: result };\n                    }\n                    return { list: [], keys: null, src: null };\n                }, { list: [], keys: null, src: null });\n                const list = norm.list;\n                const keysArr = norm.keys;\n                const oldByObjKey = new Map();\n                const oldPrimQueues = new Map();\n                for (let i = 0; i < instances.length; i++) {\n                    const n = instances[i];\n                    const k = n.__x_for_key;\n                    const ps = n.__x_primSig;\n                    if (ps) {\n                        let q = oldPrimQueues.get(ps);\n                        if (!q) {\n                            q = [];\n                            oldPrimQueues.set(ps, q);\n                        }\n                        q.push(n);\n                    }\n                    else if (k) {\n                        oldByObjKey.set(k, n);\n                    }\n                }\n                const newNodes = new Array(list.length);\n                const parent = placeholder.parentNode;\n                for (let i = 0; i < list.length; i++) {\n                    const item = list[i];\n                    const idxOrKey = keysArr ? keysArr[i] : i;\n                    let node;\n                    let nodeKey;\n                    const explicitKey = keyEval ? evalKeyExpr(item, idxOrKey) : null;\n                    if (explicitKey != null) {\n                        nodeKey = 'k:' + String(explicitKey);\n                        const prev = oldByObjKey.get(nodeKey);\n                        if (prev) {\n                            node = prev;\n                            oldByObjKey.delete(nodeKey);\n                        }\n                    }\n                    if (!node) {\n                        const k = keyFor(item);\n                        if (k && k.startsWith('o#') || (k && k.startsWith('id:'))) {\n                            nodeKey = k;\n                            const prev = oldByObjKey.get(k);\n                            if (prev) {\n                                node = prev;\n                                oldByObjKey.delete(k);\n                            }\n                        }\n                        else if (k && k.startsWith('p#')) {\n                            const ps = k;\n                            const q = oldPrimQueues.get(ps);\n                            if (q && q.length) {\n                                node = q.shift();\n                            }\n                            if (node) {\n                                nodeKey = node.__x_for_key;\n                            }\n                            if (node) {\n                                node.__x_primSig = ps;\n                            }\n                        }\n                    }\n                    if (!node) {\n                        const clone = templateToClone.cloneNode(true);\n                        clone.removeAttribute('x-for');\n                        if (keyExpr)\n                            clone.removeAttribute(keyAttrName);\n                        const initScope = createScope(item, idxOrKey, {});\n                        clone.__x_scope = initScope;\n                        clone.__x_itemRef = item;\n                        if (indexVar)\n                            clone.__x_idxRef = idxOrKey;\n                        self._loopScopes.set(clone, initScope);\n                        try {\n                            hydrateFromBlueprint(clone, blueprint);\n                        }\n                        catch { }\n                        try {\n                            self.framework._discoverNestedNamed(clone, self);\n                        }\n                        catch { }\n                        node = clone;\n                        node.__x_for_key = (nodeKey !== undefined) ? nodeKey : ('n#' + (++objSeq));\n                    }\n                    else {\n                        const existingScope = node.__x_scope;\n                        const prevIdxRef = node.__x_idxRef;\n                        const prevItemRef = node.__x_itemRef;\n                        const scope = createScope(item, idxOrKey, existingScope);\n                        node.__x_scope = scope;\n                        self._loopScopes.set(node, scope);\n                        let needsUpdate = false;\n                        if (prevItemRef !== item) {\n                            needsUpdate = true;\n                            node.__x_itemRef = item;\n                        }\n                        const indexChanged = !!indexVar && prevIdxRef !== idxOrKey;\n                        if (indexChanged) {\n                            needsUpdate = true;\n                            node.__x_idxRef = idxOrKey;\n                        }\n                        if (needsUpdate) {\n                            if (indexChanged && indexVar)\n                                self._updateElementDirectivesForVar(node, indexVar);\n                            else\n                                self._updateElementDirectives(node);\n                        }\n                    }\n                    if (nodeKey)\n                        node.__x_for_key = nodeKey;\n                    const sig = (!keyExpr && !(item && typeof item === 'object')) ? ('p#' + (typeof item) + ':' + String(item)) : undefined;\n                    node.__x_primSig = sig;\n                    newNodes[i] = node;\n                }\n                for (const [, node] of oldByObjKey) {\n                    if (node && node.parentNode) {\n                        self._cleanupElementSubtree(node);\n                        node.parentNode.removeChild(node);\n                    }\n                }\n                for (const [, queue] of oldPrimQueues) {\n                    for (const node of queue) {\n                        if (node && node.parentNode) {\n                            self._cleanupElementSubtree(node);\n                            node.parentNode.removeChild(node);\n                        }\n                    }\n                }\n                if (parent) {\n                    const oldIndexMap = new Map();\n                    for (let i = 0; i < instances.length; i++) {\n                        const k = instances[i].__x_for_key;\n                        if (k !== undefined)\n                            oldIndexMap.set(k, i);\n                    }\n                    const seq = new Array(newNodes.length);\n                    for (let i = 0; i < newNodes.length; i++) {\n                        const k = newNodes[i].__x_for_key;\n                        const oldIdx = oldIndexMap.has(k) ? oldIndexMap.get(k) : -1;\n                        seq[i] = oldIdx;\n                    }\n                    const { lisMask: lis } = this._computeLISMask(seq);\n                    const tailAnchor = instances.length ? (instances[instances.length - 1].nextSibling) : placeholder.nextSibling;\n                    let anchor = null;\n                    for (let i = newNodes.length - 1; i >= 0; i--) {\n                        const node = newNodes[i];\n                        const ref = anchor ?? tailAnchor;\n                        if (seq[i] === -1) {\n                            parent.insertBefore(node, ref);\n                        }\n                        else if (!lis[i]) {\n                            parent.insertBefore(node, ref);\n                        }\n                        anchor = node;\n                    }\n                }\n                instances.length = 0;\n                for (let i = 0; i < newNodes.length; i++)\n                    instances.push(newNodes[i]);\n            };\n            const dir = { type: 'for', expression };\n            const effect = self._createEffect(update, dir);\n            dir.update = effect;\n            self._addDirective(placeholder, dir);\n        }\n        _resolveNodeByPath(root, path) {\n            if (!FT_EXT_DIRS)\n                return root;\n            let node = root;\n            for (let i = 0; i < path.length; i++) {\n                let idx = 0;\n                let child = node.firstElementChild;\n                while (child && idx < path[i]) {\n                    child = child.nextElementSibling;\n                    idx++;\n                }\n                node = child || node;\n            }\n            return node;\n        }\n        _computeLISMask(seq) {\n            if (!FT_EXT_DIRS)\n                return { lisMask: [], lisLen: 0 };\n            const predecessors = new Array(seq.length);\n            const tails = [];\n            const tailIdx = [];\n            for (let i = 0; i < seq.length; i++) {\n                const v = seq[i];\n                if (v < 0) {\n                    predecessors[i] = -1;\n                    continue;\n                }\n                let lo = 0, hi = tails.length;\n                while (lo < hi) {\n                    const mid = (lo + hi) >> 1;\n                    if (seq[tails[mid]] < v)\n                        lo = mid + 1;\n                    else\n                        hi = mid;\n                }\n                if (lo === tails.length) {\n                    tails.push(i);\n                }\n                else {\n                    tails[lo] = i;\n                }\n                predecessors[i] = lo > 0 ? tails[lo - 1] : -1;\n                tailIdx[lo] = i;\n            }\n            const lisLen = tails.length;\n            const lis = new Array(seq.length).fill(false);\n            let k = lisLen ? tails[lisLen - 1] : -1;\n            while (k >= 0) {\n                lis[k] = true;\n                k = predecessors[k];\n            }\n            return { lisMask: lis, lisLen };\n        }\n        _render() {\n            const self = this;\n            for (const directives of self._directives.values()) {\n                for (const dr of directives) {\n                    if (XTOOL_ENABLE_STATIC_DIRECTIVES && dr._static)\n                        continue;\n                    if (dr.update) {\n                        try {\n                            dr.update();\n                        }\n                        catch (error) {\n                            if (!(error instanceof ReferenceError)) { }\n                        }\n                    }\n                }\n            }\n        }\n    }\n    ReactiveComponent._BA = {\n        itemscope: 1, formnovalidate: 1, novalidate: 1, default: 1, readonly: 1\n    };\n    const xTool = new XToolFramework();\n    return xTool;\n}();\nif (typeof window !== 'undefined') {\n    const w = window;\n    w.XTool = XToolFramework;\n    w.FyneJS = XToolFramework;\n}\n//# sourceMappingURL=x-tool.js.map"],"mappings":"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","ignoreList":[]}
{"version":3,"names":["ARRAY_ISARRAY","Array","isArray","WkMap","WeakMap","quMct","queueMicrotask","XToolFramework","_se","fn","_tr","s","trim","_Afrom","from","_AisArr","_Okeys","Object","keys","STR_STYLE","STR_DISPLAY","STR_NONE","STR_TAGNAME","STR_TEMPLATE","STR_LENGTH","STR_SOURCE","STR_READONLY","XTOOL_ENABLE_STATIC_DIRECTIVES","d","document","STR_CONTENTS","EV_DELEGATED","head","getElementById","style","createElement","id","textContent","appendChild","PFX","attrCache","Map","attrName","name","cached","get","value","set","TokenType","keywords","Set","visibility","WS_RE","NUM_RE","ReactiveComponent","attachToParent","parent","this","_parent","_addChild","_id","framework","_framework","element","_element","el","isBound","_isBound","v","isMounted","_isMounted","isDestroyed","_isDestroyed","_abortInvokerResources","byKind","_invokerResources","values","cleanup","clear","_cancelUserResources","_resolveBindingMeta","attributeName","elAny","propName","camel","replace","_","c","toUpperCase","toLowerCase","isBooleanProp","hasNonFunctionProp","isKnownBooleanAttr","_BA","_applyGenericBinding","meta","boolVal","setAttribute","removeAttribute","normalized","parts","k","push","length","join","String","getAttribute","_scanDirectiveAttrs","opts","prefixDash","prefixColon","namesOut","hasTextOrHtml","forName","names","getAttributeNames","i","startsWith","skipRootFor","setFrozen","on","_isFrozen","_sealedBeforeFreeze","_isSealed","_scheduleRender","_setSealed","_addDirective","directive","existing","_directives","constructor","def","_propUpdateActive","_runningPropEffect","_beforeMountCalled","_children","_computed","_propEffects","_computedCache","_computedDeps","_computedKeyStack","_isInComputedEvaluation","_isInMethodExecution","_allEffects","_hasComputed","_cleanupFunctions","_directiveAbort","AbortController","_targetIds","_targetSeq","_isMutationEnabled","_effectsToRun","_currentInvoker","_loopScopes","_expressionCache","_propertyDependencies","_activeEffect","_renderScheduled","_nextTickQueue","_changeFrameId","_renderFrameId","_initialClassSets","_rawData","_propParent","_callLifecycleHook","hookName","hook","_lifecycle","_safeExecute","_runWithGlobalInterception","_addCleanupFunction","wrapped","delete","add","_originalMethods","methods","_bindComputed","computed","propEffects","_bindPropEffects","mounted","unmounted","destroyed","updated","beforeMount","beforeUnmount","beforeDestroy","_cloneData","data","_data","_createReactiveData","_methods","_bindMethods","seen","has","arr","Date","getTime","RegExp","source","flags","m","forEach","st","proto","getPrototypeOf","prototype","out","create","key","callBeforeMount","_onDataChange","_property","self","cancelAnimationFrame","effectsToRun","directDeps","size","queue","visited","affectedComputed","queueIdx","base","compKey","baseDeps","entries","compEffects","requestAnimationFrame","effect","_bindFunctionMap","src","kind","makeNoArgCtxRunner","test","isNative","body","compiled","Function","ctx","_createMethodContext","call","original","args","prev","prevInv","newValue","oldValue","prevFlag","_getComputedValue","_trackDependency","getter","undefined","pop","e","propKey","activeEff","deps","includes","stackLen","current","_render","q","splice","fallback","error","bindToElement","completeBinding","getContext","includeComputed","_applyAsyncTemplateResolved","_parseDirectives","_getComponentByElement","_registerElement","child","_removeChild","index","indexOf","wrapper","thisArg","_createContextProxy","apply","destroy","directives","type","customDirective","unbind","abort","_runCleanupCallbacks","_propEffect","idx","_unregisterElement","_deepReactiveCache","_unregisterComponent","_initReactiveProps","expr","evalFn","update","obj","$props","_listen","event","handler","options","signal","addEventListener","capture","merged","_targetKey","target","toString","processElement","isRoot","hasAttribute","isComponentTag","directiveNames","_bindDirective","attr","_bindTextInterpolationsIn","_walkElements","nodes","childNodes","node","nodeType","Node","TEXT_NODE","textNode","raw","nodeValue","__x_ti_bound","segs","charCodeAt","run","start","close","text","slice","repeat","code","nextEsc","nextOpen","end","some","literalOut","map","evaluators","_createElementEvaluator","ei","dirInfo","expression","_createEffect","processor","firstElementChild","next","nextElementSibling","directiveName","isAtEvent","isShortBind","_bindAttributeDirective","_bindSimpleDirective","_bindIfDirective","_bindForDirective","_bindModelDirective","prefix","rest","split","suffix","mods","modifiers","reduce","acc","_getCustomDirective","_bindCustomDirective","_bindEventDirective","_bindIntersectDirective","phase","trimmed","runExpr","_compileHandler","payload","once","rootMargin","unobserve","_ioObserve","cb","entry","info","updateFn","directiveRef","_static","found","evaluator","originalDisplay","_prevShown","innerHTML","property","isCheckbox","isNumeric","isMultiSelect","tagName","multiple","getValueEvaluator","setValueEvaluator","_createEvaluator","checkboxValue","loopScope","_collectLoopScope","inferCheckboxValue","member","checked","sel","selected","setInputValue","t","currentData","parseFloat","getInputValue","currentVal","$value","placeholder","createComment","parentNode","insertBefore","__x_if_anchorParent","parentElement","branches","makeActualElement","content","cloneNode","isTemplate","first","firstEval","__x_tool_bound","originalNodes","sib","isElse","isElseIf","branch","active","orig","removeChild","mountBranch","b","__x_if_current","nextSibling","unmountBranch","eventName","passive","onlySelf","shouldPrevent","prevent","shouldStop","stop","isOutside","outside","isWindow","window","deferExec","defer","keyAliasMap","enter","esc","escape","space","tab","backspace","del","arrowup","arrowdown","arrowleft","arrowright","home","pageup","pagedown","comboRequirements","ctrl","alt","shift","buttonMap","left","middle","right","touchSingle","single","touchMulti","multi","modifierKeys","allowedKeys","aliases","allowedButtons","btn","needKeyCheck","needButtonCheck","needTouchCheck","passesFilters","path","composedPath","tgt","contains","TouchEvent","tCount","touches","MouseEvent","button","KeyboardEvent","ctrlKey","altKey","shiftKey","metaKey","ev","createEventHandler","preventDefault","stopPropagation","canDelegate","_getConfig","delegate","ownerDocument","remover","_registerDelegated","filter","comp","isStatement","JSON","stringify","_extractArrowFunction","match","params","p","Boolean","isBlock","endsWith","paramsList","_compileArrowForEvent","mapArgs","arrow","thisCtx","compiledArrow","executor","result","_assertMutable","parentKey","method","Error","_wrapData","isArr","isSet","isMap","makeCollectionWrapper","beforeLen","beforeFirst","beforeLast","before","existed","proxy","Proxy","receiver","isCollection","Symbol","iterator","Reflect","bind","ownKeys","had","defineProperty","configurable","enumerable","writable","deleteProperty","ok","pc","eff","_includeComputed","specials","$log","$destroy","$forceUpdate","$addCleanupFunction","$nextTick","Promise","resolve","$el","$id","$isMounted","$isDestroyed","$isSealed","$isFrozen","$parent","$children","$seal","$mutate","prevMethod","propStr","_target","targetElement","component","mergedScope","gWindow","gDocument","cfg","sandbox","sandboxExpressions","allow","allowGlobals","ensureInvoker","registerResource","setup","inv","wrapTarget","prop","optSig","removeEventListener","querySelector","querySelectorAll","doc","win","defaultView","wrapObserverCtor","Orig","observerArgs","observe","disconnect","inst","$target","$event","_routerEnabled","location","_t","_navigate","href","setTimeout","ms","clearTimeout","setInterval","clearInterval","MutationObserver","ResizeObserver","IntersectionObserver","hasOwnProperty","_name","directiveInfo","isSvg","namespaceURI","baseSet","oc","className","cls","finalCls","tokens","finalStr","baseStr","tk","classList","toggle","cssText","cssProp","setProperty","removeProperty","cur","anchorParent","__x_scope","scope","assign","_updateElementDirectives","root","force","Element","_updateElementDirectivesForVar","varName","re","_cleanupElementSubtree","toDelete","itemVar","indexVar","listCode","keyAttrName","keyExpr","templateToClone","contextAnchor","listEval","keyEval","BP_FOR","BP_KEY","BP_TEXT","BP_HTML","BP_DATA","hydrateFromBlueprint","cloneRoot","bp","instr","_resolveNodeByPath","j","dn","blueprint","walk","isRootEl","scan","dnames","n","concat","buildBlueprint","instances","createScope","item","idxOrKey","objIds","objSeq","keyFor","explicit","o","extractId","evalKeyExpr","dir","norm","list","tag","keysArr","oldByObjKey","oldPrimQueues","__x_for_key","ps","__x_primSig","newNodes","nodeKey","explicitKey","prevIdxRef","__x_idxRef","prevItemRef","__x_itemRef","needsUpdate","indexChanged","clone","initScope","oldIndexMap","seq","oldIdx","lisMask","lis","_computeLISMask","tailAnchor","anchor","ref","predecessors","tails","tailIdx","lo","hi","mid","lisLen","fill","dr","itemscope","formnovalidate","novalidate","default","readonly","_components","_byEl","_pending","_config","_customDirectives","_currentArrayInterceptorComp","_namedComponentDefs","_delegated","_delegatedRootBound","_prefetched","_currentDocURL","_scrollPositions","registerComponent","definition","_getRegisteredComponentDef","_preDiscoveryTasks","init","config","container","debug","staticDirectives","router","enabled","transitionName","_hpf","async","_applyPrefixInitialCSS","allSettled","_autoDiscoverComponents","_ensureRootObserver","_ensureDelegation","_installRouting","_normalizeDocURL","readyState","_inflightComponentLoads","_lazyComponentSources","loadComponents","sources","items","mode","tasks","it","_fetchAndEvalComponent","catch","then","inferredName","status","results","settled","failed","r","createComponent","_generateComponentId","dataAttr","_bindElementAsComponent","componentElements","reusable","_instantiateNamedComponent","_processPending","components","lastComponent","maybe","parentForEval","dataExpression","parentCtx","_parseDataExpression","desc","getOwnPropertyDescriptors","plainData","dsc","initExpr","_finalizeComponentMount","xInitExpr","now","random","Math","substring","componentId","_log","_routerTransitionName","_isSameOrigin","u","URL","baseURI","origin","_isSameDocument","pathname","search","_scrollToHash","hash","decodeURIComponent","CSS","scrollIntoView","block","behavior","defaultPrevented","a","url","prefetchOnHover","preloadEventHandler","link","preload","targetURL","targetKey","err","curKey","x","scrollX","y","scrollY","html","_fetchHTML","history","pushState","_swapDocument","pos","scrollTo","after","message","res","fetch","credentials","cache","redirect","redirected","finalUrl","statusText","DOMParser","parseFromString","newHead","newTitle","applySwap","title","_morphElement","vt","startViewTransition","cont","getPropertyValue","transition","finished","_setAttributes","curAttrs","nextAttrs","val","_attributesEqual","aNames","bNames","_isDynamicNode","nodeName","replaceWith","firstChild","curChildren","nextChildren","max","cn","nn","toRemove","retries","baseDelay","isTypeScript","strings","str","attempt","isIdentifierStart","ch","ID_START_RE","isIdentifierPart","ID_PART_RE","isGenericStartEnd","startIndex","token","skipType","standalone","skipUntil","Whitespace","Punctuation","hasItem","isSimple","Keyword","Identifier","isComplex","depth","hasNewline","isContinued","Arrow","isObjectLiteralStart","prevToken","isWhitespace","isNumber","pred","context","collection","input","createToken","Comment","Number","quoteType","tplExprDepth","nestedDepth","tokenize","isObjectLiteral","isClassBody","braceDepth","lastIdentifier","lastKeyword","objectBraceDepth","outputString","tt","paramToken","pt","pv","gt","stripTypes","delay","pow","finally","_rootObserver","records","addedNodes","removedNodes","isConnected","stack","_onComponentSourceChanged","ro","childList","subtree","attributes","attributeFilter","_ensureIO","_ioObservers","_ioRegistry","io","reg","isIntersecting","visible","leave","onEnter","onLeave","existingMounted","parentComp","lazy","promise","par","props","dynamicPropObj","rawPropExpression","propExpr","initDef","baseData","makeData","compDef","originalChildren","replaceChildren","template","applyTemplate","tpl","slots","slotEl","matched","tplVal","append","nested","cancelBubble","h","captureEvents","bubbleEvents","l","w","XTool","FyneJS"],"sourceRoot":"./dist","sources":["dist/x-tool.js"],"sourcesContent":["\"use strict\";\nconst ARRAY_ISARRAY = Array.isArray;\nconst WkMap = WeakMap;\nconst quMct = queueMicrotask;\nconst FT_C = true;\nconst FT_TI = typeof __FEAT_TEXT_INTERP__ === 'boolean' ? __FEAT_TEXT_INTERP__ : true;\nconst _FT_DR = typeof __FEAT_DEEP_REACTIVE__ === 'boolean' ? __FEAT_DEEP_REACTIVE__ : true;\nconst FT_IFB = typeof __FEAT_IF_BRANCHES__ === 'boolean' ? __FEAT_IF_BRANCHES__ : true;\nconst XToolFramework = function () {\n    const _se = (fn) => { try {\n        fn();\n    }\n    catch { } };\n    const _tr = (s) => (s || '').trim();\n    const _Afrom = Array.from;\n    const _AisArr = ARRAY_ISARRAY;\n    const _Okeys = Object.keys;\n    const STR_STYLE = 'style';\n    const STR_DISPLAY = 'display';\n    const STR_NONE = 'none';\n    const STR_TAGNAME = 'tagName';\n    const STR_TEMPLATE = 'TEMPLATE';\n    const STR_LENGTH = 'length';\n    const STR_SOURCE = 'source';\n    const STR_READONLY = 'readonly';\n    let XTOOL_ENABLE_STATIC_DIRECTIVES = true;\n    const d = (typeof document !== 'undefined' ? document : null);\n    const STR_CONTENTS = 'contents';\n    const EV_CLICK = 'click', EV_INPUT = 'input', EV_CHANGE = 'change', EV_KEYDOWN = 'keydown', EV_KEYUP = 'keyup';\n    const EV_DELEGATED = [EV_CLICK, EV_INPUT, EV_CHANGE, EV_KEYDOWN, EV_KEYUP];\n    const LS_PENDING = 0, LS_LOADING = 1, LS_LOADED = 2, LS_ERROR = 3;\n    try {\n        if (d && d.head && !d.getElementById('x-tool-initial-css')) {\n            const style = d.createElement(STR_STYLE);\n            style.id = 'x-tool-initial-css';\n            style.textContent = '[x-show],[x-if],[x-else],[x-else-if],[x\\\\:show],[x\\\\:if],[x\\\\:else],[x\\\\:else-if]{display:none;}';\n            d.head.appendChild(style);\n        }\n    }\n    catch { }\n    let PFX = 'x';\n    let attrCache = new Map();\n    const attrName = (name) => {\n        const cached = attrCache.get(name);\n        if (cached)\n            return cached;\n        const value = `${PFX}-${name}`;\n        attrCache.set(name, value);\n        return value;\n    };\n    let TokenType;\n    (function (TokenType) {\n        TokenType[TokenType[\"Identifier\"] = 0] = \"Identifier\";\n        TokenType[TokenType[\"Keyword\"] = 1] = \"Keyword\";\n        TokenType[TokenType[\"Punctuation\"] = 2] = \"Punctuation\";\n        TokenType[TokenType[\"String\"] = 3] = \"String\";\n        TokenType[TokenType[\"Comment\"] = 4] = \"Comment\";\n        TokenType[TokenType[\"Whitespace\"] = 5] = \"Whitespace\";\n        TokenType[TokenType[\"Number\"] = 6] = \"Number\";\n        TokenType[TokenType[\"Arrow\"] = 7] = \"Arrow\";\n    })(TokenType || (TokenType = {}));\n    const keywords = new Set([\n        'as', 'interface', 'type', 'import', 'export', 'from', 'extends', 'implements',\n        'declare', 'namespace', 'module', 'any', 'unknown', 'never', 'void',\n        'number', 'string', 'boolean', 'symbol', 'bigint', 'object', 'enum', 'function'\n    ]);\n    const visibility = ['public', 'private', 'protected', 'static', 'abstract', 'readonly'];\n    const WS_RE = /\\s/;\n    const NUM_RE = /\\d/;\n    function stripTypes(source) {\n        const ID_START_RE = /[a-zA-Z_$]/;\n        const ID_PART_RE = /[a-zA-Z0-9_$]/;\n        function isIdentifierStart(ch) { return ID_START_RE.test(ch); }\n        function isIdentifierPart(ch) { return ID_PART_RE.test(ch); }\n        const isWhitespace = (ch) => WS_RE.test(ch);\n        const isNumber = (ch) => NUM_RE.test(ch);\n        function isGenericStartEnd(startIndex, tokens) {\n            const token = tokens[startIndex];\n            const ch = token.value == '<' ? '<' : '>';\n            return token.value == ch && (token.next?.value !== ch && token.prev?.value !== ch);\n        }\n        const skipUntil = (tokens, index, pred) => {\n            const context = { index, depth: 0 };\n            while (index < tokens.length && !pred(tokens[index], context))\n                index++;\n            return index;\n        };\n        const hasItem = (item, collection) => {\n            return collection.indexOf(item) !== -1;\n        };\n        function skipType(tokens, startIndex, standalone = true) {\n            let i = startIndex;\n            const ctx = {};\n            i = skipUntil(tokens, i, t => t.type !== TokenType.Whitespace && !(t.type === TokenType.Punctuation && hasItem(t.value, '|?&:')));\n            let isSimple = hasItem(tokens[i].type, [TokenType.Keyword, TokenType.Identifier]);\n            if (isSimple && tokens[i] && tokens[i].next?.type === TokenType.Punctuation && hasItem(tokens[i].next?.value, '<[{(')) {\n                i = skipUntil(tokens, i, t => t.type === TokenType.Punctuation);\n            }\n            let isComplex = tokens[i].type === TokenType.Punctuation && hasItem(tokens[i].value, '<[{(');\n            while (i < tokens.length) {\n                if (isComplex) {\n                    i = skipUntil(tokens, i, (t, ctx) => {\n                        if (t.type === TokenType.Punctuation) {\n                            if (hasItem(t.value, ']})>'))\n                                ctx.depth--;\n                            else if (hasItem(t.value, '<[{('))\n                                ctx.depth++;\n                        }\n                        return ctx.depth <= 0;\n                    });\n                    i++;\n                }\n                else {\n                    i = skipUntil(tokens, i, t => (TokenType.Whitespace === t.type && t.value !== \" \") || (t.type === TokenType.Punctuation && t.value !== '.'));\n                    if (standalone && tokens[i] && tokens[i].type === TokenType.Punctuation && hasItem(tokens[i].value, '<[{(')) {\n                        let hasNewline = false;\n                        skipUntil(tokens, i, t => { if (t.type === TokenType.Whitespace && hasItem(\"\\n\", t.value))\n                            hasNewline = true; return hasNewline || t.start >= tokens[i].start; });\n                        if (!hasNewline) {\n                            i = skipUntil(tokens, i, (t, ctx) => {\n                                if (t.type === TokenType.Punctuation) {\n                                    if (hasItem(t.value, ']})>'))\n                                        ctx.depth--;\n                                    else if (hasItem(t.value, '<[{('))\n                                        ctx.depth++;\n                                }\n                                return ctx.depth <= 0;\n                            });\n                            i++;\n                        }\n                    }\n                }\n                if (i >= tokens.length) {\n                    break;\n                }\n                if (tokens[i].type === TokenType.Whitespace && hasItem(\"\\n\", tokens[i].value) && tokens[i].prev?.next && tokens[i].prev?.next?.type === TokenType.Punctuation && hasItem(tokens[i].prev?.next?.value, '?&|:')) {\n                    i = skipUntil(tokens, i, t => t.type == TokenType.Punctuation);\n                }\n                if (tokens[i].type === TokenType.Whitespace)\n                    i = skipUntil(tokens, i, t => !t.value.startsWith(' '));\n                let cur = tokens[i];\n                const isContinued = cur.type === TokenType.Punctuation && hasItem(cur.value, \"?&|:\") || (cur.type === TokenType.Arrow && cur.prev?.value === ')');\n                if (!isContinued && (isSimple && cur.type === TokenType.Punctuation && (hasItem(cur.value, '(<[') || standalone && cur.value == '{'))) {\n                    isComplex = true;\n                    i = skipUntil(tokens, i, t => t.type !== TokenType.Whitespace);\n                    continue;\n                }\n                if (isContinued) {\n                    i++;\n                    i = skipUntil(tokens, i, t => !t.value.startsWith(' '));\n                }\n                ctx.isContinued = isContinued;\n                ctx.token = tokens[i];\n                if (!isContinued) {\n                    if (standalone) {\n                        i++;\n                    }\n                    break;\n                }\n                else {\n                    isSimple = hasItem(tokens[i].type, [TokenType.Keyword, TokenType.Identifier]);\n                    isComplex = tokens[i].type === TokenType.Punctuation && hasItem(tokens[i].value, '<[{(');\n                }\n            }\n            return i;\n        }\n        function tokenize(input) {\n            const tokens = [];\n            let pos = 0;\n            const length = input.length;\n            let prevToken;\n            const createToken = (type, start, end) => {\n                const token = {\n                    type,\n                    value: input.slice(start, end),\n                    start,\n                    end\n                };\n                if (prevToken) {\n                    token.prev = prevToken;\n                    prevToken.next = token;\n                }\n                if (type !== TokenType.Whitespace && type !== TokenType.Comment) {\n                    prevToken = token;\n                }\n                return token;\n            };\n            while (pos < length) {\n                const ch = input[pos];\n                let start = pos;\n                if (isWhitespace(ch)) {\n                    do {\n                        pos++;\n                    } while (pos < length && isWhitespace(input[pos]));\n                    tokens.push(createToken(TokenType.Whitespace, start, pos));\n                    continue;\n                }\n                if (isIdentifierStart(ch)) {\n                    pos++;\n                    while (pos < length && isIdentifierPart(input[pos]))\n                        pos++;\n                    const value = input.slice(start, pos);\n                    tokens.push(createToken(keywords.has(value) || hasItem(value, visibility) ? TokenType.Keyword : TokenType.Identifier, start, pos));\n                    continue;\n                }\n                if (isNumber(ch)) {\n                    do {\n                        pos++;\n                    } while (pos < length && isNumber(input[pos]));\n                    tokens.push(createToken(TokenType.Number, start, pos));\n                    continue;\n                }\n                if (ch === '\"' || ch === \"'\" || ch === '`') {\n                    const quoteType = ch;\n                    pos++;\n                    if (quoteType !== '`') {\n                        while (pos < length) {\n                            if (input[pos] === '\\\\')\n                                pos += 2;\n                            else if (input[pos] === quoteType) {\n                                pos++;\n                                break;\n                            }\n                            else\n                                pos++;\n                        }\n                        tokens.push(createToken(TokenType.String, start, pos));\n                        continue;\n                    }\n                    let tplExprDepth = 0;\n                    while (pos < length) {\n                        const c = input[pos];\n                        if (c === '\\\\') {\n                            pos += 2;\n                            continue;\n                        }\n                        if (c === '`' && tplExprDepth === 0) {\n                            pos++;\n                            break;\n                        }\n                        if (c === '$' && pos + 1 < length && input[pos + 1] === '{') {\n                            tplExprDepth++;\n                            pos += 2;\n                            while (pos < length && tplExprDepth > 0) {\n                                const e = input[pos];\n                                if (e === '\\\\') {\n                                    pos += 2;\n                                    continue;\n                                }\n                                if (e === '\"' || e === \"'\") {\n                                    const q = e;\n                                    pos++;\n                                    while (pos < length) {\n                                        if (input[pos] === '\\\\')\n                                            pos += 2;\n                                        else if (input[pos] === q) {\n                                            pos++;\n                                            break;\n                                        }\n                                        else\n                                            pos++;\n                                    }\n                                    continue;\n                                }\n                                if (e === '`') {\n                                    pos++;\n                                    let nestedDepth = 0;\n                                    while (pos < length) {\n                                        const n = input[pos];\n                                        if (n === '\\\\') {\n                                            pos += 2;\n                                            continue;\n                                        }\n                                        if (n === '`' && nestedDepth === 0) {\n                                            pos++;\n                                            break;\n                                        }\n                                        if (n === '$' && pos + 1 < length && input[pos + 1] === '{') {\n                                            nestedDepth++;\n                                            pos += 2;\n                                            continue;\n                                        }\n                                        if (n === '}' && nestedDepth > 0) {\n                                            nestedDepth--;\n                                            pos++;\n                                            continue;\n                                        }\n                                        pos++;\n                                    }\n                                    continue;\n                                }\n                                if (e === '{') {\n                                    tplExprDepth++;\n                                    pos++;\n                                    continue;\n                                }\n                                if (e === '}') {\n                                    tplExprDepth--;\n                                    pos++;\n                                    continue;\n                                }\n                                pos++;\n                            }\n                            continue;\n                        }\n                        pos++;\n                    }\n                    tokens.push(createToken(TokenType.String, start, pos));\n                    continue;\n                }\n                if (ch === '/' && pos + 1 < length) {\n                    if (input[pos + 1] === '/') {\n                        pos += 2;\n                        while (pos < length && input[pos] !== '\\n')\n                            pos++;\n                        tokens.push(createToken(TokenType.Comment, start, pos));\n                        continue;\n                    }\n                    if (input[pos + 1] === '*') {\n                        pos += 2;\n                        while (pos < length && !(input[pos] === '*' && input[pos + 1] === '/'))\n                            pos++;\n                        pos += 2;\n                        tokens.push(createToken(TokenType.Comment, start, pos));\n                        continue;\n                    }\n                }\n                if (ch === '=' && pos + 1 < length && input[pos + 1] === '>') {\n                    pos += 2;\n                    tokens.push(createToken(TokenType.Arrow, start, pos));\n                    continue;\n                }\n                tokens.push(createToken(TokenType.Punctuation, pos, ++pos));\n            }\n            return tokens;\n        }\n        function isObjectLiteralStart(tokens, index) {\n            let j = index - 1;\n            while (j >= 0 && tokens[j].type === TokenType.Whitespace)\n                j--;\n            if (j < 0)\n                return false;\n            const prevToken = tokens[j];\n            if (prevToken.type === TokenType.Arrow)\n                return false;\n            return (prevToken.type === TokenType.Identifier && prevToken.value === 'return') || prevToken.type === TokenType.Punctuation && (prevToken.value === '=' || prevToken.value === '(' || prevToken.value === '[' ||\n                prevToken.value === ',' || prevToken.value === ':' || prevToken.value === '?');\n        }\n        const tokens = tokenize(source);\n        let i = 0;\n        const context = {\n            isObjectLiteral: false,\n            isClassBody: false,\n            braceDepth: 0,\n            lastIdentifier: undefined,\n            lastKeyword: undefined\n        };\n        let objectBraceDepth = 0;\n        let outputString = '';\n        while (i < tokens.length) {\n            const token = tokens[i];\n            const tt = token.type;\n            const v = token.value;\n            if (tt === TokenType.Comment) {\n                i++;\n                continue;\n            }\n            if (tt === TokenType.Identifier) {\n                context.lastIdentifier = v;\n            }\n            if ((tt == TokenType.Identifier || tt == TokenType.Keyword) && ((token.next?.type === TokenType.Keyword && token.next.value == 'enum') || (v == 'enum'))) {\n                i = skipUntil(tokens, i, t => t.value == '}');\n                i++;\n                continue;\n            }\n            if (tt == TokenType.String || (tt != TokenType.Punctuation && TokenType.Whitespace != tt && TokenType.Keyword != tt)) {\n                i++;\n                outputString += v;\n                continue;\n            }\n            if (tt === TokenType.Whitespace) {\n                outputString += (v.includes('\\n') ? '\\n' : v);\n                i++;\n                continue;\n            }\n            if (context.lastIdentifier === 'class') {\n                context.isClassBody = true;\n            }\n            if (tt === TokenType.Punctuation && v === '{') {\n                context.braceDepth++;\n                if (isObjectLiteralStart(tokens, i)) {\n                    objectBraceDepth++;\n                    context.isObjectLiteral = true;\n                }\n                outputString += token.value;\n                i++;\n                continue;\n            }\n            if (tt === TokenType.Punctuation && v === '}') {\n                context.braceDepth--;\n                if (context.isObjectLiteral) {\n                    objectBraceDepth--;\n                    if (objectBraceDepth <= 0)\n                        context.isObjectLiteral = false;\n                }\n                if (context.braceDepth <= 0) {\n                    context.isClassBody = false;\n                }\n                outputString += token.value;\n                i++;\n                continue;\n            }\n            if (tt === TokenType.Keyword) {\n                if (!context.isObjectLiteral && v === 'import') {\n                    i = skipUntil(tokens, i, t => (t.type === TokenType.Keyword && t.value === 'from'));\n                    i = skipUntil(tokens, i, t => t.value === ';' || (t.type === TokenType.Whitespace && t.value.includes(\"\\n\")));\n                    if (i < tokens.length && tokens[i].value === ';')\n                        i++;\n                    continue;\n                }\n                if (v === 'as' && !isObjectLiteralStart(tokens, i)) {\n                    i++;\n                    i = skipUntil(tokens, i, t => t.type !== TokenType.Whitespace);\n                    i = skipType(tokens, i, false);\n                    continue;\n                }\n                if (v === 'export' && !context.isObjectLiteral && (String(token.next?.value + token.next?.next?.value).match(/(const\\s+)?(type|interface|enum|namespace|function)/))) {\n                    i++;\n                    i = skipUntil(tokens, i, t => t.type !== TokenType.Whitespace);\n                    continue;\n                }\n                if (v === 'function' && token.next?.type === TokenType.Identifier && token.next?.next?.type === TokenType.Punctuation && token.next?.next?.value === '(' && token.next?.next?.next && token.next?.next?.next?.type === TokenType.Identifier) {\n                    let j = i + 4;\n                    let depth = 1;\n                    while (j < tokens.length && depth > 0) {\n                        const t = tokens[j];\n                        if (t.type === TokenType.Punctuation) {\n                            if (t.value === '(')\n                                depth++;\n                            else if (t.value === ')')\n                                depth--;\n                        }\n                        j++;\n                    }\n                    j = skipUntil(tokens, j, t => t.type !== TokenType.Whitespace);\n                    if (j < tokens.length && tokens[j].type === TokenType.Punctuation && tokens[j].value === ':') {\n                        j++;\n                        j = skipType(tokens, j, false);\n                        j = skipUntil(tokens, j, t => t.type !== TokenType.Whitespace);\n                    }\n                    if (j < tokens.length && tokens[j].type === TokenType.Punctuation && tokens[j].value === ';') {\n                        i = j + 1;\n                        continue;\n                    }\n                }\n            }\n            if (!context.isObjectLiteral && tt === TokenType.Keyword && !isObjectLiteralStart(tokens, i) && hasItem(v, ['interface', 'type', 'declare', 'namespace', 'module'])) {\n                if (v === 'type')\n                    i = skipUntil(tokens, i, (t, ctx) => {\n                        if (t.type === TokenType.Punctuation) {\n                            if (hasItem(t.value, '<[({')) {\n                                ctx.depth++;\n                            }\n                            else if (hasItem(t.value, '>])}')) {\n                                ctx.depth--;\n                            }\n                        }\n                        return ctx.depth <= 0 && t.type === TokenType.Punctuation && t.value == '=';\n                    }), i++;\n                else\n                    i++;\n                i = skipType(tokens, i, true);\n                continue;\n            }\n            if (!context.isObjectLiteral && tt === TokenType.Keyword && v === 'implements' && token.next?.type !== TokenType.Punctuation && !context.isObjectLiteral) {\n                i++;\n                i = skipUntil(tokens, i, t => t.type === TokenType.Punctuation && t.value == '{');\n                continue;\n            }\n            if (tt === TokenType.Punctuation && v === '!' && token.prev?.type !== TokenType.Punctuation && token.prev?.type !== TokenType.Arrow) {\n                i++;\n                continue;\n            }\n            if (tt === TokenType.Punctuation && v === '(') {\n                if (token.next && token.next.value === '{') {\n                    outputString += token.value;\n                    i++;\n                    continue;\n                }\n                outputString += v;\n                i++;\n                let depth = 1;\n                while (i < tokens.length && depth > 0) {\n                    const paramToken = tokens[i];\n                    const pt = paramToken.type;\n                    const pv = paramToken.value;\n                    if (pt == TokenType.Punctuation && pv == '{' && isObjectLiteralStart(tokens, i)) {\n                        skipUntil(tokens, i, (t, ctx) => {\n                            if (t.type === TokenType.Punctuation) {\n                                if (t.value === '{')\n                                    ctx.depth++;\n                                else if (t.value === '}')\n                                    ctx.depth--;\n                            }\n                            outputString += tokens[i].value;\n                            i++;\n                            return ctx.depth <= 0;\n                        });\n                        continue;\n                    }\n                    if (pt == TokenType.Comment) {\n                        i++;\n                        continue;\n                    }\n                    if (pt === TokenType.Punctuation && pv === '(') {\n                        depth++;\n                    }\n                    else if (pt === TokenType.Punctuation && pv === ')') {\n                        depth--;\n                    }\n                    if (pt === TokenType.Keyword && hasItem(pv, visibility)) {\n                        i++;\n                        if (tokens[i].type === TokenType.Whitespace)\n                            i = skipUntil(tokens, i, t => t.type !== TokenType.Whitespace);\n                        continue;\n                    }\n                    if (pt === TokenType.Punctuation && pv === '!' && paramToken.prev && paramToken.prev.type === TokenType.Identifier) {\n                        i++;\n                        continue;\n                    }\n                    if (pt === TokenType.Punctuation && (pv === ':' || (pv == '?' && paramToken.next?.type == TokenType.Punctuation && paramToken.next?.value == ':')) || (TokenType.Keyword === pt && pv == 'as')) {\n                        i++;\n                        i = skipType(tokens, i, false);\n                        continue;\n                    }\n                    if (i < tokens.length && tokens[i].type === TokenType.Punctuation && tokens[i].value === ')') {\n                        outputString += tokens[i].value;\n                        i++;\n                        if (i < tokens.length && tokens[i].type === TokenType.Punctuation && tokens[i].value === ':') {\n                            i++;\n                            i = skipType(tokens, i, false);\n                        }\n                        continue;\n                    }\n                    outputString += paramToken.value;\n                    i++;\n                }\n                continue;\n            }\n            if (tt === TokenType.Punctuation && (v === ':' || (v === '?' && token.next?.type === TokenType.Punctuation && token.next.value == ':'))) {\n                if (token.prev && token.prev.type === TokenType.Identifier && !context.isObjectLiteral) {\n                    i++;\n                    i = skipType(tokens, i, false);\n                    continue;\n                }\n            }\n            if (tt === TokenType.Punctuation && v === '<' && isGenericStartEnd(i, tokens)) {\n                if (i < tokens.length) {\n                    let j = skipType(tokens, i, false);\n                    if (tokens[j] && tokens[j].type === TokenType.Whitespace)\n                        j = skipUntil(tokens, j, t => t.type !== TokenType.Whitespace);\n                    let gt = tokens[j];\n                    if (gt && gt.type == TokenType.Punctuation && '({['.indexOf(gt.value) !== -1) {\n                        i = j;\n                        continue;\n                    }\n                }\n            }\n            if (!context.isObjectLiteral && tt === TokenType.Keyword &&\n                hasItem(v, visibility)) {\n                i++;\n                continue;\n            }\n            if (tt === TokenType.Keyword) {\n                context.lastKeyword = token.value;\n            }\n            outputString += v;\n            i++;\n        }\n        return outputString;\n    }\n    class XToolFramework {\n        constructor() {\n            this._components = new Map();\n            this._byEl = new WkMap();\n            this._pending = [];\n            this._config = {};\n            this._customDirectives = new Map();\n            this._currentArrayInterceptorComp = null;\n            this._namedComponentDefs = new Map();\n            this._delegated = new WkMap();\n            this._delegatedRootBound = false;\n            this._prefetched = new Set();\n            this._currentDocURL = '';\n            this._scrollPositions = new Map();\n            this.directive = (name, directive) => {\n                if (name.startsWith(PFX + '-')) {\n                    throw new Error(`Custom directive names should not start with \"${PFX}-\". Use: XTool.directive(\"my-directive\", ...)`);\n                }\n                this._customDirectives.set(name, directive);\n                return this;\n            };\n            this.registerComponent = (definition) => {\n                if (!definition || !definition.name)\n                    throw new Error('registerComponent requires a name');\n                const name = definition.name.toLowerCase();\n                if (this._namedComponentDefs.has(name))\n                    return this;\n                this._namedComponentDefs.set(name, definition);\n                return this;\n            };\n            this._getRegisteredComponentDef = (name) => this._namedComponentDefs.get(name.toLowerCase());\n            this._getCustomDirective = (name) => this._customDirectives.get(name);\n            this._getConfig = () => this._config;\n            this._preDiscoveryTasks = [];\n            this.init = (config = {}) => {\n                const base = { container: 'body', debug: false, staticDirectives: true, router: { enabled: false, transitionName: 'route' } };\n                this._config = { ...base, ...config, router: { ...base.router, ...(config.router || {}) } };\n                if (typeof this._config.staticDirectives === 'boolean') {\n                    XTOOL_ENABLE_STATIC_DIRECTIVES = this._config.staticDirectives;\n                }\n                const _hpf = this._config.prefix;\n                if (_hpf && typeof _hpf === 'string' && _hpf[STR_LENGTH] > 0) {\n                    PFX = _hpf;\n                }\n                else {\n                    PFX = 'x';\n                }\n                attrCache.clear();\n                const start = async () => {\n                    this._applyPrefixInitialCSS();\n                    if (this._preDiscoveryTasks.length) {\n                        try {\n                            await Promise.allSettled(this._preDiscoveryTasks);\n                        }\n                        catch { }\n                    }\n                    this._autoDiscoverComponents();\n                    const c = d?.querySelector(this._config.container);\n                    if (c) {\n                        this._ensureRootObserver(c);\n                        if (this._config.delegate)\n                            this._ensureDelegation(c);\n                        if (this._routerEnabled())\n                            this._installRouting(c);\n                    }\n                    try {\n                        this._currentDocURL = this._normalizeDocURL(location.href);\n                    }\n                    catch { }\n                };\n                if (d && d.readyState === 'loading') {\n                    d.addEventListener('DOMContentLoaded', () => { void start(); });\n                }\n                else if (!d || d.readyState === 'complete' || d.readyState === 'interactive') {\n                    void start();\n                }\n                return this;\n            };\n            this._inflightComponentLoads = new Map();\n            this._lazyComponentSources = new Map();\n            this.loadComponents = (sources) => {\n                const items = sources.map(s => typeof s === 'string' ? { path: s, mode: 'preload', name: undefined } : { path: s.path, mode: (s.mode || 'preload'), name: s.name });\n                const tasks = [];\n                for (const it of items) {\n                    if (it.mode === 'defer') {\n                        const p = this._fetchAndEvalComponent(it.path).catch(() => { throw new Error('load failed'); });\n                        this._preDiscoveryTasks.push(p);\n                        tasks.push(p.then(() => { }));\n                    }\n                    else if (it.mode === 'lazy') {\n                        const inferredName = (it.name || it.path.split('/').pop() || '').replace(/\\.(mjs|js|ts)(\\?.*)?$/i, '').toLowerCase();\n                        if (inferredName && !this._lazyComponentSources.has(inferredName)) {\n                            this._lazyComponentSources.set(inferredName, { path: it.path, status: LS_PENDING });\n                        }\n                    }\n                    else {\n                        const p = this._fetchAndEvalComponent(it.path).catch(() => { throw new Error('load failed'); });\n                        tasks.push(p);\n                    }\n                }\n                return Promise.allSettled(tasks).then(results => {\n                    try {\n                        this._autoDiscoverComponents();\n                    }\n                    catch { }\n                    const settled = results.length;\n                    const failed = results.filter(r => r.status === 'rejected').length;\n                    return { settled, failed };\n                });\n            };\n            this.createComponent = (definition) => {\n                const component = new ReactiveComponent(this._generateComponentId(), definition, this);\n                this._components.set(component.id, component);\n                component.callBeforeMount();\n                return component;\n            };\n            this._autoDiscoverComponents = () => {\n                const container = d?.querySelector(this._config.container);\n                if (!container)\n                    return;\n                const dataAttr = attrName('data');\n                if (container.hasAttribute(dataAttr) && !this._getComponentByElement(container)) {\n                    this._bindElementAsComponent(container, undefined);\n                }\n                const componentElements = container.querySelectorAll(`[${dataAttr}]`);\n                for (const element of componentElements) {\n                    if (!this._getComponentByElement(element))\n                        this._bindElementAsComponent(element);\n                }\n                const reusable = container.querySelectorAll('component[source]');\n                for (const el of reusable) {\n                    if (!this._getComponentByElement(el))\n                        this._instantiateNamedComponent(el);\n                }\n                this._processPending();\n                if (componentElements[STR_LENGTH] === 0 && !this._getComponentByElement(container)) {\n                    const components = _Afrom(this._components.values());\n                    const lastComponent = components[components[STR_LENGTH] - 1];\n                    if (lastComponent && !lastComponent.isBound) {\n                        lastComponent.bindToElement(container);\n                    }\n                }\n            };\n            this._processPending = () => {\n                if (!this._pending[STR_LENGTH])\n                    return;\n                for (const p of this._pending) {\n                    let cur = p.el.parentElement;\n                    let parent;\n                    while (cur && !parent) {\n                        const maybe = this._getComponentByElement(cur);\n                        if (maybe)\n                            parent = maybe;\n                        else\n                            cur = cur.parentElement;\n                    }\n                    if (parent) {\n                        p.comp.attachToParent(parent);\n                    }\n                }\n                for (const p of this._pending)\n                    p.comp.completeBinding();\n                this._pending = [];\n            };\n            this._bindElementAsComponent = (element, parentForEval) => {\n                const dataExpression = element.getAttribute(attrName('data'));\n                let data = {};\n                if (dataExpression) {\n                    element.removeAttribute(attrName('data'));\n                    try {\n                        if (parentForEval) {\n                            let parentCtx = {};\n                            if (parentForEval._createMethodContext) {\n                                try {\n                                    parentCtx = parentForEval._createMethodContext();\n                                }\n                                catch { }\n                            }\n                            const evalFn = new Function('parent', `with(parent){ return (${dataExpression}) }`);\n                            data = evalFn(parentCtx);\n                        }\n                        else {\n                            data = this._parseDataExpression(dataExpression);\n                        }\n                        const desc = Object.getOwnPropertyDescriptors(data);\n                        const computed = {};\n                        const plainData = {};\n                        for (const key in desc) {\n                            const dsc = desc[key];\n                            if (typeof dsc.get === 'function') {\n                                computed[key] = dsc.get;\n                            }\n                            else if ('value' in dsc) {\n                                plainData[key] = dsc.value;\n                            }\n                        }\n                        const hasOwnMethods = plainData.methods || data.methods;\n                        const methodsObj = data.methods;\n                        const def = hasOwnMethods ? { methods: methodsObj, data: plainData } : { data: plainData };\n                        if (_Okeys(computed).length)\n                            def.computed = computed;\n                        if (parentForEval) {\n                            def.data.$parent = parentForEval;\n                        }\n                        data = def;\n                    }\n                    catch (e) {\n                    }\n                }\n                const comp = this.createComponent(data);\n                const initExpr = element.getAttribute(attrName('init')) || undefined;\n                if (initExpr)\n                    element.removeAttribute(attrName('init'));\n                this._finalizeComponentMount(element, comp, { callBeforeMount: true, xInitExpr: initExpr });\n            };\n            this._generateComponentId = () => {\n                const now = Date.now();\n                const random = Math.random().toString(36).substring(2, 15);\n                const counter = (this._components.size + 1).toString(36);\n                return `component_${now}_${counter}_${random}`;\n            };\n            this._parseDataExpression = (expression) => {\n                try {\n                    return new Function('return ' + expression.trim())();\n                }\n                catch {\n                    return {};\n                }\n            };\n            this._unregisterComponent = (componentId) => { this._components.delete(componentId); };\n            this._log = (..._args) => { };\n            this._registerElement = (element, component) => {\n                this._byEl.set(element, component);\n            };\n            this._unregisterElement = (element) => { try {\n                this._byEl.delete(element);\n            }\n            catch { } };\n        }\n        _routerEnabled() { const c = this._config; return !!(c.router?.enabled); }\n        _routerTransitionName() { const c = this._config; return (c.router?.transitionName ?? 'route'); }\n        _isSameOrigin(href) {\n            try {\n                const u = new URL(href, d?.baseURI || location.href);\n                const cur = new URL(location.href);\n                return u.origin === cur.origin;\n            }\n            catch {\n                return false;\n            }\n        }\n        _isSameDocument(target) {\n            try {\n                const u = typeof target === 'string' ? new URL(target, d?.baseURI || location.href) : target;\n                const cur = new URL(location.href);\n                return (u.origin === cur.origin && u.pathname === cur.pathname && u.search === cur.search);\n            }\n            catch {\n                return false;\n            }\n        }\n        _normalizeDocURL(target) {\n            const u = typeof target === 'string' ? new URL(target, d?.baseURI || location.href) : target;\n            return `${u.origin}${u.pathname}${u.search}`;\n        }\n        _scrollToHash(hash) {\n            try {\n                if (!hash || hash === '#')\n                    return false;\n                const id = decodeURIComponent(hash.replace(/^#/, ''));\n                const el = d.getElementById(id) || d.querySelector(`[name=\"${CSS.escape(id)}\"]`);\n                if (el) {\n                    el.scrollIntoView({ block: 'start', 'behavior': 'instant' });\n                    return true;\n                }\n            }\n            catch { }\n            return false;\n        }\n        _installRouting(root) {\n            const self = this;\n            const preload = (href) => {\n                try {\n                    if (!self._isSameOrigin(href))\n                        return;\n                }\n                catch {\n                    return;\n                }\n                const u = new URL(href, location.href);\n                if (self._isSameDocument(u))\n                    return;\n                u.hash = '';\n                const url = u.toString();\n                if (self._prefetched.has(url))\n                    return;\n                const existing = d?.head?.querySelector(`link[rel=\"prefetch\"][href=\"${CSS.escape(url)}\"]`);\n                if (existing) {\n                    self._prefetched.add(url);\n                    return;\n                }\n                try {\n                    const link = d.createElement('link');\n                    link.setAttribute('rel', 'prefetch');\n                    link.setAttribute('as', 'document');\n                    link.setAttribute('href', url);\n                    d.head.appendChild(link);\n                    self._prefetched.add(url);\n                }\n                catch { }\n            };\n            const onClick = (e) => {\n                const ev = e;\n                if (ev.defaultPrevented || ev.metaKey || ev.ctrlKey || ev.shiftKey || ev.altKey)\n                    return;\n                let el = ev.target;\n                while (el && el !== root && el.tagName !== 'A')\n                    el = el.parentElement;\n                if (!el || el.tagName !== 'A' || el.hasAttribute('download'))\n                    return;\n                const a = el;\n                const href = a.getAttribute('href');\n                if (!href || href.startsWith('#'))\n                    return;\n                const target = a.getAttribute('target');\n                if (target && target.toLowerCase() === '_blank')\n                    return;\n                if (!self._isSameOrigin(href))\n                    return;\n                const url = new URL(href, location.href);\n                if (self._isSameDocument(url))\n                    return;\n                ev.preventDefault();\n                self._navigate(url.toString(), true, 'link').catch(() => { location.assign(url.toString()); });\n            };\n            root.addEventListener('click', onClick);\n            if (this._config.router?.prefetchOnHover) {\n                const preloadEventHandler = (e) => {\n                    const t = e.target;\n                    let el = t;\n                    while (el && el !== root && el.tagName !== 'A')\n                        el = el.parentElement;\n                    if (!el || el.tagName !== 'A' || el.hasAttribute('download'))\n                        return;\n                    const href = el.getAttribute('href');\n                    if (!href || href.startsWith('#'))\n                        return;\n                    preload(href);\n                };\n                root.addEventListener('mouseover', preloadEventHandler, { passive: true });\n                root.addEventListener('touchstart', preloadEventHandler, { passive: true });\n            }\n            window.addEventListener('popstate', () => { self._navigate(location.href, false, 'popstate').catch(() => { }); });\n        }\n        async _navigate(url, push, source = 'program') {\n            if (!this._routerEnabled())\n                return Promise.resolve();\n            if (!this._isSameOrigin(url)) {\n                location.assign(url);\n                return;\n            }\n            const targetURL = new URL(url);\n            const targetKey = this._normalizeDocURL(targetURL);\n            if (source !== 'popstate') {\n                if (this._isSameDocument(targetURL)) {\n                    location.href = url;\n                    return;\n                }\n            }\n            else {\n                if (this._currentDocURL && targetKey === this._currentDocURL) {\n                    this._scrollToHash(targetURL.hash);\n                    return;\n                }\n            }\n            const from = location.href;\n            try {\n                const res = await (this._config.router?.before?.(url, from, { source }));\n                if (res === false)\n                    return;\n            }\n            catch (err) {\n                try {\n                    this._config.router?.error?.(err, url, from);\n                }\n                catch { }\n                return;\n            }\n            const curKey = this._currentDocURL || this._normalizeDocURL(from);\n            this._scrollPositions.set(curKey, { x: window.scrollX || 0, y: window.scrollY || 0 });\n            try {\n                const html = await this._fetchHTML(url);\n                if (push)\n                    history.pushState({}, '', url);\n                await this._swapDocument(html);\n                this._currentDocURL = targetKey;\n                _se(() => {\n                    if (source === 'popstate') {\n                        const pos = this._scrollPositions.get(targetKey);\n                        if (pos)\n                            (window).scrollTo(pos.x, pos.y);\n                        else if (!this._scrollToHash(targetURL.hash))\n                            (window).scrollTo(0, 0);\n                    }\n                    else {\n                        if (!this._scrollToHash(targetURL.hash))\n                            (window).scrollTo(0, 0);\n                    }\n                });\n                try {\n                    await this._config.router?.after?.(url, from, { source });\n                }\n                catch { }\n            }\n            catch (err) {\n                if (err && (err.name === 'XToolRedirect' || err.message === 'XToolRedirect'))\n                    return;\n                _se(() => this._config.router?.error?.(err, url, from));\n                try {\n                    location.assign(url);\n                }\n                catch {\n                    _se(() => location.href = url);\n                }\n            }\n        }\n        async _fetchHTML(url) {\n            const res = await fetch(url, { credentials: 'same-origin', cache: 'default', redirect: 'follow' });\n            if (res.redirected) {\n                const finalUrl = res.url;\n                try {\n                    location.assign(finalUrl);\n                }\n                catch {\n                    _se(() => location.href = finalUrl);\n                }\n                const e = new Error('XToolRedirect');\n                e.name = 'XToolRedirect';\n                e.url = finalUrl;\n                throw e;\n            }\n            if (!res.ok)\n                throw new Error(res.status + ' ' + res.statusText);\n            return await res.text();\n        }\n        async _swapDocument(html) {\n            const parser = new DOMParser();\n            const doc = parser.parseFromString(html, 'text/html');\n            const newHead = doc.head;\n            const newTitle = newHead?.querySelector('title');\n            const applySwap = () => {\n                if (newTitle) {\n                    const t = newTitle.textContent || '';\n                    if (document.title !== t)\n                        document.title = t;\n                }\n                const sel = this._config.container || 'body';\n                const cur = d.querySelector(sel);\n                const next = doc.querySelector(sel);\n                if (cur && next) {\n                    this._morphElement(cur, next);\n                }\n                else if (next) {\n                    d.body.innerHTML = next.innerHTML;\n                }\n                else {\n                    d.body.innerHTML = doc.body.innerHTML;\n                }\n                this._byEl.delete(cur);\n                this._autoDiscoverComponents();\n                const c = d?.querySelector(this._config.container);\n                if (c) {\n                    this._ensureRootObserver(c);\n                    if (this._config.delegate)\n                        this._ensureDelegation(c);\n                }\n            };\n            const vt = (document).startViewTransition?.bind(document);\n            if (vt && this._getConfig().router?.transitionName) {\n                const sel = this._config.container || 'body';\n                const cont = d.querySelector(sel);\n                const prev = cont ? (cont.style.getPropertyValue('view-transition-name') || '') : '';\n                _se(() => { if (cont)\n                    cont.style.setProperty('view-transition-name', this._routerTransitionName()); });\n                try {\n                    const transition = vt(applySwap);\n                    await transition.finished;\n                }\n                finally {\n                    try {\n                        if (cont) {\n                            if (prev)\n                                cont.style.setProperty('view-transition-name', prev);\n                            else\n                                cont.style.removeProperty('view-transition-name');\n                        }\n                    }\n                    catch { }\n                }\n            }\n            else\n                applySwap();\n        }\n        _setAttributes(cur, next) {\n            const curAttrs = cur.getAttributeNames();\n            for (let i = 0; i < curAttrs.length; i++) {\n                const name = curAttrs[i];\n                if (!next.hasAttribute(name))\n                    cur.removeAttribute(name);\n            }\n            const nextAttrs = next.getAttributeNames();\n            for (let i = 0; i < nextAttrs.length; i++) {\n                const name = nextAttrs[i];\n                const val = next.getAttribute(name);\n                if (cur.getAttribute(name) !== val)\n                    cur.setAttribute(name, val);\n            }\n        }\n        _attributesEqual(a, b) {\n            const aNames = a.getAttributeNames();\n            const bNames = b.getAttributeNames();\n            if (aNames.length !== bNames.length)\n                return false;\n            const map = new Map();\n            for (let i = 0; i < aNames.length; i++) {\n                const n = aNames[i];\n                map.set(n, a.getAttribute(n));\n            }\n            for (let i = 0; i < bNames.length; i++) {\n                const n = bNames[i];\n                if (!map.has(n))\n                    return false;\n                if (map.get(n) !== b.getAttribute(n))\n                    return false;\n            }\n            return true;\n        }\n        _isDynamicNode(el) {\n            const tag = el.tagName;\n            if (tag === 'IFRAME' && el.hasAttribute('src'))\n                return true;\n            if (tag === 'COMPONENT' && el.hasAttribute('source'))\n                return true;\n            return false;\n        }\n        _morphElement(cur, next) {\n            if (cur.nodeName !== next.nodeName || this._isDynamicNode(next)) {\n                cur.replaceWith(next.cloneNode(true));\n                return;\n            }\n            this._setAttributes(cur, next);\n            if (!cur.firstChild && !next.firstChild)\n                return;\n            const curChildren = Array.from(cur.childNodes);\n            const nextChildren = Array.from(next.childNodes);\n            const max = nextChildren.length;\n            for (let i = 0; i < max; i++) {\n                const n = nextChildren[i];\n                const c = curChildren[i];\n                if (!c) {\n                    cur.appendChild(n.cloneNode(true));\n                    continue;\n                }\n                if (n.nodeType === c.nodeType) {\n                    if (n.nodeType === 3) {\n                        const a = c;\n                        const b = n;\n                        if (a.data !== b.data)\n                            a.data = b.data;\n                    }\n                    else if (n.nodeType === 1) {\n                        const cn = c;\n                        const nn = n;\n                        if (this._isDynamicNode(nn)) {\n                            try {\n                                cn.replaceWith(nn.cloneNode(true));\n                            }\n                            catch { }\n                        }\n                        else if (cn.nodeName === nn.nodeName && this._attributesEqual(cn, nn)) {\n                            this._morphElement(cn, nn);\n                        }\n                        else {\n                            try {\n                                cn.replaceWith(nn.cloneNode(true));\n                            }\n                            catch { }\n                        }\n                    }\n                    else {\n                        try {\n                            c.replaceWith(n.cloneNode(true));\n                        }\n                        catch { }\n                    }\n                }\n                else {\n                    try {\n                        c.replaceWith(n.cloneNode(true));\n                    }\n                    catch { }\n                }\n            }\n            if (curChildren.length > max) {\n                for (let i = curChildren.length - 1; i >= max; i--) {\n                    const toRemove = cur.childNodes[i];\n                    try {\n                        cur.removeChild(toRemove);\n                    }\n                    catch { }\n                }\n            }\n        }\n        _fetchAndEvalComponent(path, retries = 2, baseDelay = 300) {\n            const existing = this._inflightComponentLoads.get(path);\n            if (existing)\n                return existing;\n            const self = this;\n            const isTypeScript = /\\.ts?$/.test(new URL(path, d?.baseURI || location.href).pathname);\n            const html = (strings, ...values) => strings.reduce((acc, str, i) => acc + str + (i < values.length ? values[i] : ''), '') + `\\n`;\n            const attempt = (n) => {\n                return fetch(path, { cache: 'no-cache' }).then(res => {\n                    if (!res.ok)\n                        throw new Error(res.status + ' ' + res.statusText);\n                    return res.text();\n                }).then(code => {\n                    if (isTypeScript) {\n                        code = stripTypes(code);\n                    }\n                    const wrapped = code + `\\n//# sourceURL=${path}`;\n                    try {\n                        new Function('XTool', 'html', wrapped)(self, html);\n                    }\n                    catch (err) {\n                        console.error(`Error evaluating component script at ${path}:`, err);\n                    }\n                }).catch(err => {\n                    if (n >= retries)\n                        throw err;\n                    const delay = baseDelay * Math.pow(2, n);\n                    return new Promise(resolve => setTimeout(resolve, delay)).then(() => attempt(n + 1));\n                });\n            };\n            const p = attempt(0).finally(() => { this._inflightComponentLoads.delete(path); });\n            this._inflightComponentLoads.set(path, p);\n            return p;\n        }\n        _applyPrefixInitialCSS() {\n            if (!d)\n                return;\n            if (PFX === 'x')\n                return;\n            const id = `x-tool-initial-css-${PFX}`;\n            if (d.head && !d.getElementById(id)) {\n                const style = d.createElement(STR_STYLE);\n                style.id = id;\n                style.textContent = `[${PFX}-show],[${PFX}-if],[${PFX}-else],[${PFX}-else-if],[${PFX}\\\\:show],[${PFX}\\\\:if],[${PFX}\\\\:else],[${PFX}\\\\:else-if]{display:none;}`;\n                d.head.appendChild(style);\n            }\n        }\n        _ensureRootObserver(container) {\n            if (this._rootObserver || typeof MutationObserver === 'undefined')\n                return;\n            this._rootObserver = new MutationObserver(records => {\n                for (const r of records) {\n                    if (r.type === 'childList') {\n                        for (let i = 0; i < r.addedNodes.length; i++) {\n                            const n = r.addedNodes[i];\n                            if (n.nodeType !== 1)\n                                continue;\n                            const el = n;\n                            if (el[STR_TAGNAME] === 'COMPONENT') {\n                                const src = el.getAttribute(STR_SOURCE);\n                                if (src && !this._getComponentByElement(el))\n                                    this._instantiateNamedComponent(el);\n                            }\n                        }\n                        for (let i = 0; i < r.removedNodes.length; i++) {\n                            const n = r.removedNodes[i];\n                            if (n.nodeType !== 1)\n                                continue;\n                            const el = n;\n                            quMct(() => {\n                                if (el.isConnected)\n                                    return;\n                                const stack = [el];\n                                while (stack.length) {\n                                    const cur = stack.pop();\n                                    const comp = this._getComponentByElement(cur);\n                                    if (comp && !comp.isDestroyed) {\n                                        try {\n                                            comp.destroy();\n                                        }\n                                        catch { }\n                                    }\n                                    let child = cur.firstElementChild;\n                                    while (child) {\n                                        stack.push(child);\n                                        child = child.nextElementSibling;\n                                    }\n                                }\n                            });\n                        }\n                    }\n                    else if (r.type === 'attributes') {\n                        const target = r.target;\n                        if (target && target[STR_TAGNAME] === 'COMPONENT') {\n                            if (r.attributeName === STR_SOURCE) {\n                                this._onComponentSourceChanged(target);\n                            }\n                            else if (r.attributeName === STR_READONLY) {\n                                const comp = this._getComponentByElement(target);\n                                if (comp) {\n                                    try {\n                                        const ro = target.hasAttribute(STR_READONLY);\n                                        comp.setFrozen(!!ro);\n                                    }\n                                    catch { }\n                                }\n                            }\n                        }\n                    }\n                }\n                this._processPending();\n            });\n            this._rootObserver.observe(container, { childList: true, subtree: true, attributes: true, attributeFilter: [STR_SOURCE, STR_READONLY] });\n        }\n        _ensureIO(rootMargin) {\n            if (typeof IntersectionObserver === 'undefined')\n                return null;\n            if (!this._ioObservers)\n                this._ioObservers = new Map();\n            if (!this._ioRegistry)\n                this._ioRegistry = new WkMap();\n            const key = rootMargin || '0px';\n            let io = this._ioObservers.get(key);\n            if (io)\n                return io;\n            const handle = (entries) => {\n                for (const entry of entries) {\n                    const el = entry.target;\n                    const reg = this._ioRegistry.get(el);\n                    if (!reg)\n                        continue;\n                    const now = !!entry.isIntersecting;\n                    const before = !!reg.visible;\n                    reg.visible = now;\n                    if (now && (!before)) {\n                        const arr = reg.enter || [];\n                        for (let i = 0; i < arr.length; i++) {\n                            _se(() => arr[i].cb(entry, { phase: 'enter', visible: now, before }));\n                        }\n                        if (arr.length)\n                            reg.enter = arr.filter(a => !a.once);\n                    }\n                    else if (!now && before) {\n                        const arr = reg.leave || [];\n                        for (let i = 0; i < arr.length; i++) {\n                            _se(() => arr[i].cb(entry, { phase: 'leave', visible: now, before }));\n                        }\n                        if (arr.length)\n                            reg.leave = arr.filter(a => !a.once);\n                    }\n                }\n            };\n            io = new IntersectionObserver(handle, { root: null, rootMargin: key });\n            this._ioObservers.set(key, io);\n            return io;\n        }\n        _ioObserve(el, rootMargin, onEnter, onLeave) {\n            const io = this._ensureIO(rootMargin);\n            if (!io)\n                return () => { };\n            if (!this._ioRegistry)\n                this._ioRegistry = new WkMap();\n            let reg = this._ioRegistry.get(el);\n            if (!reg) {\n                reg = { rootMargin };\n                this._ioRegistry.set(el, reg);\n            }\n            if (onEnter && onEnter.cb) {\n                (reg.enter || (reg.enter = [])).push({ cb: onEnter.cb, once: !!onEnter.once });\n            }\n            if (onLeave && onLeave.cb) {\n                (reg.leave || (reg.leave = [])).push({ cb: onLeave.cb, once: !!onLeave.once });\n            }\n            _se(() => io.observe(el));\n            return () => { _se(() => io.unobserve(el)); };\n        }\n        _onComponentSourceChanged(el) {\n            const src = _tr(el.getAttribute('source'));\n            const existing = this._getComponentByElement(el);\n            if (!src) {\n                if (existing && !existing.isDestroyed) {\n                    try {\n                        existing.destroy();\n                    }\n                    catch { }\n                }\n                el.innerHTML = '';\n                return;\n            }\n            if (existing && !existing.isDestroyed) {\n                try {\n                    existing.destroy();\n                }\n                catch { }\n            }\n            el.innerHTML = '';\n            this._instantiateNamedComponent(el);\n        }\n        _finalizeComponentMount(el, comp, opts) {\n            comp.element = el;\n            if (opts?.callBeforeMount) {\n                _se(() => comp.callBeforeMount());\n            }\n            this._registerElement(comp.element, comp);\n            this._pending.push({ el, comp });\n            if (opts?.xInitExpr) {\n                const initExpr = opts.xInitExpr;\n                const existingMounted = comp._lifecycle?.mounted;\n                comp._lifecycle.mounted = function () {\n                    if (existingMounted) {\n                        _se(() => existingMounted.call(this));\n                    }\n                    const evaluator = new Function('ctx', 'with(ctx){' + initExpr + '} ');\n                    quMct(() => {\n                        if (comp.isDestroyed || !comp.element || !comp.element.isConnected)\n                            return;\n                        try {\n                            const ctx = comp._createMethodContext?.() || comp.getContext?.() || {};\n                            const result = evaluator(ctx);\n                            if (typeof result === 'function') {\n                                _se(() => result());\n                            }\n                        }\n                        catch { }\n                    });\n                };\n            }\n        }\n        _instantiateNamedComponent(el) {\n            const source = el.getAttribute('source');\n            if (!source)\n                return;\n            let def = this._getRegisteredComponentDef(source);\n            if (!def) {\n                const name = source.toLowerCase();\n                const lazy = this._lazyComponentSources?.get(name);\n                if (lazy) {\n                    if (lazy.status === LS_PENDING) {\n                        lazy.status = LS_LOADING;\n                        lazy.promise = this._fetchAndEvalComponent(lazy.path)\n                            .then(() => { lazy.status = LS_LOADED; })\n                            .catch(() => { lazy.status = LS_ERROR; });\n                    }\n                    lazy.promise?.then(() => { _se(() => { const again = this._getRegisteredComponentDef(source); if (again)\n                        this._instantiateNamedComponent(el); }); });\n                }\n                return;\n            }\n            let parentComp;\n            let par = el.parentElement;\n            while (par && !parentComp) {\n                const maybe = this._getComponentByElement(par);\n                if (maybe)\n                    parentComp = maybe;\n                else\n                    par = par.parentElement;\n            }\n            let props = null;\n            let dynamicPropObj = null;\n            let rawPropExpression = null;\n            if (!props)\n                props = {};\n            const propExpr = el.getAttribute(attrName('prop'));\n            if (propExpr) {\n                rawPropExpression = propExpr;\n                if (parentComp) {\n                    try {\n                        const fn = new Function('ctx', 'with(ctx){return (' + propExpr + ')}');\n                        const ctx = parentComp.getContext(true);\n                        dynamicPropObj = fn(ctx);\n                    }\n                    catch {\n                        dynamicPropObj = null;\n                    }\n                }\n                else {\n                    try {\n                        dynamicPropObj = new Function('return (' + propExpr + ')')();\n                    }\n                    catch {\n                        dynamicPropObj = null;\n                    }\n                }\n                if (dynamicPropObj && typeof dynamicPropObj === 'object')\n                    for (const k in dynamicPropObj)\n                        if (!(k in props))\n                            props[k] = String(dynamicPropObj[k]);\n                el.removeAttribute(attrName('prop'));\n            }\n            let baseData = {};\n            if (def.makeData) {\n                _se(() => { const result = def.makeData(props); if (result)\n                    baseData = result; });\n            }\n            if (def.data) {\n                for (const k in def.data) {\n                    baseData[k] = def.data[k];\n                }\n            }\n            for (const k in props) {\n                if (!(k in baseData))\n                    baseData[k] = props[k];\n            }\n            baseData.$props = props;\n            let initDef;\n            if (typeof def.init === 'function') {\n                try {\n                    const maybe = def.init(props);\n                    initDef = (maybe && typeof maybe === 'object') ? maybe : undefined;\n                }\n                catch {\n                    initDef = undefined;\n                }\n            }\n            const compDef = {\n                data: baseData,\n                methods: { ...(def.methods || {}), ...(initDef?.methods || {}) },\n                computed: { ...(def.computed || {}), ...(initDef?.computed || {}) },\n                propEffects: { ...(def.propEffects || {}), ...(initDef?.propEffects || {}) },\n                mounted: initDef?.mounted || def.mounted,\n                unmounted: initDef?.unmounted || def.unmounted,\n                beforeMount: initDef?.beforeMount || def.beforeMount,\n                beforeUnmount: initDef?.beforeUnmount || def.beforeUnmount,\n                updated: initDef?.updated || def.updated,\n                destroyed: initDef?.destroyed || def.destroyed,\n                beforeDestroy: initDef?.beforeDestroy || def.beforeDestroy\n            };\n            const comp = this.createComponent(compDef);\n            const originalChildren = Array.from(el.childNodes);\n            if (originalChildren.length)\n                el.replaceChildren();\n            if (def.template) {\n                const applyTemplate = (tpl) => {\n                    el.innerHTML = tpl;\n                    const slots = el.querySelectorAll('slot');\n                    if (slots.length) {\n                        for (const slotEl of slots) {\n                            const name = slotEl.getAttribute('name');\n                            const matched = name\n                                ? originalChildren.filter(n => n.nodeType === 1 && n.getAttribute('slot') === name)\n                                : originalChildren.filter(n => n.nodeType !== 1 || !n.hasAttribute('slot'));\n                            if (matched.length)\n                                slotEl.replaceWith(...matched);\n                        }\n                    }\n                };\n                const tplVal = def.template;\n                if (typeof tplVal === 'string') {\n                    applyTemplate(tplVal);\n                }\n                else if (typeof tplVal === 'function') {\n                    try {\n                        const res = tplVal();\n                        if (res && typeof res.then === 'function') {\n                            el.innerHTML = '';\n                            res.then(html => { applyTemplate(html || ''); _se(() => comp._applyAsyncTemplateResolved()); });\n                        }\n                        else {\n                            applyTemplate(String(res || ''));\n                        }\n                    }\n                    catch {\n                        el.innerHTML = '';\n                    }\n                }\n                else if (tplVal && typeof tplVal.then === 'function') {\n                    el.innerHTML = '';\n                    tplVal.then(html => { applyTemplate(html || ''); _se(() => comp._applyAsyncTemplateResolved()); });\n                }\n            }\n            else {\n                if (originalChildren.length)\n                    el.append(...originalChildren);\n            }\n            this._finalizeComponentMount(el, comp, { callBeforeMount: false });\n            try {\n                const nested = el.querySelectorAll(`[${attrName('data')}]`);\n                for (const node of nested) {\n                    if (!this._getComponentByElement(node))\n                        this._bindElementAsComponent(node, comp);\n                }\n            }\n            catch { }\n            if (rawPropExpression && parentComp) {\n                _se(() => comp._initReactiveProps(rawPropExpression, parentComp));\n            }\n            this._processPending();\n        }\n        _getComponentByElement(element) { return this._byEl.get(element); }\n        observe(_element) { }\n        _ensureDelegation(container) {\n            if (this._delegatedRootBound)\n                return;\n            const root = container;\n            const handler = (e) => {\n                let cur = e.target;\n                while (cur && cur !== root.parentElement) {\n                    if (e.cancelBubble)\n                        break;\n                    const map = this._delegated.get(cur);\n                    if (map) {\n                        const list = map.get(e.type);\n                        if (list && list.length) {\n                            for (const h of [...list]) {\n                                try {\n                                    if (h.comp && h.comp.isDestroyed) {\n                                        const i = list.indexOf(h);\n                                        if (i > -1)\n                                            list.splice(i, 1);\n                                        continue;\n                                    }\n                                    if (!h.filter || h.filter(e)) {\n                                        h.run(e);\n                                        if (h.once) {\n                                            const idx = list.indexOf(h);\n                                            if (idx > -1)\n                                                list.splice(idx, 1);\n                                        }\n                                    }\n                                }\n                                catch { }\n                            }\n                        }\n                    }\n                    cur = cur.parentElement;\n                }\n            };\n            const captureEvents = ['keydown', 'keyup'];\n            const bubbleEvents = ['click', 'input', 'change'];\n            for (const ev of captureEvents)\n                root.addEventListener(ev, handler, true);\n            for (const ev of bubbleEvents)\n                root.addEventListener(ev, handler, false);\n            this._delegatedRootBound = true;\n        }\n        _registerDelegated(element, event, entry) {\n            let map = this._delegated.get(element);\n            if (!map) {\n                map = new Map();\n                this._delegated.set(element, map);\n            }\n            let list = map.get(event);\n            if (!list) {\n                list = [];\n                map.set(event, list);\n            }\n            list.push(entry);\n            return () => {\n                try {\n                    const m = this._delegated.get(element);\n                    const l = m?.get(event);\n                    if (!l)\n                        return;\n                    const idx = l.indexOf(entry);\n                    if (idx > -1)\n                        l.splice(idx, 1);\n                }\n                catch { }\n            };\n        }\n    }\n    class ReactiveComponent {\n        attachToParent(parent) {\n            this._parent = parent;\n            parent._addChild(this);\n        }\n        get id() { return this._id; }\n        get framework() { return this._framework; }\n        get element() { return this._element; }\n        set element(el) { this._element = el; }\n        get isBound() { return this._isBound; }\n        set isBound(v) { this._isBound = v; }\n        get isMounted() { return this._isMounted; }\n        set isMounted(v) { this._isMounted = v; }\n        get isDestroyed() { return this._isDestroyed; }\n        set isDestroyed(v) { this._isDestroyed = v; }\n        _abortInvokerResources() {\n            for (const byKind of this._invokerResources.values()) {\n                for (const cleanup of byKind.values()) {\n                    _se(cleanup);\n                }\n            }\n            this._invokerResources.clear();\n        }\n        _cancelUserResources() {\n            this._abortInvokerResources();\n        }\n        _resolveBindingMeta(element, attributeName) {\n            const elAny = element;\n            let propName = attributeName in elAny ? attributeName : null;\n            if (!propName) {\n                const camel = attributeName.replace(/-([a-z])/g, (_, c) => c.toUpperCase());\n                propName = camel in elAny ? camel : (attributeName.toLowerCase() === 'readonly' && 'readOnly' in elAny ? 'readOnly' : null);\n            }\n            const isBooleanProp = !!(propName && typeof elAny[propName] === 'boolean');\n            const hasNonFunctionProp = !!(propName && typeof elAny[propName] !== 'function');\n            const isKnownBooleanAttr = !!ReactiveComponent._BA[attributeName.toLowerCase()];\n            return { elAny, propName, isBooleanProp, hasNonFunctionProp, isKnownBooleanAttr };\n        }\n        _applyGenericBinding(element, attributeName, value, meta) {\n            const { elAny, propName, isBooleanProp, hasNonFunctionProp, isKnownBooleanAttr } = meta;\n            if ((isBooleanProp && propName) || isKnownBooleanAttr) {\n                const boolVal = !!value;\n                if (propName && isBooleanProp)\n                    elAny[propName] = boolVal;\n                if (boolVal)\n                    element.setAttribute(attributeName, '');\n                else\n                    element.removeAttribute(attributeName);\n                return;\n            }\n            let normalized = null;\n            if (value && typeof value === 'object') {\n                const parts = [];\n                for (const k in value) {\n                    if (value[k])\n                        parts.push(k);\n                }\n                normalized = parts.length ? parts.join(' ') : null;\n            }\n            else if (value !== null && value !== undefined) {\n                normalized = String(value);\n            }\n            if (hasNonFunctionProp && propName) {\n                if (normalized !== null) {\n                    try {\n                        elAny[propName] = normalized;\n                    }\n                    catch {\n                        try {\n                            element.setAttribute(attributeName, normalized);\n                        }\n                        catch { }\n                    }\n                }\n                else {\n                    element.removeAttribute(attributeName);\n                }\n                return;\n            }\n            if (normalized !== null) {\n                const cur = element.getAttribute(attributeName);\n                if (cur !== normalized)\n                    element.setAttribute(attributeName, normalized);\n            }\n            else {\n                element.removeAttribute(attributeName);\n            }\n        }\n        _scanDirectiveAttrs(el, opts) {\n            const prefixDash = PFX + '-';\n            const prefixColon = PFX + ':';\n            const namesOut = [];\n            let hasTextOrHtml = false;\n            let forName = null;\n            const names = el.getAttributeNames();\n            for (let i = 0; i < names.length; i++) {\n                const name = names[i];\n                const isDir = name.startsWith(prefixDash) || name.startsWith(prefixColon) || name.startsWith('@');\n                if (!isDir)\n                    continue;\n                if (opts?.skipRootFor && name === attrName('for'))\n                    continue;\n                namesOut.push(name);\n                if (!hasTextOrHtml && (name === attrName('text') || name === attrName('html')))\n                    hasTextOrHtml = true;\n                if (!forName && name === attrName('for'))\n                    forName = name;\n            }\n            return { names: namesOut, hasTextOrHtml, forName };\n        }\n        setFrozen(on) {\n            if (on === this._isFrozen)\n                return;\n            this._isFrozen = on;\n            if (on) {\n                this._sealedBeforeFreeze = this._isSealed;\n                this._isSealed = true;\n                this._cancelUserResources();\n            }\n            else {\n                if (this._sealedBeforeFreeze !== null) {\n                    this._isSealed = this._sealedBeforeFreeze;\n                }\n                else {\n                    this._isSealed = false;\n                }\n                this._sealedBeforeFreeze = null;\n                try {\n                    this._scheduleRender();\n                }\n                catch { }\n            }\n        }\n        _setSealed(on) {\n            if (on === this._isSealed)\n                return;\n            this._isSealed = on;\n            if (on) {\n                this._cancelUserResources();\n            }\n        }\n        _addDirective(element, directive) {\n            const existing = this._directives.get(element) || [];\n            existing.push(directive);\n            this._directives.set(element, existing);\n        }\n        constructor(id, def, framework) {\n            this._propUpdateActive = false;\n            this._runningPropEffect = false;\n            this._element = null;\n            this._isBound = false;\n            this._isMounted = false;\n            this._isDestroyed = false;\n            this._beforeMountCalled = false;\n            this._children = [];\n            this._parent = null;\n            this._computed = {};\n            this._propEffects = {};\n            this._computedCache = new Map();\n            this._computedDeps = new Map();\n            this._computedKeyStack = [];\n            this._isInComputedEvaluation = false;\n            this._isInMethodExecution = false;\n            this._allEffects = new Set();\n            this._hasComputed = false;\n            this._directives = new Map();\n            this._cleanupFunctions = new Set();\n            this._directiveAbort = new AbortController();\n            this._invokerResources = new Map();\n            this._targetIds = new WkMap();\n            this._targetSeq = 0;\n            this._isSealed = false;\n            this._isFrozen = false;\n            this._sealedBeforeFreeze = null;\n            this._isMutationEnabled = true;\n            this._effectsToRun = new Set();\n            this._currentInvoker = null;\n            this._loopScopes = new WkMap();\n            this._expressionCache = new Map();\n            this._propertyDependencies = new Map();\n            this._activeEffect = null;\n            this._renderScheduled = false;\n            this._nextTickQueue = [];\n            this._changeFrameId = null;\n            this._renderFrameId = null;\n            this._initialClassSets = new WkMap();\n            this._rawData = {};\n            this._propParent = null;\n            this._callLifecycleHook = (hookName) => {\n                const hook = this._lifecycle[hookName];\n                if (typeof hook === 'function') {\n                    this._safeExecute(() => this._runWithGlobalInterception(hook, []));\n                }\n            };\n            this._addCleanupFunction = (fn) => {\n                if (typeof fn !== 'function')\n                    return undefined;\n                const wrapped = () => {\n                    try {\n                        fn();\n                    }\n                    catch { }\n                    this._cleanupFunctions.delete(wrapped);\n                };\n                this._cleanupFunctions.add(wrapped);\n                return () => { this._cleanupFunctions.delete(wrapped); };\n            };\n            this._id = id;\n            this._framework = framework;\n            this._originalMethods = def.methods || {};\n            this._computed = this._bindComputed(def.computed || {});\n            this._propEffects = def.propEffects || {};\n            if (this._propEffects && Object.keys(this._propEffects).length) {\n                this._propEffects = this._bindPropEffects();\n            }\n            this._hasComputed = !!(def.computed && Object.keys(def.computed).length);\n            this._lifecycle = {\n                mounted: def.mounted,\n                unmounted: def.unmounted || def.destroyed,\n                updated: def.updated,\n                beforeMount: def.beforeMount,\n                beforeUnmount: def.beforeUnmount || def.beforeDestroy\n            };\n            this._rawData = this._cloneData(def.data || {});\n            this._data = this._createReactiveData(this._rawData || {});\n            this._methods = this._bindMethods();\n        }\n        _cloneData(value, seen) {\n            if (value === null || typeof value !== 'object')\n                return value;\n            const s = seen || new WeakMap();\n            if (s.has(value))\n                return s.get(value);\n            if (ARRAY_ISARRAY(value)) {\n                const arr = [];\n                s.set(value, arr);\n                for (let i = 0; i < value.length; i++)\n                    arr[i] = this._cloneData(value[i], s);\n                return arr;\n            }\n            if (value instanceof Date)\n                return new Date(value.getTime());\n            if (value instanceof RegExp)\n                return new RegExp(value.source, value.flags);\n            if (typeof Map !== 'undefined' && value instanceof Map) {\n                const m = new Map();\n                s.set(value, m);\n                value.forEach((v, k) => { m.set(this._cloneData(k, s), this._cloneData(v, s)); });\n                return m;\n            }\n            if (typeof Set !== 'undefined' && value instanceof Set) {\n                const st = new Set();\n                s.set(value, st);\n                value.forEach(v => st.add(this._cloneData(v, s)));\n                return st;\n            }\n            const proto = Object.getPrototypeOf(value);\n            if (proto === Object.prototype || proto === null) {\n                const out = Object.create(proto);\n                s.set(value, out);\n                for (const key of Object.keys(value)) {\n                    out[key] = this._cloneData(value[key], s);\n                }\n                return out;\n            }\n            return value;\n        }\n        callBeforeMount() {\n            if (!this._beforeMountCalled) {\n                this._callLifecycleHook('beforeMount');\n                this._beforeMountCalled = true;\n            }\n        }\n        _onDataChange(_property) {\n            if (!this.isBound)\n                return;\n            const self = this;\n            if (self._changeFrameId != null) {\n                _se(() => cancelAnimationFrame(self._changeFrameId));\n                self._changeFrameId = null;\n            }\n            if (this._isMutationEnabled === false)\n                return;\n            const effectsToRun = self._effectsToRun;\n            const directDeps = self._propertyDependencies.get(_property);\n            if (directDeps) {\n                for (let i = 0; i < directDeps.length; i++)\n                    effectsToRun.add(directDeps[i]);\n            }\n            if (FT_C && self._computedDeps.size) {\n                const queue = [_property];\n                const visited = new Set();\n                const affectedComputed = new Set();\n                let queueIdx = 0;\n                while (queueIdx < queue.length) {\n                    const base = queue[queueIdx++];\n                    if (visited.has(base))\n                        continue;\n                    visited.add(base);\n                    for (const [compKey, baseDeps] of self._computedDeps.entries()) {\n                        if (baseDeps.has(base) && !affectedComputed.has(compKey)) {\n                            affectedComputed.add(compKey);\n                            queue.push(compKey);\n                        }\n                    }\n                }\n                for (const compKey of affectedComputed) {\n                    const compEffects = self._propertyDependencies.get(compKey);\n                    if (compEffects) {\n                        for (let i = 0; i < compEffects.length; i++)\n                            effectsToRun.add(compEffects[i]);\n                    }\n                    self._computedCache.delete(compKey);\n                }\n            }\n            self._changeFrameId = requestAnimationFrame(() => {\n                if (FT_C)\n                    self._computedCache.clear();\n                self._changeFrameId = null;\n                if (self.isDestroyed || self._isSealed)\n                    return;\n                for (const effect of effectsToRun)\n                    self._safeExecute(effect);\n                effectsToRun.clear();\n                if (!directDeps?.length && (self._hasComputed || !XTOOL_ENABLE_STATIC_DIRECTIVES)) {\n                    self._scheduleRender();\n                }\n                self._callLifecycleHook('updated');\n            });\n        }\n        _bindMethods() {\n            return this._bindFunctionMap(this._originalMethods, 'methods');\n        }\n        _bindComputed(src) {\n            return this._bindFunctionMap(src, 'computed');\n        }\n        _bindPropEffects() {\n            return this._bindFunctionMap(this._propEffects || {}, 'prop');\n        }\n        _bindFunctionMap(src, kind) {\n            const out = {};\n            const isNative = (fn) => /\\[native code\\]/.test(String(fn));\n            const makeNoArgCtxRunner = (fn) => {\n                try {\n                    if (!isNative(fn)) {\n                        let body = String(fn).trim();\n                        if (!/^function[\\s\\(]/.test(body) && !/^[\\w\\$_][\\w\\d\\$_]*\\s*=>/.test(body) && !/^\\(.*?\\)\\s*=>/.test(body)) {\n                            body = 'function ' + body;\n                        }\n                        const compiled = new Function('ctx', `with(ctx){ const f = (${body}); return f.apply(this, []); }`);\n                        return () => { const ctx = this._createMethodContext(); return compiled.call(ctx, ctx); };\n                    }\n                }\n                catch { }\n                return () => fn.call(this._createMethodContext());\n            };\n            for (const key in (src || {})) {\n                const original = src[key];\n                if (typeof original !== 'function')\n                    continue;\n                if (kind === 'computed') {\n                    out[key] = makeNoArgCtxRunner(original);\n                }\n                else if (kind === 'methods') {\n                    out[key] = (...args) => {\n                        const prev = this._isInMethodExecution;\n                        const prevInv = this._currentInvoker;\n                        this._isInMethodExecution = true;\n                        this._currentInvoker = key;\n                        try {\n                            return this._safeExecute(() => this._runWithGlobalInterception(original, args));\n                        }\n                        finally {\n                            this._isInMethodExecution = prev;\n                            this._currentInvoker = prevInv;\n                        }\n                    };\n                }\n                else {\n                    out[key] = (newValue, oldValue) => {\n                        const prevInv = this._currentInvoker;\n                        const prevFlag = this._runningPropEffect;\n                        this._currentInvoker = `prop:${key}`;\n                        this._runningPropEffect = true;\n                        try {\n                            return this._safeExecute(() => this._runWithGlobalInterception(original, [newValue, oldValue]));\n                        }\n                        finally {\n                            this._runningPropEffect = prevFlag;\n                            this._currentInvoker = prevInv;\n                        }\n                    };\n                }\n            }\n            return out;\n        }\n        _getComputedValue(key) {\n            if (!FT_C)\n                return undefined;\n            this._trackDependency(key);\n            if (this._computedCache.has(key))\n                return this._computedCache.get(key);\n            this._isInComputedEvaluation = true;\n            this._computedKeyStack.push(key);\n            this._computedDeps.set(key, new Set());\n            try {\n                const getter = this._computed[key];\n                const value = typeof getter === 'function' ? getter() : undefined;\n                this._computedKeyStack.pop();\n                this._isInComputedEvaluation = this._computedKeyStack.length > 0;\n                this._computedCache.set(key, value);\n                return value;\n            }\n            catch (e) {\n                this._computedKeyStack.pop();\n                this._isInComputedEvaluation = this._computedKeyStack.length > 0;\n                return undefined;\n            }\n        }\n        _trackDependency(propKey) {\n            const activeEff = this._activeEffect;\n            if (!activeEff)\n                return;\n            let deps = this._propertyDependencies.get(propKey);\n            if (!deps) {\n                deps = [];\n                this._propertyDependencies.set(propKey, deps);\n            }\n            if (!deps.includes(activeEff))\n                deps.push(activeEff);\n            const stackLen = this._computedKeyStack.length;\n            if (this._isInComputedEvaluation && stackLen) {\n                const current = this._computedKeyStack[stackLen - 1];\n                let s = this._computedDeps.get(current);\n                if (!s) {\n                    s = new Set();\n                    this._computedDeps.set(current, s);\n                }\n                s.add(propKey);\n            }\n        }\n        _scheduleRender() {\n            if (this._isSealed || this._isFrozen || this._isDestroyed || this._renderScheduled)\n                return;\n            this._renderScheduled = true;\n            requestAnimationFrame(() => {\n                this._renderFrameId = null;\n                this._renderScheduled = false;\n                if (this._isDestroyed || this._isSealed) {\n                    if (this._nextTickQueue?.length)\n                        this._nextTickQueue.length = 0;\n                    return;\n                }\n                this._render();\n                if (this._nextTickQueue?.length) {\n                    const q = this._nextTickQueue.splice(0);\n                    for (const fn of q) {\n                        _se(fn);\n                    }\n                }\n            });\n        }\n        _safeExecute(fn, fallback) {\n            try {\n                return fn();\n            }\n            catch (error) {\n                console.error(error);\n                return fallback;\n            }\n        }\n        bindToElement(element) {\n            if (this._isBound)\n                return;\n            this._element = element;\n            if (!this._beforeMountCalled) {\n                this.callBeforeMount();\n            }\n            this.completeBinding();\n        }\n        getContext(includeComputed = true) {\n            return this._createMethodContext(includeComputed);\n        }\n        _applyAsyncTemplateResolved() {\n            if (!this._element)\n                return;\n            try {\n                this._parseDirectives(this._element);\n            }\n            catch { }\n            this._scheduleRender();\n        }\n        completeBinding() {\n            if (this._isBound || !this._element)\n                return;\n            if (!this._framework._getComponentByElement(this._element))\n                this._framework._registerElement(this._element, this);\n            this._isBound = true;\n            this._isMounted = true;\n            this._parseDirectives(this._element);\n            this._render();\n            this._callLifecycleHook('mounted');\n        }\n        _addChild(child) {\n            if (!this._children.includes(child)) {\n                this._children.push(child);\n            }\n        }\n        _removeChild(child) {\n            const index = this._children.indexOf(child);\n            if (index > -1) {\n                this._children.splice(index, 1);\n            }\n        }\n        _runWithGlobalInterception(fn, args) {\n            try {\n                const src = String(fn);\n                if (!/\\[native code\\]/.test(src)) {\n                    let body = src.trim();\n                    if (!/^function[\\s\\(]/.test(body) && !/^[\\w\\$_][\\w\\d\\$_]*\\s*=>/.test(body) && !/^\\(.*?\\)\\s*=>/.test(body)) {\n                        body = 'function ' + body;\n                    }\n                    const trySrc = 'with(ctx){ const f = (' + body + '); return f.apply(thisArg, argsArray); }';\n                    const wrapper = new Function('thisArg', 'argsArray', 'ctx', trySrc);\n                    const thisArg = this._createMethodContext();\n                    return wrapper.call(thisArg, thisArg, args, this._createContextProxy(undefined, undefined));\n                }\n            }\n            catch {\n            }\n            return fn.apply(this._createMethodContext(), args);\n        }\n        destroy() {\n            const self = this;\n            if (self._isDestroyed)\n                return;\n            self._callLifecycleHook('beforeUnmount');\n            for (const child of self._children) {\n                if (!child.isDestroyed)\n                    child.destroy();\n            }\n            if (self._parent) {\n                self._parent._removeChild(self);\n            }\n            for (const [element, directives] of self._directives) {\n                for (const directive of directives) {\n                    if (directive.type === 'custom' && directive.customDirective?.unbind) {\n                        _se(() => directive.customDirective.unbind(element, self));\n                    }\n                }\n            }\n            self._directives.clear();\n            try {\n                self._directiveAbort.abort();\n            }\n            catch { }\n            self._directiveAbort = new AbortController();\n            self._abortInvokerResources();\n            self._runCleanupCallbacks();\n            self._computedCache.clear();\n            self._expressionCache.clear();\n            self._propertyDependencies.clear();\n            if (self._propParent && self._propEffect) {\n                for (const deps of self._propParent._propertyDependencies.values()) {\n                    const idx = deps.indexOf(self._propEffect);\n                    if (idx > -1)\n                        deps.splice(idx, 1);\n                }\n            }\n            if (self._element)\n                self._framework._unregisterElement(self._element);\n            if (self._changeFrameId != null) {\n                _se(() => cancelAnimationFrame(self._changeFrameId));\n                self._changeFrameId = null;\n            }\n            if (self._renderFrameId != null) {\n                _se(() => cancelAnimationFrame(self._renderFrameId));\n                self._renderFrameId = null;\n            }\n            self._callLifecycleHook('unmounted');\n            self._isDestroyed = true;\n            self._isMounted = false;\n            self._isBound = false;\n            self._children = [];\n            self._parent = null;\n            self._deepReactiveCache = new WkMap;\n            self._effectsToRun.clear();\n            self._element = null;\n            quMct(() => self._framework._unregisterComponent(self._id));\n            self._data = {};\n            self._rawData = {};\n            self._methods = {};\n            self._computed = {};\n            self._propEffects = {};\n            self._activeEffect = null;\n        }\n        _initReactiveProps(expr, parent) {\n            if (!expr || !parent)\n                return;\n            this._propParent = parent;\n            let evalFn;\n            try {\n                evalFn = new Function('ctx', 'with(ctx){return (' + expr + ')}');\n            }\n            catch {\n                return;\n            }\n            const update = () => {\n                parent._activeEffect = update;\n                let obj;\n                try {\n                    const ctx = parent.getContext(true);\n                    obj = evalFn(ctx);\n                }\n                catch {\n                    obj = null;\n                }\n                parent._activeEffect = null;\n                if (obj && typeof obj === 'object') {\n                    this._data.$props = this._data.$props || {};\n                    this._propUpdateActive = true;\n                    for (const k in obj) {\n                        const v = obj[k];\n                        if (this._data[k] !== v)\n                            this._data[k] = v;\n                    }\n                    this._propUpdateActive = false;\n                }\n            };\n            this._propEffect = update;\n            update();\n        }\n        _runCleanupCallbacks() {\n            for (const fn of this._cleanupFunctions) {\n                _se(fn);\n            }\n            this._cleanupFunctions.clear();\n        }\n        _listen(element, event, handler, options) {\n            const signal = this._directiveAbort.signal;\n            if (typeof options === 'boolean') {\n                element.addEventListener(event, handler, { capture: options, signal });\n            }\n            else if (options) {\n                const merged = options.signal && options.signal !== signal\n                    ? options\n                    : { ...options, signal };\n                element.addEventListener(event, handler, merged);\n            }\n            else {\n                element.addEventListener(event, handler, { signal });\n            }\n        }\n        _targetKey(target) {\n            let id = this._targetIds.get(target);\n            if (!id) {\n                id = (++this._targetSeq).toString(36);\n                this._targetIds.set(target, id);\n            }\n            return id;\n        }\n        _parseDirectives(element) {\n            const self = this;\n            let processedElements = 0;\n            const processElement = (el, isRoot = false) => {\n                if (!isRoot && (el.hasAttribute(attrName('data')) || this._framework._getComponentByElement(el))) {\n                    return false;\n                }\n                const isComponentTag = el[STR_TAGNAME] === 'COMPONENT';\n                const { names: directiveNames, hasTextOrHtml, forName } = self._scanDirectiveAttrs(el);\n                if (directiveNames.length > 0) {\n                    processedElements++;\n                    if (forName) {\n                        self._bindDirective(el, forName, el.getAttribute(forName) || '');\n                        return false;\n                    }\n                    for (const attr of directiveNames) {\n                        self._bindDirective(el, attr, el.getAttribute(attr) || '');\n                    }\n                }\n                if (FT_TI && !hasTextOrHtml)\n                    self._bindTextInterpolationsIn(el);\n                return isRoot || !isComponentTag;\n            };\n            processElement(element, true);\n            self._walkElements(element, processElement);\n        }\n        _bindTextInterpolationsIn(el) {\n            const nodes = Array.from(el.childNodes);\n            for (const node of nodes) {\n                if (node.nodeType !== Node.TEXT_NODE)\n                    continue;\n                const textNode = node;\n                const raw = textNode.nodeValue || '';\n                if (textNode.__x_ti_bound || raw.indexOf('{{') === -1)\n                    continue;\n                const segs = [];\n                let i = 0;\n                while (i < raw.length) {\n                    const ch = raw.charCodeAt(i);\n                    if (ch === 92) {\n                        let run = 0;\n                        const start = i;\n                        while (i < raw.length && raw.charCodeAt(i) === 92) {\n                            run++;\n                            i++;\n                        }\n                        if (raw.startsWith('{{', i)) {\n                            const close = raw.indexOf('}}', i + 2);\n                            if (close === -1) {\n                                segs.push({ type: 'lit', text: raw.slice(start) });\n                                break;\n                            }\n                            if (run > 1)\n                                segs.push({ type: 'lit', text: '\\\\'.repeat(run - 1) });\n                            segs.push({ type: 'lit', text: raw.slice(i, close + 2) });\n                            i = close + 2;\n                            continue;\n                        }\n                        segs.push({ type: 'lit', text: raw.slice(start, i) });\n                        continue;\n                    }\n                    if (raw.startsWith('{{', i)) {\n                        const close = raw.indexOf('}}', i + 2);\n                        if (close === -1) {\n                            segs.push({ type: 'lit', text: raw.slice(i) });\n                            break;\n                        }\n                        const expr = raw.slice(i + 2, close).trim();\n                        if (expr.length === 0)\n                            segs.push({ type: 'lit', text: '{{}}' });\n                        else\n                            segs.push({ type: 'expr', code: expr });\n                        i = close + 2;\n                        continue;\n                    }\n                    const nextEsc = raw.indexOf('\\\\', i);\n                    const nextOpen = raw.indexOf('{{', i);\n                    let end = raw.length;\n                    if (nextEsc !== -1 && nextEsc < end)\n                        end = nextEsc;\n                    if (nextOpen !== -1 && nextOpen < end)\n                        end = nextOpen;\n                    segs.push({ type: 'lit', text: raw.slice(i, end) });\n                    i = end;\n                }\n                const hasExpr = segs.some(s => s.type === 'expr');\n                if (!hasExpr) {\n                    textNode.__x_ti_bound = true;\n                    const literalOut = segs.map(s => s.text || '').join('');\n                    if (textNode.textContent !== literalOut)\n                        textNode.textContent = literalOut;\n                    continue;\n                }\n                const evaluators = [];\n                for (const s of segs)\n                    if (s.type === 'expr')\n                        evaluators.push(this._createElementEvaluator(s.code, el));\n                textNode.__x_ti_bound = true;\n                const update = () => {\n                    let out = '';\n                    let ei = 0;\n                    for (const s of segs) {\n                        if (s.type === 'lit')\n                            out += s.text;\n                        else {\n                            const v = evaluators[ei++]();\n                            out += (v == null ? '' : String(v));\n                        }\n                    }\n                    if (textNode.textContent !== out)\n                        textNode.textContent = out;\n                };\n                const dirInfo = { type: 'text-interpolation', expression: raw, update: undefined };\n                this._addDirective(el, dirInfo);\n                const effect = this._createEffect(update, dirInfo);\n                dirInfo.update = effect;\n            }\n        }\n        _walkElements(parent, processor) {\n            let child = parent.firstElementChild;\n            while (child) {\n                const next = child.nextElementSibling;\n                if (processor(child))\n                    this._walkElements(child, processor);\n                child = next;\n            }\n        }\n        _bindDirective(element, directiveName, expression) {\n            const self = this;\n            const isAtEvent = directiveName.startsWith('@');\n            const isShortBind = directiveName.startsWith(PFX + ':');\n            const type = isAtEvent ? ('on:' + directiveName.slice(1)) : directiveName.slice(PFX.length + 1);\n            if (!isAtEvent && (isShortBind || type === 'class' || type === STR_STYLE)) {\n                element.removeAttribute(directiveName);\n                return self._bindAttributeDirective(element, type, expression);\n            }\n            if (!isAtEvent && (type === 'text' || type === 'html' || type === 'show')) {\n                element.removeAttribute(directiveName);\n                return self._bindSimpleDirective(element, expression, type);\n            }\n            const handled = (!isAtEvent && type === 'model') ? (element.removeAttribute(directiveName), self._bindModelDirective(element, expression), true)\n                : type === 'if' ? (element.removeAttribute(directiveName), self._bindIfDirective(element, expression), true)\n                    : type === 'for' ? (element.removeAttribute(directiveName), self._bindForDirective(element, expression), true)\n                        : false;\n            if (handled)\n                return;\n            if (isAtEvent || type.indexOf(':') > -1) {\n                const [prefix, rest] = type.split(':', 2);\n                const [suffix, ...mods] = rest.split('.');\n                const modifiers = mods.reduce((acc, m) => { if (m)\n                    acc[m] = true; return acc; }, {});\n                if (prefix === 'on') {\n                    element.removeAttribute(directiveName);\n                    const customDirective = self.framework._getCustomDirective(suffix);\n                    return customDirective\n                        ? self._bindCustomDirective(element, suffix, expression, customDirective, modifiers)\n                        : self._bindEventDirective(element, suffix, expression, modifiers);\n                }\n                if (prefix === 'intersect') {\n                    element.removeAttribute(directiveName);\n                    return self._bindIntersectDirective(element, expression, modifiers, suffix);\n                }\n                element.removeAttribute(directiveName);\n                return self._bindAttributeDirective(element, suffix, expression);\n            }\n        }\n        _bindIntersectDirective(element, expression, modifiers, phase) {\n            const self = this;\n            const trimmed = _tr(expression);\n            const runExpr = self._compileHandler(trimmed, element, (payload) => [payload, element]);\n            const run = (payload) => { if (runExpr)\n                runExpr(payload); };\n            const once = !!modifiers['once'];\n            let rootMargin = '0px';\n            for (const m in modifiers) {\n                if (m.startsWith('rootMargin-')) {\n                    rootMargin = m.slice('rootMargin-'.length);\n                    break;\n                }\n            }\n            const onEnter = phase === 'enter' ? { cb: (entry, info) => run({ entry, ...info }), once } : undefined;\n            const onLeave = phase === 'leave' ? { cb: (entry, info) => run({ entry, ...info }), once } : undefined;\n            const unobserve = this.framework._ioObserve(element, rootMargin, onEnter, onLeave);\n            const dir = { type: 'intersect', expression };\n            this._addDirective(element, dir);\n            this._addCleanupFunction(() => { try {\n                unobserve();\n            }\n            catch { } });\n        }\n        _createEffect(updateFn, directiveRef) {\n            const effect = () => {\n                this._activeEffect = effect;\n                try {\n                    updateFn();\n                }\n                finally {\n                    this._activeEffect = null;\n                }\n            };\n            effect();\n            this._allEffects.add(effect);\n            if (XTOOL_ENABLE_STATIC_DIRECTIVES && directiveRef && directiveRef._static === undefined) {\n                let found = false;\n                for (const deps of this._propertyDependencies.values()) {\n                    if (deps.includes(effect)) {\n                        found = true;\n                        break;\n                    }\n                }\n                directiveRef._static = !found;\n            }\n            return effect;\n        }\n        _bindSimpleDirective(element, expression, type) {\n            if (type === 'class' || type === STR_STYLE) {\n                return this._bindAttributeDirective(element, type, expression);\n            }\n            const evaluator = this._createElementEvaluator(expression, element);\n            let originalDisplay;\n            if (type === 'show') {\n                const el = element;\n                originalDisplay = el.style[STR_DISPLAY] !== STR_NONE ? el.style[STR_DISPLAY] : undefined;\n            }\n            let _prevShown = undefined;\n            const update = () => {\n                const value = evaluator();\n                const el = element;\n                switch (type) {\n                    case 'text':\n                        el.textContent = String(value);\n                        break;\n                    case 'html':\n                        el.innerHTML = String(value || '');\n                        break;\n                    case 'show':\n                        const next = !!value;\n                        if (_prevShown === next)\n                            return;\n                        _prevShown = next;\n                        el.style[STR_DISPLAY] = next ? (originalDisplay || '') : STR_NONE;\n                        break;\n                }\n            };\n            const dirInfo = { type, expression, update: undefined, originalDisplay };\n            this._addDirective(element, dirInfo);\n            const effect = this._createEffect(update, dirInfo);\n            dirInfo.update = effect;\n        }\n        _bindModelDirective(element, property) {\n            const isCheckbox = element.type === 'checkbox';\n            const isNumeric = element.type === 'number' || element.type === 'range';\n            const isMultiSelect = element.tagName === 'SELECT' && element.multiple === true;\n            if (!(property in this._data)) {\n                this._data[property] = undefined;\n            }\n            const getValueEvaluator = this._createElementEvaluator(property, element);\n            const setValueEvaluator = this._createEvaluator(`${property} = $value`, true);\n            const inferCheckboxValue = () => {\n                if (element.hasAttribute('value'))\n                    return element.value;\n                const loopScope = this._collectLoopScope(element);\n                if (loopScope) {\n                    const keys = Object.keys(loopScope);\n                    if (keys.length === 1)\n                        return loopScope[keys[0]];\n                }\n                return element.value;\n            };\n            const checkboxValue = isCheckbox ? inferCheckboxValue() : undefined;\n            const getInputValue = () => {\n                if (isCheckbox) {\n                    const currentData = getValueEvaluator();\n                    if (Array.isArray(currentData) && checkboxValue !== undefined) {\n                        return element.checked ? checkboxValue : undefined;\n                    }\n                    return element.hasAttribute('value') ? (element.checked ? element.value : undefined) : element.checked;\n                }\n                if (isMultiSelect) {\n                    const sel = element;\n                    const values = [];\n                    const opts = sel.options;\n                    for (let i = 0; i < opts.length; i++) {\n                        if (opts[i].selected)\n                            values.push(opts[i].value);\n                    }\n                    return values;\n                }\n                return isNumeric ? parseFloat(element.value) || 0 : element.value;\n            };\n            const setInputValue = (value) => {\n                if (isCheckbox) {\n                    if (Array.isArray(value)) {\n                        const member = element.hasAttribute('value') ? element.value : checkboxValue;\n                        element.checked = member != null ? value.includes(member) : false;\n                    }\n                    else {\n                        element.checked = !!value;\n                    }\n                    return;\n                }\n                if (isMultiSelect) {\n                    const sel = element;\n                    const arr = Array.isArray(value) ? value : [];\n                    const opts = sel.options;\n                    for (let i = 0; i < opts.length; i++) {\n                        opts[i].selected = arr.includes(opts[i].value);\n                    }\n                    return;\n                }\n                element.value = String(value ?? (isNumeric ? 0 : ''));\n            };\n            this._createEffect(() => setInputValue(getValueEvaluator()));\n            const ctx = this._createContextProxy(undefined, element);\n            const updateData = () => {\n                const raw = getInputValue();\n                const currentVal = this._safeExecute(() => getValueEvaluator());\n                if (isCheckbox && Array.isArray(currentVal)) {\n                    const member = element.hasAttribute('value') ? element.value : checkboxValue;\n                    if (member !== undefined) {\n                        const idx = currentVal.indexOf(member);\n                        if (element.checked) {\n                            if (idx === -1)\n                                currentVal.push(member);\n                        }\n                        else if (idx > -1) {\n                            currentVal.splice(idx, 1);\n                        }\n                    }\n                }\n                else if (isMultiSelect && Array.isArray(currentVal)) {\n                    currentVal.splice(0, currentVal.length, ...raw);\n                }\n                else {\n                    ctx.$value = raw;\n                    this._safeExecute(() => { setValueEvaluator.call(this._createMethodContext(), ctx); });\n                }\n            };\n            const t = element.type;\n            const eventType = (element[STR_TAGNAME] === 'SELECT' || t === 'checkbox' || t === 'radio' || t === 'file') ? 'change' : 'input';\n            this._listen(element, eventType, updateData);\n            this._addDirective(element, { type: 'model', property });\n        }\n        _bindIfDirective(element, expression) {\n            const self = this;\n            const placeholder = d.createComment('x-if');\n            element.parentNode?.insertBefore(placeholder, element);\n            element.__x_if_anchorParent = placeholder.parentElement || null;\n            const branches = [];\n            const makeActualElement = (el) => {\n                if (el[STR_TAGNAME] === STR_TEMPLATE) {\n                    const wrapper = d.createElement('div');\n                    wrapper.style[STR_DISPLAY] = STR_CONTENTS;\n                    wrapper.appendChild(el.content.cloneNode(true));\n                    return { el: wrapper, isTemplate: true };\n                }\n                return { el: el, isTemplate: false };\n            };\n            const first = makeActualElement(element);\n            const firstEval = self._createElementEvaluator(expression, element);\n            branches.push({ el: first.el, test: firstEval, isTemplate: first.isTemplate });\n            if (!first.isTemplate)\n                first.el.__x_tool_bound = true;\n            const originalNodes = [element];\n            if (FT_IFB) {\n                let sib = element.nextElementSibling;\n                while (sib) {\n                    const isElse = sib.hasAttribute(attrName('else'));\n                    const isElseIf = sib.hasAttribute(attrName('else-if'));\n                    if (!isElse && !isElseIf)\n                        break;\n                    if (sib.hasAttribute(attrName('else-if'))) {\n                        const attr = sib.getAttribute(attrName('else-if')) || '';\n                        const branch = makeActualElement(sib);\n                        const evalFn = self._createElementEvaluator(_tr(attr), sib);\n                        branches.push({ el: branch.el, test: evalFn, isTemplate: branch.isTemplate });\n                        if (!branch.isTemplate)\n                            branch.el.__x_tool_bound = true;\n                    }\n                    else {\n                        const branch = makeActualElement(sib);\n                        branches.push({ el: branch.el, test: null, isTemplate: branch.isTemplate });\n                        if (!branch.isTemplate)\n                            branch.el.__x_tool_bound = true;\n                    }\n                    sib.removeAttribute(attrName('else'));\n                    sib.removeAttribute(attrName('else-if'));\n                    originalNodes.push(sib);\n                    sib = sib.nextElementSibling;\n                }\n            }\n            let active = -1;\n            for (const orig of originalNodes) {\n                if (orig.parentNode)\n                    orig.parentNode.removeChild(orig);\n            }\n            const mountBranch = (idx) => {\n                if (idx < 0)\n                    return;\n                const b = branches[idx];\n                if (!b.el.__x_tool_bound) {\n                    self._parseDirectives(b.el);\n                    b.el.__x_tool_bound = true;\n                }\n                element.__x_if_current?.parentNode?.removeChild(element.__x_if_current);\n                if (!b.el.parentNode) {\n                    placeholder.parentNode?.insertBefore(b.el, placeholder.nextSibling);\n                }\n                element.__x_if_current = b.el;\n                active = idx;\n            };\n            const unmountBranch = (idx, cb) => {\n                if (idx < 0) {\n                    if (cb)\n                        cb();\n                    return;\n                }\n                const b = branches[idx];\n                if (b.el.parentNode) {\n                    if (b.el.parentNode)\n                        b.el.parentNode.removeChild(b.el);\n                    if (cb)\n                        cb();\n                }\n                else if (cb)\n                    cb();\n                active = -1;\n            };\n            const update = () => {\n                let next = -1;\n                for (let i = 0; i < branches[STR_LENGTH]; i++) {\n                    const b = branches[i];\n                    const pass = b.test ? !!b.test() : true;\n                    if (pass) {\n                        next = i;\n                        break;\n                    }\n                }\n                if (next === active)\n                    return;\n                if (active !== -1) {\n                    unmountBranch(active, () => mountBranch(next));\n                }\n                else {\n                    mountBranch(next);\n                }\n            };\n            const effect = self._createEffect(update);\n            self._addDirective(element, { type: 'if', expression, update: effect });\n        }\n        _bindEventDirective(element, eventName, expression, modifiers) {\n            const self = this;\n            const trimmed = _tr(expression);\n            const opts = modifiers ? {\n                once: !!modifiers.once,\n                passive: !!modifiers.passive,\n                capture: !!modifiers.capture,\n            } : undefined;\n            const onlySelf = !!modifiers?.self;\n            const shouldPrevent = !!modifiers?.prevent;\n            const shouldStop = !!modifiers?.stop;\n            const isOutside = !!modifiers?.outside;\n            const isWindow = !!modifiers?.window;\n            const deferExec = !!modifiers?.defer;\n            const keyAliasMap = { enter: ['enter'], esc: ['escape', 'esc'], escape: ['escape', 'esc'], space: [' ', 'space', 'spacebar'], tab: ['tab'], backspace: ['backspace'], delete: ['delete', 'del'], del: ['delete', 'del'], arrowup: ['arrowup', 'up'], arrowdown: ['arrowdown', 'down'], arrowleft: ['arrowleft', 'left'], arrowright: ['arrowright', 'right'], home: ['home'], end: ['end'], pageup: ['pageup'], pagedown: ['pagedown'] };\n            const comboRequirements = {\n                ctrl: !!modifiers?.ctrl,\n                alt: !!modifiers?.alt,\n                shift: !!modifiers?.shift,\n                meta: !!modifiers?.meta,\n            };\n            const buttonMap = { left: 0, middle: 1, right: 2 };\n            const touchSingle = !!modifiers?.single;\n            const touchMulti = !!modifiers?.multi;\n            const modifierKeys = modifiers ? _Okeys(modifiers) : [];\n            const allowedKeys = [];\n            for (const m of modifierKeys) {\n                const aliases = keyAliasMap[m.toLowerCase()];\n                if (aliases)\n                    allowedKeys.push(...aliases);\n            }\n            const allowedButtons = [];\n            for (const m of modifierKeys) {\n                const btn = buttonMap[m.toLowerCase()];\n                if (btn !== undefined)\n                    allowedButtons.push(btn);\n            }\n            const needKeyCheck = allowedKeys.length > 0 || comboRequirements.ctrl || comboRequirements.alt || comboRequirements.shift || comboRequirements.meta;\n            const needButtonCheck = allowedButtons.length > 0;\n            const needTouchCheck = touchSingle || touchMulti;\n            const passesFilters = (event) => {\n                const path = event.composedPath ? event.composedPath() : null;\n                const tgt = (path && path.length ? path[0] : event.target);\n                if (isOutside) {\n                    if (!tgt)\n                        return false;\n                    if (element instanceof Node && (element === tgt || element.contains(tgt)))\n                        return false;\n                }\n                if (onlySelf && event.target !== element)\n                    return false;\n                if (needTouchCheck) {\n                    if (event instanceof TouchEvent) {\n                        const tCount = event.touches.length;\n                        if (touchSingle && tCount !== 1)\n                            return false;\n                        if (touchMulti && tCount < 2)\n                            return false;\n                    }\n                    else\n                        return false;\n                }\n                if (needButtonCheck) {\n                    if (event instanceof MouseEvent) {\n                        if (!allowedButtons.includes(event.button))\n                            return false;\n                    }\n                    else\n                        return false;\n                }\n                if (needKeyCheck) {\n                    if (!(event instanceof KeyboardEvent))\n                        return false;\n                    const k = (event.key || '').toLowerCase();\n                    if (allowedKeys.length > 0 && !allowedKeys.includes(k))\n                        return false;\n                    const { ctrlKey, altKey, shiftKey, metaKey } = event;\n                    if ((comboRequirements.ctrl && !ctrlKey) || (comboRequirements.alt && !altKey) ||\n                        (comboRequirements.shift && !shiftKey) || (comboRequirements.meta && !metaKey))\n                        return false;\n                }\n                return true;\n            };\n            const runExpr = self._compileHandler(trimmed, element, (ev) => [ev, element]);\n            const createEventHandler = (event) => {\n                if (!passesFilters(event))\n                    return;\n                if (shouldPrevent)\n                    event.preventDefault();\n                if (shouldStop)\n                    event.stopPropagation();\n                if (!runExpr)\n                    return;\n                if (deferExec && typeof quMct === 'function') {\n                    const ev = event;\n                    quMct(() => self._safeExecute(() => runExpr(ev)));\n                    return;\n                }\n                self._safeExecute(() => runExpr(event));\n            };\n            const cfg = this.framework._getConfig();\n            const canDelegate = !!cfg.delegate && EV_DELEGATED.includes(eventName);\n            if (!isOutside && !isWindow && canDelegate) {\n                const remover = this.framework._registerDelegated(element, eventName, { filter: (e) => passesFilters(e), run: (e) => createEventHandler(e), once: !!modifiers?.once, comp: this });\n                this._addCleanupFunction(remover);\n            }\n            else {\n                const target = isWindow ? (typeof window !== 'undefined' ? window : element) : (isOutside ? (element?.ownerDocument || d || document) : element);\n                self._listen(target, eventName, createEventHandler, opts);\n            }\n        }\n        _createEvaluator(expression, isStatement = false) {\n            const key = `${isStatement ? 's' : 'r'}:${expression}`;\n            let fn = this._expressionCache.get(key);\n            if (!fn) {\n                try {\n                    fn = new Function('ctx', `with(ctx){${isStatement ? expression : `return (${expression})`}}`);\n                }\n                catch {\n                    expression = JSON.stringify(expression);\n                    fn = new Function('ctx', `with(ctx){${isStatement ? expression : `return (${expression})`}}`);\n                }\n                this._expressionCache.set(key, fn);\n            }\n            return fn;\n        }\n        _createElementEvaluator(expression, element) {\n            const self = this;\n            const compiled = self._createEvaluator(expression);\n            return () => this._safeExecute(() => compiled.call(self._createMethodContext(), self._createContextProxy(undefined, element)));\n        }\n        _extractArrowFunction(expression) {\n            let m = expression.match(/^\\s*\\(\\s*([^)]*?)\\s*\\)\\s*=>\\s*([\\s\\S]+)$/);\n            if (!m)\n                m = expression.match(/^\\s*([a-zA-Z_$][a-zA-Z0-9_$]*)\\s*=>\\s*([\\s\\S]+)$/);\n            if (!m)\n                return null;\n            const params = (m[1] || '')\n                .split(',')\n                .map(p => p.trim())\n                .filter(Boolean);\n            const body = _tr(m[2]);\n            const isBlock = body.startsWith('{') && body.endsWith('}');\n            const finalBody = isBlock ? body.slice(1, -1) : body;\n            return { paramsList: params, body: finalBody, isBlock };\n        }\n        _compileArrowForEvent(params, body, isBlock) {\n            const content = isBlock ? body : 'return ( ' + body + ' );';\n            return new Function('ctx', ...params, 'with(ctx){ ' + content + ' }');\n        }\n        _compileHandler(expression, element, mapArgs) {\n            const self = this;\n            const trimmed = _tr(expression);\n            if (!trimmed)\n                return null;\n            const arrow = self._extractArrowFunction(trimmed);\n            const thisCtx = self._createMethodContext();\n            if (arrow) {\n                const { paramsList, body, isBlock } = arrow;\n                const compiledArrow = self._compileArrowForEvent(paramsList, body, isBlock);\n                return (payload) => {\n                    const ctx = self._createContextProxy(payload, element);\n                    const args = mapArgs(payload);\n                    self._safeExecute(() => compiledArrow.call(thisCtx, ctx, ...args.slice(0, paramsList.length)));\n                };\n            }\n            const isStatement = trimmed.includes(';');\n            const executor = self._createEvaluator(trimmed, isStatement);\n            return (payload) => {\n                const ctx = self._createContextProxy(payload, element);\n                const result = executor.call(thisCtx, ctx);\n                if (typeof result === 'function') {\n                    try {\n                        result.call(thisCtx, payload);\n                    }\n                    catch { }\n                }\n            };\n        }\n        _assertMutable(parentKey, method) {\n            if (this._isInComputedEvaluation) {\n                throw new Error(`[x-tool] Mutation via '${String(parentKey)}.${method}()' is not allowed during computed evaluation.`);\n            }\n            if (this._isFrozen) {\n                throw new Error(`[x-tool] Mutation via '${String(parentKey)}.${method}()' is not allowed while component is frozen.`);\n            }\n        }\n        _wrapData(data, parentKey) {\n            const isArr = ARRAY_ISARRAY(data);\n            const isSet = (typeof Set !== 'undefined') && (data instanceof Set);\n            const isMap = (typeof Map !== 'undefined') && (data instanceof Map);\n            if (!(Object.getPrototypeOf(data) === Object.prototype || isArr || isSet || isMap))\n                return data;\n            const self = this;\n            if (!this._deepReactiveCache)\n                this._deepReactiveCache = new WkMap();\n            if (this._deepReactiveCache.has(data))\n                return this._deepReactiveCache.get(data);\n            const makeCollectionWrapper = (name, fn, isArray) => function (...args) {\n                self._assertMutable(parentKey, name);\n                if (isArray) {\n                    const arr = this;\n                    const beforeLen = arr.length;\n                    const beforeFirst = arr[0];\n                    const beforeLast = arr[beforeLen - 1];\n                    const result = fn.apply(this, args);\n                    if (!self._isSealed && (arr.length !== beforeLen || arr[0] !== beforeFirst || arr[arr.length - 1] !== beforeLast)) {\n                        self._onDataChange(parentKey);\n                    }\n                    return result;\n                }\n                else {\n                    const before = this.size;\n                    const existed = (name === 'set') ? this.has(args[0]) : false;\n                    const result = fn.apply(this, args);\n                    if (!self._isSealed && (this.size !== before || (name === 'set' && !existed)))\n                        self._onDataChange(parentKey);\n                    return result;\n                }\n            };\n            const proxy = new Proxy(data, {\n                get: (target, p, receiver) => {\n                    const isCollection = isSet || isMap;\n                    if (isArr) {\n                        if (p === Symbol.iterator || p === 'length' || (typeof p === 'string' && /^\\d+$/.test(p))) {\n                            self._trackDependency(parentKey);\n                            if (p === Symbol.iterator)\n                                return Reflect.get(target, p, receiver);\n                        }\n                    }\n                    else if (isCollection) {\n                        if (p === 'size' || p === Symbol.iterator || p === 'keys' || p === 'values' || p === 'entries') {\n                            self._trackDependency(parentKey);\n                        }\n                    }\n                    else {\n                        self._trackDependency(parentKey);\n                    }\n                    const value = Reflect.get(target, p, receiver);\n                    if (isCollection && typeof value === 'function' && (p === Symbol.iterator || p === 'keys' || p === 'values' || p === 'entries')) {\n                        return function (...args) { return value.apply(target, args); };\n                    }\n                    if (typeof value === 'function') {\n                        if (isArr && ['push', 'pop', 'shift', 'unshift', 'splice', 'reverse', 'copyWithin', 'fill', 'sort'].includes(p)) {\n                            return makeCollectionWrapper(String(p), value, true).bind(target);\n                        }\n                        if (isSet && (p === 'add' || p === 'delete' || p === 'clear')) {\n                            return makeCollectionWrapper(String(p), value, false).bind(target);\n                        }\n                        if (isMap && (p === 'set' || p === 'delete' || p === 'clear')) {\n                            return makeCollectionWrapper(String(p), value, false).bind(target);\n                        }\n                    }\n                    return (value && typeof value === 'object') ? self._wrapData(value, parentKey) : value;\n                },\n                ownKeys: Reflect.ownKeys,\n                has: Reflect.has,\n                set: (target, p, value) => {\n                    if (self._isDestroyed || typeof p === 'symbol')\n                        return true;\n                    const key = String(parentKey) + '.' + String(p);\n                    if (self._isInComputedEvaluation)\n                        throw new Error(`[x-tool] Mutation of '${key}' is not allowed during computed evaluation.`);\n                    if (self._isFrozen)\n                        throw new Error(`[x-tool] Mutation of '${key}' is not allowed while component is frozen.`);\n                    const had = Reflect.has(target, p);\n                    const oldValue = had ? Reflect.get(target, p) : undefined;\n                    if (value && typeof value === 'object') {\n                        value = self._wrapData(value, (String(parentKey) + '.' + String(p)));\n                    }\n                    if (!had) {\n                        _se(() => Reflect.defineProperty(target, p, { configurable: true, enumerable: true, writable: true, value }));\n                        if (!Reflect.has(target, p))\n                            Reflect.set(target, p, value);\n                        self._onDataChange(parentKey);\n                        return true;\n                    }\n                    if (oldValue === value)\n                        return true;\n                    Reflect.set(target, p, value);\n                    if (!self._isSealed)\n                        self._onDataChange(parentKey);\n                    return true;\n                },\n                deleteProperty: (target, p) => {\n                    const key = String(parentKey) + (typeof p === 'symbol' ? '' : '.' + String(p));\n                    if (self._isInComputedEvaluation)\n                        throw new Error(`[x-tool] Deletion of '${key}' is not allowed during computed evaluation.`);\n                    if (self._isFrozen)\n                        throw new Error(`[x-tool] Deletion of '${key}' is not allowed while component is frozen.`);\n                    const ok = Reflect.deleteProperty(target, p);\n                    if (ok && !self._isSealed)\n                        self._onDataChange(parentKey);\n                    return ok;\n                }\n            });\n            this._deepReactiveCache.set(data, proxy);\n            return proxy;\n        }\n        _createReactiveData(data) {\n            const self = this;\n            return new Proxy(data, {\n                get: (target, property, receiver) => {\n                    const value = Reflect.get(target, property, receiver);\n                    if (property === Symbol.iterator)\n                        return value;\n                    if (typeof property !== 'symbol') {\n                        self._trackDependency(property);\n                    }\n                    if (value && typeof value === 'object') {\n                        return self._wrapData(value, property);\n                    }\n                    return value;\n                },\n                ownKeys: (target) => Reflect.ownKeys(target),\n                has: (target, key) => Reflect.has(target, key),\n                set: (target, property, value, receiver) => {\n                    if (self._isDestroyed)\n                        return true;\n                    if (self._isFrozen)\n                        return true;\n                    if (self._isInComputedEvaluation) {\n                        throw new Error(`[x-tool] Mutation of '${String(property)}' is not allowed during computed evaluation.`);\n                    }\n                    if (property === Symbol.iterator && ARRAY_ISARRAY(target))\n                        return value;\n                    const oldValue = Reflect.get(target, property);\n                    const had = Reflect.has(target, property);\n                    if (!had) {\n                        try {\n                            Reflect.defineProperty(target, property, {\n                                configurable: true,\n                                enumerable: true,\n                                writable: true,\n                                value\n                            });\n                        }\n                        catch {\n                            Reflect.set(target, property, value, receiver);\n                        }\n                    }\n                    else {\n                        Reflect.set(target, property, value, receiver);\n                    }\n                    if (!this._isSealed)\n                        this._onDataChange(property);\n                    if (this._propUpdateActive && property !== '$props') {\n                        const pc = target.$props;\n                        if (pc)\n                            pc[property] = value;\n                        const eff = this._propEffects[property];\n                        if (eff && !this._isSealed) {\n                            eff(value, oldValue);\n                        }\n                    }\n                    return true;\n                }\n            });\n        }\n        _createMethodContext(_includeComputed = true) {\n            const specials = {\n                '$log': (..._args) => { },\n                '$destroy': () => this.destroy(),\n                '$forceUpdate': () => this._scheduleRender(),\n                '$addCleanupFunction': (fn) => this._addCleanupFunction(fn),\n                '$nextTick': (cb) => {\n                    if (cb) {\n                        this._nextTickQueue.push(cb);\n                        if (!this._renderScheduled)\n                            quMct(() => {\n                                if (!this._renderScheduled && this._nextTickQueue.length) {\n                                    const q = this._nextTickQueue.splice(0, this._nextTickQueue.length);\n                                    for (const fn of q) {\n                                        this._safeExecute(() => fn());\n                                    }\n                                }\n                            });\n                        return;\n                    }\n                    return new Promise(resolve => {\n                        this._nextTickQueue.push(() => resolve());\n                        if (!this._renderScheduled)\n                            quMct(() => {\n                                if (!this._renderScheduled && this._nextTickQueue.length) {\n                                    const q = this._nextTickQueue.splice(0, this._nextTickQueue.length);\n                                    for (const fn of q) {\n                                        this._safeExecute(() => fn());\n                                    }\n                                }\n                            });\n                    });\n                },\n                '$el': this._element,\n                '$id': this._id,\n                '$isMounted': this._isMounted,\n                '$isDestroyed': this._isDestroyed,\n                '$isSealed': this._isSealed,\n                '$isFrozen': this._isFrozen,\n                '$parent': this._parent,\n                '$children': this._children,\n                '$seal': (on = true) => { this._setSealed(!!on); },\n                '$mutate': (fn) => {\n                    const prevMethod = this._isInMethodExecution;\n                    this._isMutationEnabled = false;\n                    if (this._isInComputedEvaluation) {\n                        throw new Error('[x-tool] $mutate cannot be used inside computed evaluation; computed getters must be pure.');\n                    }\n                    this._isInMethodExecution = false;\n                    try {\n                        return typeof fn === 'function' ? fn() : undefined;\n                    }\n                    finally {\n                        this._isInMethodExecution = prevMethod;\n                        this._isMutationEnabled = true;\n                        this._scheduleRender();\n                    }\n                }\n            };\n            let data = this._data;\n            if (this._isInComputedEvaluation) {\n                data = (this._rawData);\n            }\n            return new Proxy(data, {\n                get: (target, propStr) => {\n                    if (propStr in target) {\n                        this._trackDependency(propStr);\n                        const v = target[propStr];\n                        return v;\n                    }\n                    if (FT_C && (propStr in this._computed)) {\n                        return this._getComputedValue(propStr);\n                    }\n                    if (propStr in specials)\n                        return specials[propStr];\n                    return this._methods[propStr];\n                },\n                set: (_target, propStr, value) => {\n                    if (this._isInComputedEvaluation) {\n                        throw new Error(`[x-tool] Mutation of '${String(propStr)}' is not allowed during computed evaluation.`);\n                    }\n                    if (this._isFrozen) {\n                        throw new Error(`[x-tool] Mutation of '${String(propStr)}' is not allowed while component is frozen.`);\n                    }\n                    this._data[propStr] = value;\n                    return true;\n                }\n            });\n        }\n        _createContextProxy(event, targetElement) {\n            const component = this;\n            const mergedScope = targetElement ? this._collectLoopScope(targetElement) : null;\n            const gWindow = (typeof window !== 'undefined' ? window : undefined);\n            const gDocument = (typeof document !== 'undefined' ? document : undefined);\n            const cfg = this.framework._getConfig();\n            const sandbox = !!cfg.sandboxExpressions;\n            const allow = new Set((cfg.allowGlobals || []).map(s => String(s)));\n            const ensureInvoker = () => this._currentInvoker || '__anonymous__';\n            const registerResource = (kind, setup) => {\n                const inv = ensureInvoker();\n                let byKind = this._invokerResources.get(inv);\n                if (!byKind) {\n                    byKind = new Map();\n                    this._invokerResources.set(inv, byKind);\n                }\n                const prev = byKind.get(kind);\n                if (prev) {\n                    try {\n                        prev();\n                    }\n                    catch { }\n                    byKind.delete(kind);\n                }\n                const cleanup = setup();\n                if (typeof cleanup === 'function') {\n                    const wrapped = () => {\n                        try {\n                            cleanup();\n                        }\n                        finally {\n                            byKind?.delete(kind);\n                        }\n                    };\n                    byKind.set(kind, wrapped);\n                    this._addCleanupFunction(wrapped);\n                }\n            };\n            const wrapTarget = (target) => {\n                if (!target || typeof target.addEventListener !== 'function')\n                    return target;\n                return new Proxy(target, {\n                    get: (obj, prop) => {\n                        if (prop === 'addEventListener') {\n                            return (eventName, handler, options) => {\n                                if (this._isSealed || this._isFrozen)\n                                    return;\n                                obj.addEventListener(eventName, handler, options);\n                                const optSig = typeof options === 'boolean' ? options : options?.capture ? '1' : '0';\n                                const key = 'listener:' + this._targetKey(obj) + ':' + eventName + ':' + optSig;\n                                registerResource(key, () => () => {\n                                    try {\n                                        obj.removeEventListener(eventName, handler, options);\n                                    }\n                                    catch { }\n                                });\n                            };\n                        }\n                        if (prop === 'removeEventListener') {\n                            return (eventName, handler, options) => {\n                                try {\n                                    obj.removeEventListener(eventName, handler, options);\n                                }\n                                catch { }\n                            };\n                        }\n                        if (prop === 'querySelector') {\n                            return (sel) => wrapTarget(obj.querySelector(sel));\n                        }\n                        if (prop === 'querySelectorAll') {\n                            return (sel) => Array.from(obj.querySelectorAll(sel)).map(wrapTarget);\n                        }\n                        if (prop === 'getElementById') {\n                            return (id) => wrapTarget(obj.getElementById(id));\n                        }\n                        if (prop === 'document') {\n                            const doc = obj.document;\n                            return wrapTarget(doc) || doc;\n                        }\n                        if (prop === 'defaultView') {\n                            const win = obj.defaultView;\n                            return wrapTarget(win) || win;\n                        }\n                        if (prop === 'body') {\n                            const body = obj.body;\n                            return wrapTarget(body) || body;\n                        }\n                        const value = obj[prop];\n                        if (typeof value === 'function') {\n                            try {\n                                return value.bind(obj);\n                            }\n                            catch {\n                                return value;\n                            }\n                        }\n                        return value;\n                    }\n                });\n            };\n            const ctxSetTimeout = (fn, ms, ...args) => {\n                if (this._isSealed || this._isFrozen || this._isDestroyed)\n                    return undefined;\n                const id = gWindow?.setTimeout?.(fn, ms, ...args);\n                if (id != null)\n                    registerResource('timeout', () => () => { try {\n                        gWindow?.clearTimeout?.(id);\n                    }\n                    catch { } });\n                return id;\n            };\n            const ctxSetInterval = (fn, ms, ...args) => {\n                if (this._isSealed || this._isFrozen)\n                    return undefined;\n                const id = gWindow?.setInterval?.(fn, ms, ...args);\n                if (id != null)\n                    registerResource('interval', () => () => { try {\n                        gWindow?.clearInterval?.(id);\n                    }\n                    catch { } });\n                return id;\n            };\n            const ctxRequestAnimationFrame = (cb) => {\n                if (this._isSealed || this._isFrozen)\n                    return undefined;\n                const id = gWindow?.requestAnimationFrame?.(cb);\n                if (id != null)\n                    registerResource('raf', () => () => { try {\n                        gWindow?.cancelAnimationFrame?.(id);\n                    }\n                    catch { } });\n                return id;\n            };\n            const wrapObserverCtor = (Orig, kind) => {\n                if (!Orig)\n                    return undefined;\n                return function (...observerArgs) {\n                    if (component._isSealed || component._isFrozen)\n                        return { observe() { }, disconnect() { }, unobserve() { } };\n                    const inst = new Orig(...observerArgs);\n                    registerResource('observer:' + kind, () => () => { try {\n                        inst.disconnect();\n                    }\n                    catch { } });\n                    return inst;\n                };\n            };\n            const specials = {\n                '$target': targetElement || null,\n                '$event': event || null,\n                ...(this.framework._routerEnabled() ? {\n                    'location': new Proxy(gWindow?.location || location, {\n                        get: (t, p) => t[p],\n                        set: (_t, p, v) => {\n                            const key = String(p);\n                            if (key === 'href') {\n                                try {\n                                    this.framework._navigate(String(v), true, 'program');\n                                }\n                                catch {\n                                    location.href = String(v);\n                                }\n                                return true;\n                            }\n                            try {\n                                location[p] = v;\n                            }\n                            catch { }\n                            return true;\n                        }\n                    })\n                } : {}),\n                ...(sandbox && !allow.has('setTimeout') ? {} : { 'setTimeout': ctxSetTimeout }),\n                ...(sandbox && !allow.has('clearTimeout') ? {} : { 'clearTimeout': (id) => { try {\n                        gWindow?.clearTimeout?.(id);\n                    }\n                    catch { } } }),\n                ...(sandbox && !allow.has('setInterval') ? {} : { 'setInterval': ctxSetInterval }),\n                ...(sandbox && !allow.has('clearInterval') ? {} : { 'clearInterval': (id) => { try {\n                        gWindow?.clearInterval?.(id);\n                    }\n                    catch { } } }),\n                ...(sandbox && !allow.has('requestAnimationFrame') ? {} : { 'requestAnimationFrame': ctxRequestAnimationFrame }),\n                ...(sandbox && !allow.has('cancelAnimationFrame') ? {} : { 'cancelAnimationFrame': (id) => { try {\n                        gWindow?.cancelAnimationFrame?.(id);\n                    }\n                    catch { } } }),\n                ...(sandbox && !allow.has('MutationObserver') ? {} : { 'MutationObserver': wrapObserverCtor(gWindow?.MutationObserver, 'mutation') }),\n                ...(sandbox && !allow.has('ResizeObserver') ? {} : { 'ResizeObserver': wrapObserverCtor(gWindow?.ResizeObserver, 'resize') }),\n                ...(sandbox && !allow.has('IntersectionObserver') ? {} : { 'IntersectionObserver': wrapObserverCtor(gWindow?.IntersectionObserver, 'intersection') }),\n                ...(sandbox && !allow.has('window') ? {} : { 'window': wrapTarget(gWindow) }),\n                ...(sandbox && !allow.has('document') ? {} : { 'document': wrapTarget(gDocument) })\n            };\n            return new Proxy({}, {\n                get: (_t, propStr) => {\n                    if (mergedScope && propStr in mergedScope)\n                        return mergedScope[propStr];\n                    if (propStr in component._data)\n                        return component._data[propStr];\n                    if (propStr in component._computed)\n                        return component._getComputedValue(propStr);\n                    if (propStr in component._methods)\n                        return component._methods[propStr];\n                    if (propStr in specials)\n                        return specials[propStr];\n                    return undefined;\n                },\n                set: (_t, propStr, value) => {\n                    if (mergedScope) {\n                        let s = mergedScope;\n                        while (s) {\n                            if (Object.prototype.hasOwnProperty.call(s, propStr)) {\n                                s[propStr] = value;\n                                return true;\n                            }\n                            s = Object.getPrototypeOf(s);\n                        }\n                    }\n                    component._data[propStr] = value;\n                    return true;\n                },\n                has: (_t, propStr) => !!(mergedScope && propStr in mergedScope) ||\n                    propStr in component._data ||\n                    propStr in component._computed ||\n                    propStr in component._methods ||\n                    propStr in specials\n            });\n        }\n        _bindCustomDirective(element, _name, expression, directive, modifiers) {\n            const self = this;\n            const evaluator = self._createElementEvaluator(expression, element);\n            const directiveInfo = { type: 'custom', expression, customDirective: directive };\n            if (directive.bind) {\n                self._safeExecute(() => directive.bind(element, evaluator(), expression, self, modifiers, evaluator));\n            }\n            const update = () => {\n                if (directive.update)\n                    self._safeExecute(() => directive.update(element, evaluator(), expression, self, modifiers, evaluator));\n            };\n            const effect = self._createEffect(update);\n            directiveInfo.update = effect;\n            self._addDirective(element, directiveInfo);\n        }\n        _bindAttributeDirective(element, attributeName, expression) {\n            const self = this;\n            const evaluator = self._createElementEvaluator(expression, element);\n            const isSvg = element.namespaceURI === 'http://www.w3.org/2000/svg';\n            if (attributeName === 'class') {\n                const el = element;\n                if (!self._initialClassSets.get(el)) {\n                    const baseSet = new Set();\n                    const oc = isSvg ? (element.getAttribute('class') || '') : (element.className || '');\n                    if (oc)\n                        for (const cls of oc.split(/\\s+/)) {\n                            if (cls)\n                                baseSet.add(cls);\n                        }\n                    self._initialClassSets.set(el, baseSet);\n                }\n            }\n            const meta = self._resolveBindingMeta(element, attributeName);\n            const update = () => {\n                const value = evaluator();\n                if (attributeName === 'class') {\n                    const base = self._initialClassSets.get(element);\n                    if (typeof value === 'string') {\n                        const finalCls = base && base.size ? [...base].join(' ') + (value ? ' ' + value : '') : value || '';\n                        if (isSvg) {\n                            if (finalCls)\n                                element.setAttribute('class', finalCls);\n                            else\n                                element.removeAttribute('class');\n                        }\n                        else {\n                            element.className = finalCls;\n                        }\n                    }\n                    else if (ARRAY_ISARRAY(value)) {\n                        const tokens = value.filter(Boolean);\n                        const finalList = base && base.size ? [...base, ...tokens] : tokens;\n                        const finalStr = finalList.join(' ');\n                        if (isSvg) {\n                            if (finalStr)\n                                element.setAttribute('class', finalStr);\n                            else\n                                element.removeAttribute('class');\n                        }\n                        else {\n                            element.className = finalStr;\n                        }\n                    }\n                    else if (value && typeof value === 'object') {\n                        if (base && base.size) {\n                            const baseStr = [...base].join(' ');\n                            if (isSvg) {\n                                if (baseStr)\n                                    element.setAttribute('class', baseStr);\n                                else\n                                    element.removeAttribute('class');\n                            }\n                            else {\n                                element.className = baseStr;\n                            }\n                        }\n                        const elAny = element;\n                        for (const raw in value) {\n                            const on = !!value[raw];\n                            if (!raw)\n                                continue;\n                            const tokens = raw.split(/\\s+/);\n                            for (let i = 0; i < tokens.length; i++) {\n                                const tk = tokens[i];\n                                if (!tk)\n                                    continue;\n                                elAny.classList?.toggle(tk, on);\n                            }\n                        }\n                    }\n                    else if (value == null && base && base.size) {\n                        const baseStr = [...base].join(' ');\n                        if (isSvg) {\n                            if (baseStr)\n                                element.setAttribute('class', baseStr);\n                            else\n                                element.removeAttribute('class');\n                        }\n                        else {\n                            element.className = baseStr;\n                        }\n                    }\n                    else if (value == null) {\n                        element.removeAttribute('class');\n                    }\n                    return;\n                }\n                if (attributeName === STR_STYLE) {\n                    const el = element;\n                    if (typeof value === 'string') {\n                        el.style.cssText = value;\n                        return;\n                    }\n                    if (value && typeof value === 'object') {\n                        for (const k in value) {\n                            const v = value[k];\n                            const cssProp = k.startsWith('--') ? k : k.replace(/[A-Z]/g, m => '-' + m.toLowerCase());\n                            if (v != null)\n                                el.style.setProperty(cssProp, String(v));\n                            else\n                                el.style.removeProperty(cssProp);\n                        }\n                        return;\n                    }\n                    if (value == null)\n                        el.removeAttribute('style');\n                    return;\n                }\n                self._applyGenericBinding(element, attributeName, value, meta);\n            };\n            const effect = self._createEffect(update);\n            self._addDirective(element, { type: 'bind', expression, update: effect });\n        }\n        _collectLoopScope(el) {\n            if (!el)\n                return null;\n            if (!el.parentElement) {\n                const cur = el.__x_if_current;\n                if (cur && cur.parentElement) {\n                    el = cur;\n                }\n                else {\n                    const anchorParent = el.__x_if_anchorParent;\n                    if (anchorParent)\n                        el = anchorParent;\n                }\n            }\n            let node = el;\n            while (node) {\n                const s = node.__x_scope;\n                if (s)\n                    return s;\n                node = node.parentElement;\n            }\n            const merged = {};\n            node = el;\n            while (node) {\n                const scope = this._loopScopes.get(node);\n                if (scope)\n                    Object.assign(merged, scope);\n                if (node === this.element)\n                    break;\n                node = node.parentElement;\n            }\n            return _Okeys(merged).length ? merged : null;\n        }\n        _updateElementDirectives(root, force) {\n            for (const [element, directives] of this._directives) {\n                for (const directive of directives) {\n                    if ((root === element || (element instanceof Element && root.contains(element))) && directive.update) {\n                        if (XTOOL_ENABLE_STATIC_DIRECTIVES && directive._static && !force)\n                            continue;\n                        directive.update();\n                    }\n                }\n            }\n        }\n        _updateElementDirectivesForVar(root, varName) {\n            const re = new RegExp('(^|[^$\\\\w])' + varName.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&') + '([^$\\\\w]|$)');\n            for (const [element, directives] of this._directives) {\n                if (!(root === element || (element instanceof Element && root.contains(element))))\n                    continue;\n                for (const directive of directives) {\n                    if (!directive.update)\n                        continue;\n                    const expr = directive.expression || '';\n                    if (re.test(expr)) {\n                        directive.update();\n                    }\n                }\n            }\n        }\n        _cleanupElementSubtree(root) {\n            const toDelete = [];\n            for (const [element, directives] of this._directives) {\n                if (root === element || (element instanceof Element && root.contains(element))) {\n                    for (const directive of directives) {\n                        if (directive.type === 'custom' && directive.customDirective?.unbind) {\n                            try {\n                                directive.customDirective.unbind(element, this);\n                            }\n                            catch { }\n                        }\n                    }\n                    toDelete.push(element);\n                }\n            }\n            if (toDelete.length) {\n                for (const el of toDelete)\n                    this._directives.delete(el);\n            }\n        }\n        _bindForDirective(element, expression) {\n            const self = this;\n            const match = expression.trim().match(/^(?:\\(\\s*([^,\\s]+)\\s*(?:,\\s*([^\\)]+))?\\s*\\)|([^,\\s]+))\\s+(in|of)\\s+(.+)$/);\n            if (!match) {\n                return;\n            }\n            const itemVar = match[1] || match[3];\n            const indexVar = match[2];\n            const listCode = match[5];\n            const keyAttrName = attrName('key');\n            const keyExpr = element.getAttribute(keyAttrName) || null;\n            if (keyExpr)\n                element.removeAttribute(keyAttrName);\n            const placeholder = d.createComment('x-for');\n            element.parentNode?.insertBefore(placeholder, element);\n            let templateToClone;\n            if (element[STR_TAGNAME] === STR_TEMPLATE) {\n                templateToClone = d.createElement('div');\n                templateToClone.style[STR_DISPLAY] = STR_CONTENTS;\n                templateToClone.appendChild(element.content.cloneNode(true));\n                element.parentNode?.removeChild(element);\n            }\n            else {\n                templateToClone = element;\n                element.parentNode?.removeChild(element);\n            }\n            const contextAnchor = placeholder.parentElement || self.element;\n            const listEval = self._createElementEvaluator(listCode.trim(), contextAnchor);\n            const keyEval = keyExpr ? self._createEvaluator(keyExpr) : null;\n            const BP_FOR = attrName('for');\n            const BP_KEY = attrName('key');\n            const BP_TEXT = attrName('text');\n            const BP_HTML = attrName('html');\n            const BP_DATA = attrName('data');\n            const buildBlueprint = (root) => {\n                const bp = [];\n                const walk = (el, path, isRootEl) => {\n                    if (!isRootEl && el.hasAttribute(BP_DATA))\n                        return;\n                    const isComponentTag = el[STR_TAGNAME] === 'COMPONENT';\n                    const scan = self._scanDirectiveAttrs(el, { skipRootFor: isRootEl });\n                    const dnames = scan.names.filter(n => n !== BP_KEY && (!isRootEl || n !== BP_FOR));\n                    const hasTextOrHtml = scan.names.includes(BP_TEXT) || scan.names.includes(BP_HTML);\n                    const forName = scan.forName;\n                    if (dnames.length) {\n                        if (forName) {\n                            bp.push({ path, directiveNames: [forName], hasTextOrHtml: hasTextOrHtml, forName });\n                            return;\n                        }\n                        bp.push({ path, directiveNames: dnames, hasTextOrHtml });\n                    }\n                    else {\n                        if (FT_TI && !hasTextOrHtml) {\n                            bp.push({ path, directiveNames: [], hasTextOrHtml });\n                        }\n                    }\n                    if (isComponentTag)\n                        return;\n                    let idx = 0;\n                    let child = el.firstElementChild;\n                    while (child) {\n                        const next = child.nextElementSibling;\n                        walk(child, path.concat(idx), false);\n                        idx++;\n                        child = next;\n                    }\n                };\n                walk(root, [], true);\n                return bp;\n            };\n            const hydrateFromBlueprint = (cloneRoot, bp) => {\n                for (let i = 0; i < bp.length; i++) {\n                    const instr = bp[i];\n                    const target = this._resolveNodeByPath(cloneRoot, instr.path);\n                    if (instr.forName) {\n                        const expr = target.getAttribute(instr.forName) || '';\n                        self._bindDirective(target, instr.forName, expr);\n                        continue;\n                    }\n                    for (let j = 0; j < instr.directiveNames.length; j++) {\n                        const dn = instr.directiveNames[j];\n                        const expr = target.getAttribute(dn) || '';\n                        if (dn === BP_KEY)\n                            continue;\n                        self._bindDirective(target, dn, expr);\n                    }\n                    if (FT_TI && !instr.hasTextOrHtml)\n                        self._bindTextInterpolationsIn(target);\n                }\n            };\n            const blueprint = buildBlueprint(templateToClone);\n            const instances = [];\n            const createScope = (item, idxOrKey, existing) => {\n                const scope = existing || {};\n                scope[itemVar] = item;\n                if (indexVar)\n                    scope[indexVar] = idxOrKey;\n                return scope;\n            };\n            const objIds = new WeakMap();\n            let objSeq = 0;\n            const extractId = (o) => {\n                if (!o || typeof o !== 'object')\n                    return null;\n                const v = o.id ?? o._id ?? o.key;\n                if (v == null)\n                    return null;\n                const t = typeof v;\n                return (t === 'string' || t === 'number') ? ('id:' + String(v)) : null;\n            };\n            const keyFor = (item) => {\n                if (item && typeof item === 'object') {\n                    const explicit = extractId(item);\n                    if (explicit)\n                        return explicit;\n                    let id = objIds.get(item);\n                    if (!id) {\n                        id = 'o#' + (++objSeq);\n                        objIds.set(item, id);\n                    }\n                    return id;\n                }\n                return 'p#' + (typeof item) + ':' + String(item);\n            };\n            const evalKeyExpr = (item, idxOrKey) => {\n                if (!keyEval)\n                    return null;\n                try {\n                    const base = self._createContextProxy(undefined, contextAnchor);\n                    const ctx = Object.create(base);\n                    ctx[itemVar] = item;\n                    if (indexVar)\n                        ctx[indexVar] = idxOrKey;\n                    const v = keyEval.call(self._createMethodContext(), ctx);\n                    const t = typeof v;\n                    return (t === 'string' || t === 'number') ? v : (v != null ? String(v) : null);\n                }\n                catch {\n                    return null;\n                }\n            };\n            const update = () => {\n                const norm = self._safeExecute(() => {\n                    const result = listEval();\n                    if (_AisArr(result))\n                        return { list: result, keys: null, src: result };\n                    const tag = result && Object.prototype.toString.call(result);\n                    const isMap = typeof Map !== 'undefined' && (result instanceof Map || tag === '[object Map]' || (result && typeof result.get === 'function' && typeof result.set === 'function' && typeof result.keys === 'function'));\n                    if (isMap) {\n                        return { list: _Afrom(result.values()), keys: _Afrom(result.keys()), src: result };\n                    }\n                    const isSet = typeof Set !== 'undefined' && (result instanceof Set || tag === '[object Set]' || (result && typeof result.add === 'function' && typeof result.has === 'function' && typeof result.values === 'function'));\n                    if (isSet) {\n                        return { list: _Afrom(result.values()), keys: null, src: result };\n                    }\n                    if (result && typeof result[Symbol.iterator] === 'function') {\n                        return { list: _Afrom(result), keys: null, src: result };\n                    }\n                    if (result && typeof result === 'object') {\n                        const keys = Object.keys(result);\n                        const list = keys.map(k => result[k]);\n                        return { list, keys, src: result };\n                    }\n                    return { list: [], keys: null, src: null };\n                }, { list: [], keys: null, src: null });\n                const list = norm.list;\n                const keysArr = norm.keys;\n                const oldByObjKey = new Map();\n                const oldPrimQueues = new Map();\n                for (let i = 0; i < instances.length; i++) {\n                    const n = instances[i];\n                    const k = n.__x_for_key;\n                    const ps = n.__x_primSig;\n                    if (ps) {\n                        let q = oldPrimQueues.get(ps);\n                        if (!q) {\n                            q = [];\n                            oldPrimQueues.set(ps, q);\n                        }\n                        q.push(n);\n                    }\n                    else if (k) {\n                        oldByObjKey.set(k, n);\n                    }\n                }\n                const newNodes = new Array(list.length);\n                const parent = placeholder.parentNode;\n                for (let i = 0; i < list.length; i++) {\n                    const item = list[i];\n                    const idxOrKey = keysArr ? keysArr[i] : i;\n                    let node;\n                    let nodeKey;\n                    const explicitKey = keyEval ? evalKeyExpr(item, idxOrKey) : null;\n                    if (explicitKey != null) {\n                        nodeKey = 'k:' + String(explicitKey);\n                        const prev = oldByObjKey.get(nodeKey);\n                        if (prev) {\n                            node = prev;\n                            oldByObjKey.delete(nodeKey);\n                        }\n                    }\n                    if (!node) {\n                        const k = keyFor(item);\n                        if (k && k.startsWith('o#') || (k && k.startsWith('id:'))) {\n                            nodeKey = k;\n                            const prev = oldByObjKey.get(k);\n                            if (prev) {\n                                node = prev;\n                                oldByObjKey.delete(k);\n                            }\n                        }\n                        else if (k && k.startsWith('p#')) {\n                            const ps = k;\n                            const q = oldPrimQueues.get(ps);\n                            if (q && q.length) {\n                                node = q.shift();\n                            }\n                            if (node) {\n                                nodeKey = node.__x_for_key;\n                            }\n                            if (node) {\n                                node.__x_primSig = ps;\n                            }\n                        }\n                    }\n                    if (!node) {\n                        const clone = templateToClone.cloneNode(true);\n                        clone.removeAttribute('x-for');\n                        if (keyExpr)\n                            clone.removeAttribute(keyAttrName);\n                        const initScope = createScope(item, idxOrKey, {});\n                        clone.__x_scope = initScope;\n                        clone.__x_itemRef = item;\n                        if (indexVar)\n                            clone.__x_idxRef = idxOrKey;\n                        self._loopScopes.set(clone, initScope);\n                        try {\n                            hydrateFromBlueprint(clone, blueprint);\n                        }\n                        catch { }\n                        node = clone;\n                        node.__x_for_key = (nodeKey !== undefined) ? nodeKey : ('n#' + (++objSeq));\n                    }\n                    else {\n                        const existingScope = node.__x_scope;\n                        const prevIdxRef = node.__x_idxRef;\n                        const prevItemRef = node.__x_itemRef;\n                        const scope = createScope(item, idxOrKey, existingScope);\n                        node.__x_scope = scope;\n                        self._loopScopes.set(node, scope);\n                        let needsUpdate = false;\n                        if (prevItemRef !== item) {\n                            needsUpdate = true;\n                            node.__x_itemRef = item;\n                        }\n                        const indexChanged = !!indexVar && prevIdxRef !== idxOrKey;\n                        if (indexChanged) {\n                            needsUpdate = true;\n                            node.__x_idxRef = idxOrKey;\n                        }\n                        if (needsUpdate) {\n                            if (indexChanged && indexVar)\n                                self._updateElementDirectivesForVar(node, indexVar);\n                            else\n                                self._updateElementDirectives(node);\n                        }\n                    }\n                    if (nodeKey)\n                        node.__x_for_key = nodeKey;\n                    const sig = (!keyExpr && !(item && typeof item === 'object')) ? ('p#' + (typeof item) + ':' + String(item)) : undefined;\n                    node.__x_primSig = sig;\n                    newNodes[i] = node;\n                }\n                for (const [, node] of oldByObjKey) {\n                    if (node && node.parentNode) {\n                        self._cleanupElementSubtree(node);\n                        node.parentNode.removeChild(node);\n                    }\n                }\n                for (const [, queue] of oldPrimQueues) {\n                    for (const node of queue) {\n                        if (node && node.parentNode) {\n                            self._cleanupElementSubtree(node);\n                            node.parentNode.removeChild(node);\n                        }\n                    }\n                }\n                if (parent) {\n                    const oldIndexMap = new Map();\n                    for (let i = 0; i < instances.length; i++) {\n                        const k = instances[i].__x_for_key;\n                        if (k !== undefined)\n                            oldIndexMap.set(k, i);\n                    }\n                    const seq = new Array(newNodes.length);\n                    for (let i = 0; i < newNodes.length; i++) {\n                        const k = newNodes[i].__x_for_key;\n                        const oldIdx = oldIndexMap.has(k) ? oldIndexMap.get(k) : -1;\n                        seq[i] = oldIdx;\n                    }\n                    const { lisMask: lis } = this._computeLISMask(seq);\n                    const tailAnchor = instances.length ? (instances[instances.length - 1].nextSibling) : placeholder.nextSibling;\n                    let anchor = null;\n                    for (let i = newNodes.length - 1; i >= 0; i--) {\n                        const node = newNodes[i];\n                        const ref = anchor ?? tailAnchor;\n                        if (seq[i] === -1) {\n                            parent.insertBefore(node, ref);\n                        }\n                        else if (!lis[i]) {\n                            parent.insertBefore(node, ref);\n                        }\n                        anchor = node;\n                    }\n                }\n                instances.length = 0;\n                for (let i = 0; i < newNodes.length; i++)\n                    instances.push(newNodes[i]);\n            };\n            const dir = { type: 'for', expression };\n            const effect = self._createEffect(update, dir);\n            dir.update = effect;\n            self._addDirective(placeholder, dir);\n        }\n        _resolveNodeByPath(root, path) {\n            let node = root;\n            for (let i = 0; i < path.length; i++) {\n                let idx = 0;\n                let child = node.firstElementChild;\n                while (child && idx < path[i]) {\n                    child = child.nextElementSibling;\n                    idx++;\n                }\n                node = child || node;\n            }\n            return node;\n        }\n        _computeLISMask(seq) {\n            const predecessors = new Array(seq.length);\n            const tails = [];\n            const tailIdx = [];\n            for (let i = 0; i < seq.length; i++) {\n                const v = seq[i];\n                if (v < 0) {\n                    predecessors[i] = -1;\n                    continue;\n                }\n                let lo = 0, hi = tails.length;\n                while (lo < hi) {\n                    const mid = (lo + hi) >> 1;\n                    if (seq[tails[mid]] < v)\n                        lo = mid + 1;\n                    else\n                        hi = mid;\n                }\n                if (lo === tails.length) {\n                    tails.push(i);\n                }\n                else {\n                    tails[lo] = i;\n                }\n                predecessors[i] = lo > 0 ? tails[lo - 1] : -1;\n                tailIdx[lo] = i;\n            }\n            const lisLen = tails.length;\n            const lis = new Array(seq.length).fill(false);\n            let k = lisLen ? tails[lisLen - 1] : -1;\n            while (k >= 0) {\n                lis[k] = true;\n                k = predecessors[k];\n            }\n            return { lisMask: lis, lisLen };\n        }\n        _render() {\n            const self = this;\n            for (const directives of self._directives.values()) {\n                for (const dr of directives) {\n                    if (XTOOL_ENABLE_STATIC_DIRECTIVES && dr._static)\n                        continue;\n                    if (dr.update) {\n                        try {\n                            dr.update();\n                        }\n                        catch (error) {\n                            if (!(error instanceof ReferenceError)) { }\n                        }\n                    }\n                }\n            }\n        }\n    }\n    ReactiveComponent._BA = {\n        itemscope: 1, formnovalidate: 1, novalidate: 1, default: 1, readonly: 1\n    };\n    const xTool = new XToolFramework();\n    return xTool;\n}();\nif (typeof window !== 'undefined') {\n    const w = window;\n    w.XTool = XToolFramework;\n    w.FyneJS = XToolFramework;\n}\n//# sourceMappingURL=x-tool.js.map"],"mappings":"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","ignoreList":[]}
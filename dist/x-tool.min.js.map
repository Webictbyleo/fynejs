{"version":3,"file":"x-tool.min.js","names":["ARRAY_ISARRAY","Array","isArray","WkMap","WeakMap","quMct","queueMicrotask","XToolFramework","_Afrom","from","_AisArr","_Okeys","Object","keys","_logErr","STR_STYLE","STR_DISPLAY","STR_NONE","STR_TAGNAME","STR_TEMPLATE","STR_LENGTH","XTOOL_ENABLE_STATIC_DIRECTIVES","d","document","STR_CONTENTS","EV_DELEGATED","head","getElementById","style","createElement","id","textContent","appendChild","PFX","attrCache","Map","attrName","name","cached","get","value","set","ReactiveComponent","attachToParent","parent","this","_parent","_addChild","_id","framework","_framework","element","_element","el","isBound","_isBound","v","isMounted","_isMounted","isDestroyed","_isDestroyed","_abortInvokerResources","byKind","_invokerResources","values","cleanup","clear","_cancelUserResources","setFrozen","on","_isFrozen","_sealedBeforeFreeze","_isSealed","_scheduleRender","_setSealed","_addDirective","directive","existing","_directives","push","constructor","def","_propUpdateActive","_runningPropEffect","_beforeMountCalled","_children","_computed","_propEffects","_computedCache","_computedDeps","_isInComputedEvaluation","_isInMethodExecution","_allEffects","Set","_hasComputed","_cleanupFunctions","_directiveAbort","AbortController","_targetIds","_targetSeq","_isMutationEnabled","_effectsToRun","_currentInvoker","_loopScopes","_expressionCache","_propertyDependencies","_activeEffect","_renderScheduled","_nextTickQueue","_changeFrameId","_renderFrameId","_initialClassSets","_rawData","_propParent","_callLifecycleHook","hookName","hook","_lifecycle","_safeExecute","_runWithGlobalInterception","_addCleanupFunction","fn","wrapped","delete","add","_originalMethods","methods","computed","propEffects","length","mounted","unmounted","destroyed","updated","beforeMount","beforeUnmount","beforeDestroy","data","_data","_createReactiveData","_methods","_bindMethods","callBeforeMount","_onDataChange","_property","self","cancelAnimationFrame","effectsToRun","directDeps","i","requestAnimationFrame","fid","effect","boundMethods","methodName","originalMethod","args","prev","prevInv","_getComputedValue","key","_trackDependency","has","computeFn","call","_createMethodContext","e","propKey","deps","includes","_render","q","splice","fallback","error","bindToElement","completeBinding","getContext","includeComputed","_applyAsyncTemplateResolved","_parseDirectives","_getComponentByElement","_registerElement","child","_removeChild","index","indexOf","src","String","test","body","trim","Function","undefined","_createContextProxy","apply","destroy","directives","type","customDirective","unbind","abort","_runCleanupCallbacks","_propEffect","idx","_unregisterElement","_deepReactiveCache","_unregisterComponent","_initReactiveProps","expr","evalFn","update","obj","ctx","$props","k","_listen","event","handler","options","signal","addEventListener","capture","merged","_targetKey","target","toString","processElement","isRoot","hasAttribute","isComponentTag","prefixDash","prefixColon","directiveNames","hasTextOrHtml","forName","names","getAttributeNames","startsWith","_bindDirective","getAttribute","attr","_bindTextInterpolationsIn","_walkElements","nodes","childNodes","node","nodeType","Node","TEXT_NODE","textNode","raw","nodeValue","__x_ti_bound","segs","charCodeAt","run","start","close","text","slice","repeat","code","nextEsc","nextOpen","end","some","s","literalOut","map","join","evaluators","_createElementEvaluator","out","ei","dirInfo","expression","_createEffect","processor","firstElementChild","next","nextElementSibling","directiveName","isShortBind","removeAttribute","_bindAttributeDirective","_bindSimpleDirective","_bindModelDirective","_bindIfDirective","_bindForDirective","prefix","rest","split","suffix","mods","modifiers","reduce","acc","m","_getCustomDirective","_bindCustomDirective","_bindEventDirective","updateFn","directiveRef","_static","found","evaluator","originalDisplay","_prevShown","innerHTML","property","isCheckbox","isNumeric","isMultiSelect","tagName","multiple","Reflect","defineProperty","configurable","enumerable","writable","getValueEvaluator","setValueEvaluator","_createEvaluator","checkboxValue","loopScope","_collectLoopScope","inferCheckboxValue","member","checked","sel","arr","opt","selected","setInputValue","t","parseFloat","getInputValue","currentVal","forEach","$value","placeholder","createComment","parentNode","insertBefore","__x_if_anchorParent","parentElement","branches","makeActualElement","wrapper","content","cloneNode","isTemplate","first","firstEval","__x_tool_bound","originalNodes","sib","isElse","isElseIf","branch","active","orig","removeChild","mountBranch","b","__x_if_current","nextSibling","cb","unmountBranch","eventName","trimmed","arrow","_extractArrowFunction","opts","once","passive","onlySelf","shouldPrevent","prevent","shouldStop","stop","isOutside","outside","deferExec","defer","keyAliasMap","enter","esc","escape","space","tab","backspace","del","arrowup","arrowdown","arrowleft","arrowright","home","pageup","pagedown","comboRequirements","ctrl","alt","shift","meta","buttonMap","left","middle","right","touchSingle","single","touchMulti","multi","modifierKeys","allowedKeys","aliases","toLowerCase","allowedButtons","btn","needKeyCheck","needButtonCheck","needTouchCheck","passesFilters","path","composedPath","tgt","contains","TouchEvent","tCount","touches","MouseEvent","button","KeyboardEvent","ctrlKey","altKey","shiftKey","metaKey","hasExpr","runExpr","thisCtx","compiledArrow","_compileArrowForEvent","paramsList","isBlock","mapArgs","_","isStatement","executor","result","createEventHandler","preventDefault","stopPropagation","ev","canDelegate","_getConfig","delegate","remover","_registerDelegated","filter","comp","ownerDocument","compiled","match","params","p","Boolean","endsWith","_wrapData","parentKey","getPrototypeOf","prototype","proxy","Proxy","receiver","Symbol","iterator","Error","beforeLen","beforeFirst","beforeLast","ownKeys","had","oldValue","deleteProperty","ok","pc","eff","_includeComputed","specials","$log","$destroy","$forceUpdate","$addCleanupFunction","$nextTick","Promise","resolve","$el","$id","$isMounted","$isDestroyed","$isSealed","$isFrozen","$parent","$children","$seal","$mutate","prevMethod","propStr","_target","targetElement","component","mergedScope","scopeKeys","gWindow","window","gDocument","cfg","sandbox","sandboxExpressions","allow","allowGlobals","ensureInvoker","registerResource","kind","setup","inv","wrapTarget","prop","optSig","removeEventListener","querySelector","querySelectorAll","doc","win","defaultView","bind","wrapObserverCtor","Orig","observerArgs","observe","disconnect","unobserve","inst","$target","$event","setTimeout","ms","clearTimeout","setInterval","clearInterval","MutationObserver","ResizeObserver","IntersectionObserver","_t","_name","directiveInfo","attributeName","baseSet","oc","className","cls","elAny","propName","camel","replace","c","toUpperCase","isBooleanProp","hasNonFunctionProp","isKnownBooleanAttr","_BA","base","size","tokens","tk","classList","toggle","cssText","assign","boolVal","setAttribute","normalized","parts","cur","anchorParent","scope","_updateElementDirectives","root","Element","itemVar","indexVar","listCode","templateToClone","contextAnchor","listEval","instances","createScope","item","idxOrKey","objIds","objSeq","keyFor","_i","primSeen","explicit","o","extractId","n","dir","norm","list","keysArr","newKeys","oldByKey","__x_for_key","newNodes","curRef","__x_itemRef","clone","oldKeys","different","before","dr","itemscope","formnovalidate","novalidate","default","readonly","_components","_byEl","_pending","_config","_customDirectives","_namedComponentDefs","_delegated","_delegatedRootBound","registerComponent","definition","_getRegisteredComponentDef","_preDiscoveryTasks","init","config","container","debug","staticDirectives","_hpf","async","_applyPrefixInitialCSS","allSettled","_autoDiscoverComponents","_ensureRootObserver","_ensureDelegation","readyState","_inflightComponentLoads","_lazyComponentSources","loadComponents","sources","items","mode","tasks","it","_fetchAndEvalComponent","catch","then","inferredName","pop","status","results","settled","failed","r","createComponent","_generateComponentId","componentElements","_bindElementAsComponent","reusable","_instantiateNamedComponent","_processPending","components","lastComponent","maybe","parentForEval","dataExpression","parentCtx","_parseDataExpression","initExpr","existingMounted","isConnected","now","Date","random","Math","substring","componentId","_log","retries","baseDelay","html","strings","str","attempt","fetch","cache","res","statusText","err","delay","pow","finally","_rootObserver","records","addedNodes","removedNodes","stack","_onComponentSourceChanged","ro","childList","subtree","attributes","attributeFilter","source","parentComp","lazy","promise","par","props","dynamicPropObj","rawPropExpression","propExpr","initDef","baseData","makeData","compDef","originalChildren","replaceChildren","template","applyTemplate","tpl","slots","slotEl","matched","replaceWith","tplVal","append","nested","cancelBubble","h","captureEvents","bubbleEvents","entry","l","w","XTool","FyneJS"],"sourceRoot":"./dist","sources":["dist/x-tool.js"],"sourcesContent":["\"use strict\";\nconst ARRAY_ISARRAY = Array.isArray;\nconst WkMap = WeakMap;\nconst quMct = queueMicrotask;\nconst FT_C = true;\nconst FT_TI = typeof __FEAT_TEXT_INTERP__ === 'boolean' ? __FEAT_TEXT_INTERP__ : true;\nconst _FT_DR = typeof __FEAT_DEEP_REACTIVE__ === 'boolean' ? __FEAT_DEEP_REACTIVE__ : true;\nconst FT_IFB = typeof __FEAT_IF_BRANCHES__ === 'boolean' ? __FEAT_IF_BRANCHES__ : true;\nconst XToolFramework = function () {\n    const _Afrom = Array.from;\n    const _AisArr = ARRAY_ISARRAY;\n    const _Okeys = Object.keys;\n    const _logErr = (..._args) => { };\n    const STR_STYLE = 'style';\n    const STR_DISPLAY = 'display';\n    const STR_NONE = 'none';\n    const STR_TAGNAME = 'tagName';\n    const STR_TEMPLATE = 'TEMPLATE';\n    const STR_LENGTH = 'length';\n    let XTOOL_ENABLE_STATIC_DIRECTIVES = true;\n    const d = (typeof document !== 'undefined' ? document : null);\n    const STR_CONTENTS = 'contents';\n    const EV_CLICK = 'click', EV_INPUT = 'input', EV_CHANGE = 'change', EV_KEYDOWN = 'keydown', EV_KEYUP = 'keyup';\n    const EV_DELEGATED = [EV_CLICK, EV_INPUT, EV_CHANGE, EV_KEYDOWN, EV_KEYUP];\n    const LS_PENDING = 0, LS_LOADING = 1, LS_LOADED = 2, LS_ERROR = 3;\n    try {\n        if (d && d.head && !d.getElementById('x-tool-initial-css')) {\n            const style = d.createElement(STR_STYLE);\n            style.id = 'x-tool-initial-css';\n            style.textContent = '[x-show],[x-if],[x-else],[x-else-if],[x\\\\:show],[x\\\\:if],[x\\\\:else],[x\\\\:else-if]{display:none;}';\n            d.head.appendChild(style);\n        }\n    }\n    catch { }\n    let PFX = 'x';\n    let attrCache = new Map();\n    const attrName = (name) => {\n        const cached = attrCache.get(name);\n        if (cached)\n            return cached;\n        const value = `${PFX}-${name}`;\n        attrCache.set(name, value);\n        return value;\n    };\n    class XToolFramework {\n        constructor() {\n            this._components = new Map();\n            this._byEl = new WkMap();\n            this._pending = [];\n            this._config = {};\n            this._customDirectives = new Map();\n            this._namedComponentDefs = new Map();\n            this._delegated = new WkMap();\n            this._delegatedRootBound = false;\n            this.directive = (name, directive) => {\n                if (name.startsWith(PFX + '-')) {\n                    throw new Error(`Custom directive names should not start with \"${PFX}-\". Use: XTool.directive(\"my-directive\", ...)`);\n                }\n                this._customDirectives.set(name, directive);\n                return this;\n            };\n            this.registerComponent = (definition) => {\n                if (!definition || !definition.name)\n                    throw new Error('registerComponent requires a name');\n                const name = definition.name.toLowerCase();\n                if (this._namedComponentDefs.has(name))\n                    throw new Error(`Component name \"${name}\" already registered`);\n                this._namedComponentDefs.set(name, definition);\n                return this;\n            };\n            this._getRegisteredComponentDef = (name) => this._namedComponentDefs.get(name.toLowerCase());\n            this._getCustomDirective = (name) => this._customDirectives.get(name);\n            this._getConfig = () => this._config;\n            this._preDiscoveryTasks = [];\n            this.init = (config = {}) => {\n                this._config = { container: 'body', debug: false, staticDirectives: true, ...config };\n                if (typeof this._config.staticDirectives === 'boolean') {\n                    XTOOL_ENABLE_STATIC_DIRECTIVES = this._config.staticDirectives;\n                }\n                const _hpf = this._config.prefix;\n                if (_hpf && typeof _hpf === 'string' && _hpf[STR_LENGTH] > 0) {\n                    PFX = _hpf;\n                }\n                else {\n                    PFX = 'x';\n                }\n                attrCache.clear();\n                const start = async () => {\n                    this._applyPrefixInitialCSS();\n                    if (this._preDiscoveryTasks.length) {\n                        try {\n                            await Promise.allSettled(this._preDiscoveryTasks);\n                        }\n                        catch { }\n                    }\n                    this._autoDiscoverComponents();\n                    const c = d?.querySelector(this._config.container);\n                    if (c) {\n                        this._ensureRootObserver(c);\n                        if (this._config.delegate)\n                            this._ensureDelegation(c);\n                    }\n                };\n                if (d && d.readyState === 'loading') {\n                    d.addEventListener('DOMContentLoaded', () => { void start(); });\n                }\n                else if (!d || d.readyState === 'complete' || d.readyState === 'interactive') {\n                    void start();\n                }\n                return this;\n            };\n            this._inflightComponentLoads = new Map();\n            this._lazyComponentSources = new Map();\n            this.loadComponents = (sources) => {\n                const items = sources.map(s => typeof s === 'string' ? { path: s, mode: 'preload', name: undefined } : { path: s.path, mode: (s.mode || 'preload'), name: s.name });\n                const tasks = [];\n                for (const it of items) {\n                    if (it.mode === 'defer') {\n                        const p = this._fetchAndEvalComponent(it.path).catch(() => { throw new Error('load failed'); });\n                        this._preDiscoveryTasks.push(p);\n                        tasks.push(p.then(() => { }));\n                    }\n                    else if (it.mode === 'lazy') {\n                        const inferredName = (it.name || it.path.split('/').pop() || '').replace(/\\.(mjs|js|ts)(\\?.*)?$/i, '').toLowerCase();\n                        if (inferredName && !this._lazyComponentSources.has(inferredName)) {\n                            this._lazyComponentSources.set(inferredName, { path: it.path, status: LS_PENDING });\n                        }\n                    }\n                    else {\n                        const p = this._fetchAndEvalComponent(it.path).catch(() => { throw new Error('load failed'); });\n                        tasks.push(p);\n                    }\n                }\n                return Promise.allSettled(tasks).then(results => {\n                    try {\n                        this._autoDiscoverComponents();\n                    }\n                    catch { }\n                    const settled = results.length;\n                    const failed = results.filter(r => r.status === 'rejected').length;\n                    return { settled, failed };\n                });\n            };\n            this.createComponent = (definition) => {\n                const component = new ReactiveComponent(this._generateComponentId(), definition, this);\n                this._components.set(component.id, component);\n                component.callBeforeMount();\n                return component;\n            };\n            this._autoDiscoverComponents = () => {\n                const container = d?.querySelector(this._config.container);\n                if (!container)\n                    return;\n                const componentElements = container.querySelectorAll(`[${attrName('data')}]`);\n                for (const element of componentElements) {\n                    if (!this._getComponentByElement(element))\n                        this._bindElementAsComponent(element);\n                }\n                const reusable = container.querySelectorAll('component[source]');\n                for (const el of reusable) {\n                    if (!this._getComponentByElement(el))\n                        this._instantiateNamedComponent(el);\n                }\n                this._processPending();\n                if (componentElements[STR_LENGTH] === 0 && !this._getComponentByElement(container)) {\n                    const components = _Afrom(this._components.values());\n                    const lastComponent = components[components[STR_LENGTH] - 1];\n                    if (lastComponent && !lastComponent.isBound) {\n                        lastComponent.bindToElement(container);\n                    }\n                }\n            };\n            this._processPending = () => {\n                if (!this._pending[STR_LENGTH])\n                    return;\n                for (const p of this._pending) {\n                    let cur = p.el.parentElement;\n                    let parent;\n                    while (cur && !parent) {\n                        const maybe = this._getComponentByElement(cur);\n                        if (maybe)\n                            parent = maybe;\n                        else\n                            cur = cur.parentElement;\n                    }\n                    if (parent) {\n                        p.comp.attachToParent(parent);\n                    }\n                }\n                for (const p of this._pending)\n                    p.comp.completeBinding();\n                this._pending = [];\n            };\n            this._bindElementAsComponent = (element, parentForEval) => {\n                const dataExpression = element.getAttribute(attrName('data'));\n                let data = {};\n                if (dataExpression) {\n                    element.removeAttribute(attrName('data'));\n                    try {\n                        if (parentForEval) {\n                            let parentCtx = {};\n                            try {\n                                parentCtx = parentForEval._createMethodContext?.() || {};\n                            }\n                            catch {\n                                parentCtx = {};\n                            }\n                            const evalFn = new Function('parent', `with(parent){ return (${dataExpression}) }`);\n                            data = evalFn(parentCtx);\n                        }\n                        else {\n                            data = this._parseDataExpression(dataExpression);\n                        }\n                        if (data.methods) {\n                            data = { methods: data.methods, data: { ...data } };\n                        }\n                        else {\n                            data = { data: { ...data } };\n                        }\n                        if (parentForEval) {\n                            data.data.$parent = parentForEval;\n                        }\n                    }\n                    catch (e) {\n                    }\n                }\n                const comp = this.createComponent(data);\n                comp.element = element;\n                comp.callBeforeMount();\n                this._registerElement(comp.element, comp);\n                this._pending.push({ el: element, comp });\n                const initExpr = element.getAttribute(attrName('init'));\n                if (initExpr) {\n                    element.removeAttribute(attrName('init'));\n                    const existingMounted = comp._lifecycle?.mounted;\n                    comp._lifecycle.mounted = function () {\n                        if (existingMounted) {\n                            try {\n                                existingMounted.call(this);\n                            }\n                            catch { }\n                        }\n                        const evaluator = new Function('ctx', 'with(ctx){' + initExpr + '} ');\n                        quMct(() => {\n                            if (comp.isDestroyed || !comp.element || !comp.element.isConnected)\n                                return;\n                            try {\n                                const ctx = comp._createMethodContext?.() || comp.getContext?.() || {};\n                                const result = evaluator(ctx);\n                                if (typeof result === 'function') {\n                                    try {\n                                        result();\n                                    }\n                                    catch { }\n                                }\n                            }\n                            catch { }\n                        });\n                    };\n                }\n            };\n            this._generateComponentId = () => {\n                const now = Date.now();\n                const random = Math.random().toString(36).substring(2, 15);\n                const counter = (this._components.size + 1).toString(36);\n                return `component_${now}_${counter}_${random}`;\n            };\n            this._parseDataExpression = (expression) => {\n                try {\n                    return new Function('return ' + expression.trim())();\n                }\n                catch {\n                    return {};\n                }\n            };\n            this._unregisterComponent = (componentId) => { this._components.delete(componentId); };\n            this._log = (..._args) => { };\n            this._registerElement = (element, component) => {\n                this._byEl.set(element, component);\n            };\n            this._unregisterElement = (element) => { try {\n                this._byEl.delete(element);\n            }\n            catch { } };\n        }\n        _fetchAndEvalComponent(path, retries = 2, baseDelay = 300) {\n            const existing = this._inflightComponentLoads.get(path);\n            if (existing)\n                return existing;\n            const self = this;\n            const html = (strings, ...values) => strings.reduce((acc, str, i) => acc + str + (i < values.length ? values[i] : ''), '');\n            const attempt = (n) => {\n                return fetch(path, { cache: 'no-cache' }).then(res => {\n                    if (!res.ok)\n                        throw new Error(res.status + ' ' + res.statusText);\n                    return res.text();\n                }).then(code => {\n                    const wrapped = code + `\\n//# sourceURL=${path}`;\n                    new Function('XTool', 'html', wrapped)(self, html);\n                }).catch(err => {\n                    if (n >= retries)\n                        throw err;\n                    const delay = baseDelay * Math.pow(2, n);\n                    return new Promise(resolve => setTimeout(resolve, delay)).then(() => attempt(n + 1));\n                });\n            };\n            const p = attempt(0).finally(() => { this._inflightComponentLoads.delete(path); });\n            this._inflightComponentLoads.set(path, p);\n            return p;\n        }\n        _applyPrefixInitialCSS() {\n            if (!d)\n                return;\n            if (PFX === 'x')\n                return;\n            const id = `x-tool-initial-css-${PFX}`;\n            if (d.head && !d.getElementById(id)) {\n                const style = d.createElement(STR_STYLE);\n                style.id = id;\n                style.textContent = `[${PFX}-show],[${PFX}-if],[${PFX}-else],[${PFX}-else-if],[${PFX}\\\\:show],[${PFX}\\\\:if],[${PFX}\\\\:else],[${PFX}\\\\:else-if]{display:none;}`;\n                d.head.appendChild(style);\n            }\n        }\n        _ensureRootObserver(container) {\n            if (this._rootObserver || typeof MutationObserver === 'undefined')\n                return;\n            this._rootObserver = new MutationObserver(records => {\n                for (const r of records) {\n                    if (r.type === 'childList') {\n                        for (let i = 0; i < r.addedNodes.length; i++) {\n                            const n = r.addedNodes[i];\n                            if (n.nodeType !== 1)\n                                continue;\n                            const el = n;\n                            if (el[STR_TAGNAME] === 'COMPONENT') {\n                                const src = el.getAttribute('source');\n                                if (src && !this._getComponentByElement(el))\n                                    this._instantiateNamedComponent(el);\n                            }\n                        }\n                        for (let i = 0; i < r.removedNodes.length; i++) {\n                            const n = r.removedNodes[i];\n                            if (n.nodeType !== 1)\n                                continue;\n                            const el = n;\n                            quMct(() => {\n                                if (el.isConnected)\n                                    return;\n                                const stack = [el];\n                                while (stack.length) {\n                                    const cur = stack.pop();\n                                    const comp = this._getComponentByElement(cur);\n                                    if (comp && !comp.isDestroyed) {\n                                        try {\n                                            comp.destroy();\n                                        }\n                                        catch { }\n                                    }\n                                    let child = cur.firstElementChild;\n                                    while (child) {\n                                        stack.push(child);\n                                        child = child.nextElementSibling;\n                                    }\n                                }\n                            });\n                        }\n                    }\n                    else if (r.type === 'attributes') {\n                        const target = r.target;\n                        if (target && target[STR_TAGNAME] === 'COMPONENT') {\n                            if (r.attributeName === 'source') {\n                                this._onComponentSourceChanged(target);\n                            }\n                            else if (r.attributeName === 'readonly') {\n                                const comp = this._getComponentByElement(target);\n                                if (comp) {\n                                    try {\n                                        const ro = target.hasAttribute('readonly');\n                                        comp.setFrozen(!!ro);\n                                    }\n                                    catch { }\n                                }\n                            }\n                        }\n                    }\n                }\n                this._processPending();\n            });\n            this._rootObserver.observe(container, { childList: true, subtree: true, attributes: true, attributeFilter: ['source', 'readonly'] });\n        }\n        _onComponentSourceChanged(el) {\n            const src = (el.getAttribute('source') || '').trim();\n            const existing = this._getComponentByElement(el);\n            if (!src) {\n                if (existing && !existing.isDestroyed) {\n                    try {\n                        existing.destroy();\n                    }\n                    catch { }\n                }\n                el.innerHTML = '';\n                return;\n            }\n            if (existing && !existing.isDestroyed) {\n                try {\n                    existing.destroy();\n                }\n                catch { }\n            }\n            el.innerHTML = '';\n            this._instantiateNamedComponent(el);\n        }\n        _instantiateNamedComponent(el) {\n            const source = el.getAttribute('source');\n            if (!source)\n                return;\n            let def = this._getRegisteredComponentDef(source);\n            if (!def) {\n                const name = source.toLowerCase();\n                const lazy = this._lazyComponentSources?.get(name);\n                if (lazy) {\n                    if (lazy.status === LS_PENDING) {\n                        lazy.status = LS_LOADING;\n                        lazy.promise = this._fetchAndEvalComponent(lazy.path)\n                            .then(() => { lazy.status = LS_LOADED; })\n                            .catch(() => { lazy.status = LS_ERROR; });\n                    }\n                    lazy.promise?.then(() => { try {\n                        const again = this._getRegisteredComponentDef(source);\n                        if (again)\n                            this._instantiateNamedComponent(el);\n                    }\n                    catch { } });\n                }\n                return;\n            }\n            let parentComp;\n            let par = el.parentElement;\n            while (par && !parentComp) {\n                const maybe = this._getComponentByElement(par);\n                if (maybe)\n                    parentComp = maybe;\n                else\n                    par = par.parentElement;\n            }\n            let props = null;\n            let dynamicPropObj = null;\n            let rawPropExpression = null;\n            if (!props)\n                props = {};\n            const propExpr = el.getAttribute(attrName('prop'));\n            if (propExpr) {\n                rawPropExpression = propExpr;\n                if (parentComp) {\n                    try {\n                        const fn = new Function('ctx', 'with(ctx){return (' + propExpr + ')}');\n                        const ctx = parentComp.getContext(true);\n                        dynamicPropObj = fn(ctx);\n                    }\n                    catch {\n                        dynamicPropObj = null;\n                    }\n                }\n                else {\n                    try {\n                        dynamicPropObj = new Function('return (' + propExpr + ')')();\n                    }\n                    catch {\n                        dynamicPropObj = null;\n                    }\n                }\n                if (dynamicPropObj && typeof dynamicPropObj === 'object')\n                    for (const k in dynamicPropObj)\n                        if (!(k in props))\n                            props[k] = String(dynamicPropObj[k]);\n                el.removeAttribute(attrName('prop'));\n            }\n            let baseData = {};\n            if (def.makeData) {\n                try {\n                    baseData = def.makeData(props) || {};\n                }\n                catch {\n                    baseData = {};\n                }\n            }\n            if (def.data) {\n                for (const k in def.data) {\n                    baseData[k] = def.data[k];\n                }\n            }\n            for (const k in props) {\n                if (!(k in baseData))\n                    baseData[k] = props[k];\n            }\n            baseData.$props = props;\n            let initDef;\n            if (typeof def.init === 'function') {\n                try {\n                    const maybe = def.init(props);\n                    initDef = (maybe && typeof maybe === 'object') ? maybe : undefined;\n                }\n                catch {\n                    initDef = undefined;\n                }\n            }\n            const compDef = {\n                data: baseData,\n                methods: { ...(def.methods || {}), ...(initDef?.methods || {}) },\n                computed: { ...(def.computed || {}), ...(initDef?.computed || {}) },\n                propEffects: { ...(def.propEffects || {}), ...(initDef?.propEffects || {}) },\n                mounted: initDef?.mounted || def.mounted,\n                unmounted: initDef?.unmounted || def.unmounted,\n                beforeMount: initDef?.beforeMount || def.beforeMount,\n                beforeUnmount: initDef?.beforeUnmount || def.beforeUnmount,\n                updated: initDef?.updated || def.updated,\n                destroyed: initDef?.destroyed || def.destroyed,\n                beforeDestroy: initDef?.beforeDestroy || def.beforeDestroy\n            };\n            const comp = this.createComponent(compDef);\n            comp.element = el;\n            const originalChildren = Array.from(el.childNodes);\n            if (originalChildren.length)\n                el.replaceChildren();\n            if (def.template) {\n                const applyTemplate = (tpl) => {\n                    el.innerHTML = tpl;\n                    const slots = el.querySelectorAll('slot');\n                    if (slots.length) {\n                        for (const slotEl of slots) {\n                            const name = slotEl.getAttribute('name');\n                            const matched = name\n                                ? originalChildren.filter(n => n.nodeType === 1 && n.getAttribute('slot') === name)\n                                : originalChildren.filter(n => n.nodeType !== 1 || !n.hasAttribute('slot'));\n                            if (matched.length)\n                                slotEl.replaceWith(...matched);\n                        }\n                    }\n                };\n                const tplVal = def.template;\n                if (typeof tplVal === 'string') {\n                    applyTemplate(tplVal);\n                }\n                else if (typeof tplVal === 'function') {\n                    try {\n                        const res = tplVal();\n                        if (res && typeof res.then === 'function') {\n                            el.innerHTML = '';\n                            res.then(html => { applyTemplate(html || ''); try {\n                                comp._applyAsyncTemplateResolved();\n                            }\n                            catch { } });\n                        }\n                        else {\n                            applyTemplate(String(res || ''));\n                        }\n                    }\n                    catch {\n                        el.innerHTML = '';\n                    }\n                }\n                else if (tplVal && typeof tplVal.then === 'function') {\n                    el.innerHTML = '';\n                    tplVal.then(html => { applyTemplate(html || ''); try {\n                        comp._applyAsyncTemplateResolved();\n                    }\n                    catch { } });\n                }\n            }\n            else {\n                if (originalChildren.length)\n                    el.append(...originalChildren);\n            }\n            this._registerElement(el, comp);\n            try {\n                const nested = el.querySelectorAll(`[${attrName('data')}]`);\n                for (const node of nested) {\n                    if (!this._getComponentByElement(node))\n                        this._bindElementAsComponent(node, comp);\n                }\n            }\n            catch { }\n            this._pending.push({ el, comp });\n            if (rawPropExpression && parentComp) {\n                try {\n                    comp._initReactiveProps(rawPropExpression, parentComp);\n                }\n                catch { }\n            }\n            this._processPending();\n        }\n        _getComponentByElement(element) { return this._byEl.get(element); }\n        observe(_element) { }\n        _ensureDelegation(container) {\n            if (this._delegatedRootBound)\n                return;\n            const root = container;\n            const handler = (e) => {\n                let cur = e.target;\n                while (cur && cur !== root.parentElement) {\n                    if (e.cancelBubble)\n                        break;\n                    const map = this._delegated.get(cur);\n                    if (map) {\n                        const list = map.get(e.type);\n                        if (list && list.length) {\n                            for (const h of [...list]) {\n                                try {\n                                    if (h.comp && h.comp.isDestroyed) {\n                                        const i = list.indexOf(h);\n                                        if (i > -1)\n                                            list.splice(i, 1);\n                                        continue;\n                                    }\n                                    if (!h.filter || h.filter(e)) {\n                                        h.run(e);\n                                        if (h.once) {\n                                            const idx = list.indexOf(h);\n                                            if (idx > -1)\n                                                list.splice(idx, 1);\n                                        }\n                                    }\n                                }\n                                catch { }\n                            }\n                        }\n                    }\n                    cur = cur.parentElement;\n                }\n            };\n            const captureEvents = ['keydown', 'keyup'];\n            const bubbleEvents = ['click', 'input', 'change'];\n            for (const ev of captureEvents)\n                root.addEventListener(ev, handler, true);\n            for (const ev of bubbleEvents)\n                root.addEventListener(ev, handler, false);\n            this._delegatedRootBound = true;\n        }\n        _registerDelegated(element, event, entry) {\n            let map = this._delegated.get(element);\n            if (!map) {\n                map = new Map();\n                this._delegated.set(element, map);\n            }\n            let list = map.get(event);\n            if (!list) {\n                list = [];\n                map.set(event, list);\n            }\n            list.push(entry);\n            return () => {\n                try {\n                    const m = this._delegated.get(element);\n                    const l = m?.get(event);\n                    if (!l)\n                        return;\n                    const idx = l.indexOf(entry);\n                    if (idx > -1)\n                        l.splice(idx, 1);\n                }\n                catch { }\n            };\n        }\n    }\n    class ReactiveComponent {\n        attachToParent(parent) {\n            this._parent = parent;\n            parent._addChild(this);\n        }\n        get id() { return this._id; }\n        get framework() { return this._framework; }\n        get element() { return this._element; }\n        set element(el) { this._element = el; }\n        get isBound() { return this._isBound; }\n        set isBound(v) { this._isBound = v; }\n        get isMounted() { return this._isMounted; }\n        set isMounted(v) { this._isMounted = v; }\n        get isDestroyed() { return this._isDestroyed; }\n        set isDestroyed(v) { this._isDestroyed = v; }\n        _abortInvokerResources() {\n            for (const byKind of this._invokerResources.values()) {\n                for (const cleanup of byKind.values()) {\n                    try {\n                        cleanup();\n                    }\n                    catch { }\n                }\n            }\n            this._invokerResources.clear();\n        }\n        _cancelUserResources() {\n            this._abortInvokerResources();\n        }\n        setFrozen(on) {\n            if (on === this._isFrozen)\n                return;\n            this._isFrozen = on;\n            if (on) {\n                this._sealedBeforeFreeze = this._isSealed;\n                this._isSealed = true;\n                this._cancelUserResources();\n            }\n            else {\n                if (this._sealedBeforeFreeze !== null) {\n                    this._isSealed = this._sealedBeforeFreeze;\n                }\n                else {\n                    this._isSealed = false;\n                }\n                this._sealedBeforeFreeze = null;\n                try {\n                    this._scheduleRender();\n                }\n                catch { }\n            }\n        }\n        _setSealed(on) {\n            if (on === this._isSealed)\n                return;\n            this._isSealed = on;\n            if (on) {\n                this._cancelUserResources();\n            }\n        }\n        _addDirective(element, directive) {\n            const existing = this._directives.get(element) || [];\n            existing.push(directive);\n            this._directives.set(element, existing);\n        }\n        constructor(id, def, framework) {\n            this._propUpdateActive = false;\n            this._runningPropEffect = false;\n            this._element = null;\n            this._isBound = false;\n            this._isMounted = false;\n            this._isDestroyed = false;\n            this._beforeMountCalled = false;\n            this._children = [];\n            this._parent = null;\n            this._computed = {};\n            this._propEffects = {};\n            this._computedCache = new Map();\n            this._computedDeps = new Map();\n            this._isInComputedEvaluation = false;\n            this._isInMethodExecution = false;\n            this._allEffects = new Set();\n            this._hasComputed = false;\n            this._directives = new Map();\n            this._cleanupFunctions = new Set();\n            this._directiveAbort = new AbortController();\n            this._invokerResources = new Map();\n            this._targetIds = new WkMap();\n            this._targetSeq = 0;\n            this._isSealed = false;\n            this._isFrozen = false;\n            this._sealedBeforeFreeze = null;\n            this._isMutationEnabled = true;\n            this._effectsToRun = new Set();\n            this._currentInvoker = null;\n            this._loopScopes = new WkMap();\n            this._expressionCache = new Map();\n            this._propertyDependencies = new Map();\n            this._activeEffect = null;\n            this._renderScheduled = false;\n            this._nextTickQueue = [];\n            this._changeFrameId = null;\n            this._renderFrameId = null;\n            this._initialClassSets = new WkMap();\n            this._rawData = {};\n            this._propParent = null;\n            this._callLifecycleHook = (hookName) => {\n                const hook = this._lifecycle[hookName];\n                if (typeof hook === 'function') {\n                    this._safeExecute(() => this._runWithGlobalInterception(hook, []));\n                }\n            };\n            this._addCleanupFunction = (fn) => {\n                if (typeof fn !== 'function')\n                    return undefined;\n                const wrapped = () => {\n                    try {\n                        fn();\n                    }\n                    catch { }\n                    this._cleanupFunctions.delete(wrapped);\n                };\n                this._cleanupFunctions.add(wrapped);\n                return () => { this._cleanupFunctions.delete(wrapped); };\n            };\n            this._id = id;\n            this._framework = framework;\n            this._originalMethods = def.methods || {};\n            this._computed = def.computed || {};\n            this._propEffects = def.propEffects || {};\n            this._hasComputed = !!(def.computed && Object.keys(def.computed).length);\n            this._lifecycle = {\n                mounted: def.mounted,\n                unmounted: def.unmounted || def.destroyed,\n                updated: def.updated,\n                beforeMount: def.beforeMount,\n                beforeUnmount: def.beforeUnmount || def.beforeDestroy\n            };\n            this._rawData = def.data || {};\n            this._data = this._createReactiveData(this._rawData || {});\n            this._methods = this._bindMethods();\n        }\n        callBeforeMount() {\n            if (!this._beforeMountCalled) {\n                this._callLifecycleHook('beforeMount');\n                this._beforeMountCalled = true;\n            }\n        }\n        _onDataChange(_property) {\n            if (this.isBound) {\n                const self = this;\n                if (self._changeFrameId != null) {\n                    try {\n                        cancelAnimationFrame(self._changeFrameId);\n                    }\n                    catch { }\n                }\n                if (this._isMutationEnabled === false)\n                    return;\n                const effectsToRun = self._effectsToRun;\n                const directDeps = self._propertyDependencies.get(_property);\n                if (directDeps)\n                    for (let i = 0; i < directDeps.length; i++)\n                        effectsToRun.add(directDeps[i]);\n                self._changeFrameId = requestAnimationFrame(() => {\n                    if (FT_C)\n                        self._computedCache.clear();\n                    const fid = self._changeFrameId;\n                    self._changeFrameId = null;\n                    if (fid != null) {\n                        try {\n                            cancelAnimationFrame(fid);\n                        }\n                        catch { }\n                    }\n                    if (self.isDestroyed || self._isSealed)\n                        return;\n                    for (const effect of effectsToRun)\n                        self._safeExecute(effect);\n                    effectsToRun.clear();\n                    if (self._hasComputed || !XTOOL_ENABLE_STATIC_DIRECTIVES) {\n                        self._scheduleRender();\n                    }\n                    self._callLifecycleHook('updated');\n                });\n            }\n        }\n        _bindMethods() {\n            const boundMethods = {};\n            for (const methodName in this._originalMethods) {\n                const originalMethod = this._originalMethods[methodName];\n                boundMethods[methodName] = (...args) => {\n                    const prev = this._isInMethodExecution;\n                    const prevInv = this._currentInvoker;\n                    this._isInMethodExecution = true;\n                    this._currentInvoker = methodName;\n                    try {\n                        return this._safeExecute(() => this._runWithGlobalInterception(originalMethod, args));\n                    }\n                    finally {\n                        this._isInMethodExecution = prev;\n                        this._currentInvoker = prevInv;\n                    }\n                };\n            }\n            return boundMethods;\n        }\n        _getComputedValue(key) {\n            if (!FT_C)\n                return undefined;\n            this._trackDependency(key);\n            if (this._computedCache.has(key))\n                return this._computedCache.get(key);\n            try {\n                const computeFn = this._computed[key];\n                this._isInComputedEvaluation = true;\n                this._computedDeps.set(key, new Set());\n                const value = computeFn.call(this._createMethodContext());\n                this._isInComputedEvaluation = false;\n                this._computedCache.set(key, value);\n                return value;\n            }\n            catch (e) {\n                this._isInComputedEvaluation = false;\n                return undefined;\n            }\n        }\n        _trackDependency(propKey) {\n            if (!this._activeEffect)\n                return;\n            let deps = this._propertyDependencies.get(propKey);\n            if (!deps) {\n                deps = [];\n                this._propertyDependencies.set(propKey, deps);\n            }\n            if (!deps.includes(this._activeEffect))\n                deps.push(this._activeEffect);\n        }\n        _scheduleRender() {\n            if (this._isSealed || this._isFrozen || this._isDestroyed)\n                return;\n            if (this._renderScheduled)\n                return;\n            this._renderScheduled = true;\n            requestAnimationFrame(() => {\n                const fid = this._renderFrameId;\n                this._renderFrameId = null;\n                if (fid != null) {\n                    try {\n                        cancelAnimationFrame(fid);\n                    }\n                    catch { }\n                }\n                this._renderScheduled = false;\n                if (this._isDestroyed || this._isSealed) {\n                    if (this._nextTickQueue && this._nextTickQueue.length)\n                        this._nextTickQueue.length = 0;\n                    return;\n                }\n                this._render();\n                if (this._nextTickQueue && this._nextTickQueue.length) {\n                    const q = this._nextTickQueue.splice(0, this._nextTickQueue.length);\n                    for (const fn of q) {\n                        try {\n                            fn();\n                        }\n                        catch { }\n                    }\n                }\n            });\n        }\n        _safeExecute(fn, fallback) {\n            try {\n                return fn();\n            }\n            catch (error) {\n                console.error(error);\n                return fallback;\n            }\n        }\n        bindToElement(element) {\n            if (this._isBound)\n                return;\n            this._element = element;\n            if (!this._beforeMountCalled) {\n                this.callBeforeMount();\n            }\n            this.completeBinding();\n        }\n        getContext(includeComputed = true) {\n            return this._createMethodContext(includeComputed);\n        }\n        _applyAsyncTemplateResolved() {\n            if (!this._element)\n                return;\n            try {\n                this._parseDirectives(this._element);\n            }\n            catch { }\n            this._scheduleRender();\n        }\n        completeBinding() {\n            if (this._isBound || !this._element)\n                return;\n            if (!this._framework._getComponentByElement(this._element))\n                this._framework._registerElement(this._element, this);\n            this._isBound = true;\n            this._isMounted = true;\n            this._parseDirectives(this._element);\n            this._render();\n            this._callLifecycleHook('mounted');\n        }\n        _addChild(child) {\n            if (!this._children.includes(child)) {\n                this._children.push(child);\n            }\n        }\n        _removeChild(child) {\n            const index = this._children.indexOf(child);\n            if (index > -1) {\n                this._children.splice(index, 1);\n            }\n        }\n        _runWithGlobalInterception(fn, args) {\n            try {\n                const src = String(fn);\n                if (!/\\[native code\\]/.test(src)) {\n                    let body = src.trim();\n                    if (!/^function[\\s\\(]/.test(body) && !/^[\\w\\$_][\\w\\d\\$_]*\\s*=>/.test(body) && !/^\\(.*?\\)\\s*=>/.test(body)) {\n                        body = 'function ' + body;\n                    }\n                    const trySrc = 'with(ctx){ const f = (' + body + '); return f.apply(thisArg, argsArray); }';\n                    const wrapper = new Function('thisArg', 'argsArray', 'ctx', trySrc);\n                    return wrapper.call(undefined, this._createMethodContext(), args, this._createContextProxy(undefined, undefined));\n                }\n            }\n            catch {\n            }\n            return fn.apply(this._createMethodContext(), args);\n        }\n        destroy() {\n            const self = this;\n            if (self._isDestroyed)\n                return;\n            self._callLifecycleHook('beforeUnmount');\n            for (const child of self._children) {\n                if (!child.isDestroyed)\n                    child.destroy();\n            }\n            if (self._parent) {\n                self._parent._removeChild(self);\n            }\n            for (const [element, directives] of self._directives) {\n                for (const directive of directives) {\n                    if (directive.type === 'custom' && directive.customDirective?.unbind) {\n                        try {\n                            directive.customDirective.unbind(element, self);\n                        }\n                        catch {\n                            _logErr();\n                        }\n                    }\n                }\n            }\n            self._directives.clear();\n            try {\n                self._directiveAbort.abort();\n            }\n            catch { }\n            self._directiveAbort = new AbortController();\n            self._abortInvokerResources();\n            self._runCleanupCallbacks();\n            self._computedCache.clear();\n            self._expressionCache.clear();\n            self._propertyDependencies.clear();\n            if (self._propParent && self._propEffect) {\n                for (const deps of self._propParent._propertyDependencies.values()) {\n                    const idx = deps.indexOf(self._propEffect);\n                    if (idx > -1)\n                        deps.splice(idx, 1);\n                }\n            }\n            if (self._element)\n                self._framework._unregisterElement(self._element);\n            if (self._changeFrameId != null) {\n                try {\n                    cancelAnimationFrame(self._changeFrameId);\n                }\n                catch { }\n                ;\n                self._changeFrameId = null;\n            }\n            if (self._renderFrameId != null) {\n                try {\n                    cancelAnimationFrame(self._renderFrameId);\n                }\n                catch { }\n                ;\n                self._renderFrameId = null;\n            }\n            self._callLifecycleHook('unmounted');\n            self._isDestroyed = true;\n            self._isMounted = false;\n            self._isBound = false;\n            self._children = [];\n            self._parent = null;\n            this._deepReactiveCache = new WkMap;\n            this._effectsToRun.clear();\n            self._element = null;\n            quMct(() => self._framework._unregisterComponent(self._id));\n            this._data = {};\n            this._rawData = {};\n            this._methods = {};\n            this._computed = {};\n            this._propEffects = {};\n            this._activeEffect = null;\n        }\n        _initReactiveProps(expr, parent) {\n            if (!expr || !parent)\n                return;\n            this._propParent = parent;\n            let evalFn;\n            try {\n                evalFn = new Function('ctx', 'with(ctx){return (' + expr + ')}');\n            }\n            catch {\n                return;\n            }\n            const update = () => {\n                parent._activeEffect = update;\n                let obj;\n                try {\n                    const ctx = parent.getContext(true);\n                    obj = evalFn(ctx);\n                }\n                catch {\n                    obj = null;\n                }\n                parent._activeEffect = null;\n                if (obj && typeof obj === 'object') {\n                    this._data.$props = this._data.$props || {};\n                    this._propUpdateActive = true;\n                    for (const k in obj) {\n                        const v = obj[k];\n                        if (this._data[k] !== v)\n                            this._data[k] = v;\n                    }\n                    this._propUpdateActive = false;\n                }\n            };\n            this._propEffect = update;\n            update();\n        }\n        _runCleanupCallbacks() {\n            for (const fn of this._cleanupFunctions) {\n                try {\n                    fn();\n                }\n                catch { }\n            }\n            this._cleanupFunctions.clear();\n        }\n        _listen(element, event, handler, options) {\n            const signal = this._directiveAbort.signal;\n            if (typeof options === 'boolean') {\n                element.addEventListener(event, handler, { capture: options, signal });\n            }\n            else if (options) {\n                const merged = options.signal && options.signal !== signal\n                    ? options\n                    : { ...options, signal };\n                element.addEventListener(event, handler, merged);\n            }\n            else {\n                element.addEventListener(event, handler, { signal });\n            }\n        }\n        _targetKey(target) {\n            let id = this._targetIds.get(target);\n            if (!id) {\n                id = (++this._targetSeq).toString(36);\n                this._targetIds.set(target, id);\n            }\n            return id;\n        }\n        _parseDirectives(element) {\n            const self = this;\n            let processedElements = 0;\n            const processElement = (el, isRoot = false) => {\n                if (!isRoot && (el.hasAttribute(attrName('data')) || this._framework._getComponentByElement(el))) {\n                    return false;\n                }\n                const isComponentTag = el[STR_TAGNAME] === 'COMPONENT';\n                const prefixDash = PFX + '-';\n                const prefixColon = PFX + ':';\n                const directiveNames = [];\n                let hasTextOrHtml = false;\n                let forName = null;\n                const names = el.getAttributeNames();\n                for (let i = 0; i < names.length; i++) {\n                    const name = names[i];\n                    if (name.startsWith(prefixDash) || name.startsWith(prefixColon)) {\n                        directiveNames.push(name);\n                        if (!hasTextOrHtml && (name === attrName('text') || name === attrName('html')))\n                            hasTextOrHtml = true;\n                        if (!forName && name === attrName('for'))\n                            forName = name;\n                    }\n                }\n                if (directiveNames.length > 0) {\n                    processedElements++;\n                    if (forName) {\n                        self._bindDirective(el, forName, el.getAttribute(forName) || '');\n                        return false;\n                    }\n                    for (const attr of directiveNames) {\n                        self._bindDirective(el, attr, el.getAttribute(attr) || '');\n                    }\n                }\n                if (FT_TI && !hasTextOrHtml)\n                    self._bindTextInterpolationsIn(el);\n                return isRoot || !isComponentTag;\n            };\n            processElement(element, true);\n            self._walkElements(element, processElement);\n        }\n        _bindTextInterpolationsIn(el) {\n            const nodes = Array.from(el.childNodes);\n            for (const node of nodes) {\n                if (node.nodeType !== Node.TEXT_NODE)\n                    continue;\n                const textNode = node;\n                const raw = textNode.nodeValue || '';\n                if (textNode.__x_ti_bound || raw.indexOf('{{') === -1)\n                    continue;\n                const segs = [];\n                let i = 0;\n                while (i < raw.length) {\n                    const ch = raw.charCodeAt(i);\n                    if (ch === 92) {\n                        let run = 0;\n                        const start = i;\n                        while (i < raw.length && raw.charCodeAt(i) === 92) {\n                            run++;\n                            i++;\n                        }\n                        if (raw.startsWith('{{', i)) {\n                            const close = raw.indexOf('}}', i + 2);\n                            if (close === -1) {\n                                segs.push({ type: 'lit', text: raw.slice(start) });\n                                break;\n                            }\n                            if (run > 1)\n                                segs.push({ type: 'lit', text: '\\\\'.repeat(run - 1) });\n                            segs.push({ type: 'lit', text: raw.slice(i, close + 2) });\n                            i = close + 2;\n                            continue;\n                        }\n                        segs.push({ type: 'lit', text: raw.slice(start, i) });\n                        continue;\n                    }\n                    if (raw.startsWith('{{', i)) {\n                        const close = raw.indexOf('}}', i + 2);\n                        if (close === -1) {\n                            segs.push({ type: 'lit', text: raw.slice(i) });\n                            break;\n                        }\n                        const expr = raw.slice(i + 2, close).trim();\n                        if (expr.length === 0)\n                            segs.push({ type: 'lit', text: '{{}}' });\n                        else\n                            segs.push({ type: 'expr', code: expr });\n                        i = close + 2;\n                        continue;\n                    }\n                    const nextEsc = raw.indexOf('\\\\', i);\n                    const nextOpen = raw.indexOf('{{', i);\n                    let end = raw.length;\n                    if (nextEsc !== -1 && nextEsc < end)\n                        end = nextEsc;\n                    if (nextOpen !== -1 && nextOpen < end)\n                        end = nextOpen;\n                    segs.push({ type: 'lit', text: raw.slice(i, end) });\n                    i = end;\n                }\n                const hasExpr = segs.some(s => s.type === 'expr');\n                if (!hasExpr) {\n                    textNode.__x_ti_bound = true;\n                    const literalOut = segs.map(s => s.text || '').join('');\n                    if (textNode.textContent !== literalOut)\n                        textNode.textContent = literalOut;\n                    continue;\n                }\n                const evaluators = [];\n                for (const s of segs)\n                    if (s.type === 'expr')\n                        evaluators.push(this._createElementEvaluator(s.code, el));\n                textNode.__x_ti_bound = true;\n                const update = () => {\n                    let out = '';\n                    let ei = 0;\n                    for (const s of segs) {\n                        if (s.type === 'lit')\n                            out += s.text;\n                        else {\n                            const v = evaluators[ei++]();\n                            out += (v == null ? '' : String(v));\n                        }\n                    }\n                    if (textNode.textContent !== out)\n                        textNode.textContent = out;\n                };\n                const dirInfo = { type: 'text-interpolation', expression: raw, update: undefined };\n                this._addDirective(el, dirInfo);\n                const effect = this._createEffect(update, dirInfo);\n                dirInfo.update = effect;\n            }\n        }\n        _walkElements(parent, processor) {\n            let child = parent.firstElementChild;\n            while (child) {\n                const next = child.nextElementSibling;\n                if (processor(child))\n                    this._walkElements(child, processor);\n                child = next;\n            }\n        }\n        _bindDirective(element, directiveName, expression) {\n            const self = this;\n            const isShortBind = directiveName.startsWith(PFX + ':');\n            const type = directiveName.slice(PFX.length + 1);\n            if (isShortBind || type === 'class' || type === STR_STYLE) {\n                element.removeAttribute(directiveName);\n                return self._bindAttributeDirective(element, type, expression);\n            }\n            if (type === 'text' || type === 'html' || type === 'show') {\n                element.removeAttribute(directiveName);\n                return self._bindSimpleDirective(element, expression, type);\n            }\n            const handled = type === 'model' ? (element.removeAttribute(directiveName), self._bindModelDirective(element, expression), true)\n                : type === 'if' ? (element.removeAttribute(directiveName), self._bindIfDirective(element, expression), true)\n                    : type === 'for' ? (element.removeAttribute(directiveName), self._bindForDirective(element, expression), true)\n                        : false;\n            if (handled)\n                return;\n            if (type.indexOf(':') > -1) {\n                const [prefix, rest] = type.split(':', 2);\n                const [suffix, ...mods] = rest.split('.');\n                const modifiers = mods.reduce((acc, m) => { if (m)\n                    acc[m] = true; return acc; }, {});\n                if (prefix === 'on') {\n                    element.removeAttribute(directiveName);\n                    const customDirective = self.framework._getCustomDirective(suffix);\n                    return customDirective\n                        ? self._bindCustomDirective(element, suffix, expression, customDirective, modifiers)\n                        : self._bindEventDirective(element, suffix, expression, modifiers);\n                }\n                element.removeAttribute(directiveName);\n                return self._bindAttributeDirective(element, suffix, expression);\n            }\n        }\n        _createEffect(updateFn, directiveRef) {\n            const effect = () => {\n                this._activeEffect = effect;\n                try {\n                    updateFn();\n                }\n                finally {\n                    this._activeEffect = null;\n                }\n            };\n            effect();\n            this._allEffects.add(effect);\n            if (XTOOL_ENABLE_STATIC_DIRECTIVES && directiveRef && directiveRef._static === undefined) {\n                let found = false;\n                for (const deps of this._propertyDependencies.values()) {\n                    if (deps.includes(effect)) {\n                        found = true;\n                        break;\n                    }\n                }\n                directiveRef._static = !found;\n            }\n            return effect;\n        }\n        _bindSimpleDirective(element, expression, type) {\n            if (type === 'class' || type === STR_STYLE) {\n                return this._bindAttributeDirective(element, type, expression);\n            }\n            const evaluator = this._createElementEvaluator(expression, element);\n            let originalDisplay;\n            if (type === 'show') {\n                const el = element;\n                originalDisplay = el.style[STR_DISPLAY] !== STR_NONE ? el.style[STR_DISPLAY] : undefined;\n            }\n            let _prevShown = undefined;\n            const update = () => {\n                const value = evaluator();\n                const el = element;\n                switch (type) {\n                    case 'text':\n                        el.textContent = String(value);\n                        break;\n                    case 'html':\n                        el.innerHTML = String(value || '');\n                        break;\n                    case 'show':\n                        const next = !!value;\n                        if (_prevShown === next)\n                            return;\n                        _prevShown = next;\n                        el.style[STR_DISPLAY] = next ? (originalDisplay || '') : STR_NONE;\n                        break;\n                }\n            };\n            const dirInfo = { type, expression, update: undefined, originalDisplay };\n            this._addDirective(element, dirInfo);\n            const effect = this._createEffect(update, dirInfo);\n            dirInfo.update = effect;\n        }\n        _bindModelDirective(element, property) {\n            const isCheckbox = element.type === 'checkbox';\n            const isNumeric = element.type === 'number' || element.type === 'range';\n            const isMultiSelect = element.tagName === 'SELECT' && element.multiple === true;\n            if (!Reflect.has(this._data, property)) {\n                Reflect.defineProperty(this._data, property, {\n                    'configurable': true,\n                    'enumerable': true,\n                    'writable': true\n                });\n            }\n            const getValueEvaluator = this._createElementEvaluator(property, element);\n            const setValueEvaluator = this._createEvaluator(`${property} = $value`, true);\n            const inferCheckboxValue = () => {\n                if (element.hasAttribute('value'))\n                    return element.value;\n                const loopScope = this._collectLoopScope(element);\n                if (loopScope) {\n                    const keys = Object.keys(loopScope);\n                    if (keys.length === 1)\n                        return loopScope[keys[0]];\n                }\n                return element.value;\n            };\n            const checkboxValue = isCheckbox ? inferCheckboxValue() : undefined;\n            const getInputValue = () => {\n                if (isCheckbox) {\n                    if (Array.isArray(getValueEvaluator()) && checkboxValue !== undefined) {\n                        return element.checked ? checkboxValue : undefined;\n                    }\n                    if (element.hasAttribute('value'))\n                        return element.checked ? element.value : undefined;\n                    return element.checked;\n                }\n                if (isMultiSelect) {\n                    const sel = element;\n                    const values = [];\n                    for (let i = 0; i < sel.options.length; i++) {\n                        const opt = sel.options[i];\n                        if (opt.selected)\n                            values.push(opt.value);\n                    }\n                    return values;\n                }\n                return isNumeric ? parseFloat(element.value) || 0 : element.value;\n            };\n            const setInputValue = (value) => {\n                if (isCheckbox) {\n                    if (Array.isArray(value)) {\n                        const member = element.hasAttribute('value') ? element.value : checkboxValue;\n                        element.checked = member != null ? value.includes(member) : false;\n                    }\n                    else {\n                        element.checked = !!value;\n                    }\n                    return;\n                }\n                if (isMultiSelect) {\n                    const sel = element;\n                    const arr = Array.isArray(value) ? value : [];\n                    for (let i = 0; i < sel.options.length; i++) {\n                        const opt = sel.options[i];\n                        opt.selected = arr.includes(opt.value);\n                    }\n                    return;\n                }\n                element.value = String(value ?? (isNumeric ? 0 : ''));\n            };\n            this._createEffect(() => setInputValue(getValueEvaluator()));\n            const ctx = this._createContextProxy(undefined, element);\n            const updateData = () => {\n                const raw = getInputValue();\n                const currentVal = this._safeExecute(() => getValueEvaluator());\n                if (isCheckbox && Array.isArray(currentVal)) {\n                    const arr = currentVal;\n                    const member = element.hasAttribute('value') ? element.value : checkboxValue;\n                    if (member !== undefined) {\n                        const idx = arr.indexOf(member);\n                        if (element.checked) {\n                            if (idx === -1)\n                                arr.push(member);\n                        }\n                        else if (idx > -1) {\n                            arr.splice(idx, 1);\n                        }\n                    }\n                }\n                else if (isMultiSelect && Array.isArray(currentVal)) {\n                    const arr = currentVal;\n                    arr.splice(0, arr.length);\n                    raw.forEach(v => arr.push(v));\n                }\n                else {\n                    ctx.$value = raw;\n                    this._safeExecute(() => { setValueEvaluator.call(this._createMethodContext(), ctx); });\n                }\n            };\n            const t = element.type;\n            const eventType = (element[STR_TAGNAME] === 'SELECT' || t === 'checkbox' || t === 'radio' || t === 'file') ? 'change' : 'input';\n            this._listen(element, eventType, updateData);\n            this._addDirective(element, { type: 'model', property });\n        }\n        _bindIfDirective(element, expression) {\n            const self = this;\n            const placeholder = d.createComment('x-if');\n            element.parentNode?.insertBefore(placeholder, element);\n            element.__x_if_anchorParent = placeholder.parentElement || null;\n            const branches = [];\n            const makeActualElement = (el) => {\n                if (el[STR_TAGNAME] === STR_TEMPLATE) {\n                    const wrapper = d.createElement('div');\n                    wrapper.style[STR_DISPLAY] = STR_CONTENTS;\n                    wrapper.appendChild(el.content.cloneNode(true));\n                    return { el: wrapper, isTemplate: true };\n                }\n                return { el: el, isTemplate: false };\n            };\n            const first = makeActualElement(element);\n            const firstEval = self._createElementEvaluator(expression, element);\n            branches.push({ el: first.el, test: firstEval, isTemplate: first.isTemplate });\n            if (!first.isTemplate)\n                first.el.__x_tool_bound = true;\n            const originalNodes = [element];\n            if (FT_IFB) {\n                if (FT_IFB) {\n                    let sib = element.nextElementSibling;\n                    while (sib) {\n                        const isElse = sib.hasAttribute('x-else');\n                        const isElseIf = sib.hasAttribute('x-else-if');\n                        if (!isElse && !isElseIf)\n                            break;\n                        if (sib.hasAttribute('x-else-if')) {\n                            const attr = sib.getAttribute('x-else-if') || '';\n                            const branch = makeActualElement(sib);\n                            const evalFn = self._createElementEvaluator((attr || '').trim(), sib);\n                            branches.push({ el: branch.el, test: evalFn, isTemplate: branch.isTemplate });\n                            if (!branch.isTemplate)\n                                branch.el.__x_tool_bound = true;\n                        }\n                        else {\n                            const branch = makeActualElement(sib);\n                            branches.push({ el: branch.el, test: null, isTemplate: branch.isTemplate });\n                            if (!branch.isTemplate)\n                                branch.el.__x_tool_bound = true;\n                        }\n                        sib.removeAttribute('x-else');\n                        sib.removeAttribute('x-else-if');\n                        originalNodes.push(sib);\n                        sib = sib.nextElementSibling;\n                    }\n                }\n            }\n            let active = -1;\n            for (const orig of originalNodes) {\n                if (orig.parentNode)\n                    orig.parentNode.removeChild(orig);\n            }\n            const mountBranch = (idx) => {\n                if (idx < 0)\n                    return;\n                const b = branches[idx];\n                if (!b.el.__x_tool_bound) {\n                    self._parseDirectives(b.el);\n                    b.el.__x_tool_bound = true;\n                }\n                element.__x_if_current?.parentNode?.removeChild(element.__x_if_current);\n                if (!b.el.parentNode) {\n                    placeholder.parentNode?.insertBefore(b.el, placeholder.nextSibling);\n                }\n                element.__x_if_current = b.el;\n                active = idx;\n            };\n            const unmountBranch = (idx, cb) => {\n                if (idx < 0) {\n                    if (cb)\n                        cb();\n                    return;\n                }\n                const b = branches[idx];\n                if (b.el.parentNode) {\n                    if (b.el.parentNode)\n                        b.el.parentNode.removeChild(b.el);\n                    if (cb)\n                        cb();\n                }\n                else if (cb)\n                    cb();\n                active = -1;\n            };\n            const update = () => {\n                let next = -1;\n                for (let i = 0; i < branches[STR_LENGTH]; i++) {\n                    const b = branches[i];\n                    const pass = b.test ? !!b.test() : true;\n                    if (pass) {\n                        next = i;\n                        break;\n                    }\n                }\n                if (next === active)\n                    return;\n                if (active !== -1) {\n                    unmountBranch(active, () => mountBranch(next));\n                }\n                else {\n                    mountBranch(next);\n                }\n            };\n            const effect = self._createEffect(update);\n            self._addDirective(element, { type: 'if', expression, update: effect });\n        }\n        _bindEventDirective(element, eventName, expression, modifiers) {\n            const self = this;\n            const trimmed = (expression || '').trim();\n            const arrow = self._extractArrowFunction(trimmed);\n            const opts = modifiers ? {\n                once: !!modifiers.once,\n                passive: !!modifiers.passive,\n                capture: !!modifiers.capture,\n            } : undefined;\n            const onlySelf = !!modifiers?.self;\n            const shouldPrevent = !!modifiers?.prevent;\n            const shouldStop = !!modifiers?.stop;\n            const isOutside = !!modifiers?.outside;\n            const deferExec = !!modifiers?.defer;\n            const keyAliasMap = {\n                enter: ['enter'],\n                esc: ['escape', 'esc'],\n                escape: ['escape', 'esc'],\n                space: [' ', 'space', 'spacebar'],\n                tab: ['tab'],\n                backspace: ['backspace'],\n                delete: ['delete', 'del'],\n                del: ['delete', 'del'],\n                arrowup: ['arrowup', 'up'],\n                arrowdown: ['arrowdown', 'down'],\n                arrowleft: ['arrowleft', 'left'],\n                arrowright: ['arrowright', 'right'],\n                home: ['home'],\n                end: ['end'],\n                pageup: ['pageup'],\n                pagedown: ['pagedown']\n            };\n            const comboRequirements = {\n                ctrl: !!modifiers?.ctrl,\n                alt: !!modifiers?.alt,\n                shift: !!modifiers?.shift,\n                meta: !!modifiers?.meta,\n            };\n            const buttonMap = { left: 0, middle: 1, right: 2 };\n            const touchSingle = !!modifiers?.single;\n            const touchMulti = !!modifiers?.multi;\n            const modifierKeys = modifiers ? _Okeys(modifiers) : [];\n            const allowedKeys = [];\n            for (const m of modifierKeys) {\n                const aliases = keyAliasMap[m.toLowerCase()];\n                if (aliases)\n                    allowedKeys.push(...aliases);\n            }\n            const allowedButtons = [];\n            for (const m of modifierKeys) {\n                const btn = buttonMap[m.toLowerCase()];\n                if (btn !== undefined)\n                    allowedButtons.push(btn);\n            }\n            const needKeyCheck = allowedKeys.length > 0 || comboRequirements.ctrl || comboRequirements.alt || comboRequirements.shift || comboRequirements.meta;\n            const needButtonCheck = allowedButtons.length > 0;\n            const needTouchCheck = touchSingle || touchMulti;\n            const passesFilters = (event) => {\n                const path = event.composedPath ? event.composedPath() : null;\n                const tgt = (path && path.length ? path[0] : event.target);\n                if (isOutside) {\n                    if (!tgt)\n                        return false;\n                    if (element instanceof Node && (element === tgt || element.contains(tgt)))\n                        return false;\n                }\n                if (onlySelf && event.target !== element)\n                    return false;\n                if (needTouchCheck) {\n                    if (event instanceof TouchEvent) {\n                        const tCount = event.touches.length;\n                        if (touchSingle && tCount !== 1)\n                            return false;\n                        if (touchMulti && tCount < 2)\n                            return false;\n                    }\n                    else\n                        return false;\n                }\n                if (needButtonCheck) {\n                    if (event instanceof MouseEvent) {\n                        if (!allowedButtons.includes(event.button))\n                            return false;\n                    }\n                    else\n                        return false;\n                }\n                if (needKeyCheck) {\n                    if (!(event instanceof KeyboardEvent))\n                        return false;\n                    const k = (event.key || '').toLowerCase();\n                    if (allowedKeys.length > 0 && !allowedKeys.includes(k))\n                        return false;\n                    if (comboRequirements.ctrl && !event.ctrlKey)\n                        return false;\n                    if (comboRequirements.alt && !event.altKey)\n                        return false;\n                    if (comboRequirements.shift && !event.shiftKey)\n                        return false;\n                    if (comboRequirements.meta && !event.metaKey)\n                        return false;\n                }\n                return true;\n            };\n            const hasExpr = !!trimmed;\n            let runExpr = null;\n            const thisCtx = self._createMethodContext();\n            if (arrow) {\n                const compiledArrow = self._compileArrowForEvent(arrow.paramsList, arrow.body, arrow.isBlock);\n                const mapArgs = arrow.paramsList.length\n                    ? (event) => arrow.paramsList.map((_, idx) => (idx === 0 ? event : idx === 1 ? element : undefined))\n                    : () => [];\n                runExpr = (event) => {\n                    const ctx = self._createContextProxy(event, element);\n                    compiledArrow.call(thisCtx, ctx, ...mapArgs(event));\n                };\n            }\n            else if (hasExpr) {\n                const isStatement = trimmed.includes(';');\n                const executor = self._createEvaluator(trimmed, isStatement);\n                runExpr = (event) => {\n                    const ctx = self._createContextProxy(event, element);\n                    const result = executor.call(thisCtx, ctx);\n                    if (typeof result === 'function')\n                        result.call(thisCtx, event);\n                };\n            }\n            const createEventHandler = (event) => {\n                if (!passesFilters(event))\n                    return;\n                if (shouldPrevent && typeof event.preventDefault === 'function')\n                    event.preventDefault();\n                if (shouldStop && typeof event.stopPropagation === 'function')\n                    event.stopPropagation();\n                if (!runExpr)\n                    return;\n                if (deferExec && typeof quMct === 'function') {\n                    const ev = event;\n                    quMct(() => self._safeExecute(() => runExpr(ev)));\n                    return;\n                }\n                self._safeExecute(() => runExpr(event));\n            };\n            const cfg = this.framework._getConfig();\n            const canDelegate = !!cfg.delegate && EV_DELEGATED.includes(eventName);\n            if (!isOutside && canDelegate) {\n                const remover = this.framework._registerDelegated(element, eventName, { filter: (e) => passesFilters(e), run: (e) => createEventHandler(e), once: !!modifiers?.once, comp: this });\n                this._addCleanupFunction(remover);\n            }\n            else {\n                const target = isOutside ? (element?.ownerDocument || d || document) : element;\n                self._listen(target, eventName, createEventHandler, opts);\n            }\n        }\n        _createEvaluator(expression, isStatement = false) {\n            const key = `${isStatement ? 's' : 'r'}:${expression}`;\n            let fn = this._expressionCache.get(key);\n            if (!fn) {\n                fn = new Function('ctx', `with(ctx){${isStatement ? expression : `return (${expression})`}}`);\n                this._expressionCache.set(key, fn);\n            }\n            return fn;\n        }\n        _createElementEvaluator(expression, element) {\n            const self = this;\n            const compiled = self._createEvaluator(expression);\n            return () => this._safeExecute(() => compiled.call(self._createMethodContext(), self._createContextProxy(undefined, element)));\n        }\n        _extractArrowFunction(expression) {\n            let m = expression.match(/^\\s*\\(\\s*([^)]*?)\\s*\\)\\s*=>\\s*([\\s\\S]+)$/);\n            if (!m)\n                m = expression.match(/^\\s*([a-zA-Z_$][a-zA-Z0-9_$]*)\\s*=>\\s*([\\s\\S]+)$/);\n            if (!m)\n                return null;\n            const params = (m[1] || '')\n                .split(',')\n                .map(p => p.trim())\n                .filter(Boolean);\n            const body = (m[2] || '').trim();\n            const isBlock = body.startsWith('{') && body.endsWith('}');\n            const finalBody = isBlock ? body.slice(1, -1) : body;\n            return { paramsList: params, body: finalBody, isBlock };\n        }\n        _compileArrowForEvent(params, body, isBlock) {\n            const content = isBlock ? body : 'return ( ' + body + ' );';\n            return new Function('ctx', ...params, 'with(ctx){ ' + content + ' }');\n        }\n        _wrapData(data, parentKey) {\n            if (!(Object.getPrototypeOf(data) === Object.prototype || ARRAY_ISARRAY(data)))\n                return data;\n            const self = this;\n            if (!this._deepReactiveCache)\n                this._deepReactiveCache = new WkMap();\n            if (this._deepReactiveCache.has(data))\n                return this._deepReactiveCache.get(data);\n            const proxy = new Proxy(data, {\n                get: (target, p, receiver) => {\n                    if (ARRAY_ISARRAY(target)) {\n                        if (p === Symbol.iterator) {\n                            self._trackDependency(parentKey);\n                            return Reflect.get(target, p, receiver);\n                        }\n                        if (p === 'length' || (typeof p === 'string' && /^\\d+$/.test(p))) {\n                            self._trackDependency(parentKey);\n                        }\n                    }\n                    else {\n                        self._trackDependency(parentKey);\n                    }\n                    const value = Reflect.get(target, p, receiver);\n                    if (ARRAY_ISARRAY(target) && typeof value === 'function' && ['push', 'pop', 'shift', 'unshift', 'splice', 'reverse', 'copyWithin', 'fill', 'sort'].includes(p)) {\n                        return function (...args) {\n                            if (self._isInComputedEvaluation) {\n                                const name = String(p);\n                                throw new Error(`[x-tool] Mutation via '${String(parentKey)}.${name}()' is not allowed during computed evaluation.`);\n                            }\n                            if (self._isFrozen) {\n                                const name = String(p);\n                                throw new Error(`[x-tool] Mutation via '${String(parentKey)}.${name}()' is not allowed while component is frozen.`);\n                            }\n                            const arr = target;\n                            const beforeLen = arr.length;\n                            const beforeFirst = arr[0];\n                            const beforeLast = arr[beforeLen - 1];\n                            const result = value.apply(target, args);\n                            if (!self._isSealed && (arr.length !== beforeLen || arr[0] !== beforeFirst || arr[arr.length - 1] !== beforeLast)) {\n                                self._onDataChange(parentKey);\n                            }\n                            return result;\n                        };\n                    }\n                    const type = typeof value;\n                    if (value && type === 'object') {\n                        return self._wrapData(value, parentKey);\n                    }\n                    return value;\n                },\n                ownKeys: (target) => { return Reflect.ownKeys(target); },\n                has: (target, key) => { return Reflect.has(target, key); },\n                set: (target, p, value) => {\n                    if (self._isDestroyed)\n                        return true;\n                    if (self._isInComputedEvaluation) {\n                        const key = String(parentKey) + (typeof p === 'symbol' ? '' : '.' + String(p));\n                        throw new Error(`[x-tool] Mutation of '${key}' is not allowed during computed evaluation.`);\n                    }\n                    if (self._isFrozen) {\n                        const key = String(parentKey) + (typeof p === 'symbol' ? '' : '.' + String(p));\n                        throw new Error(`[x-tool] Mutation of '${key}' is not allowed while component is frozen.`);\n                    }\n                    if (typeof p === 'symbol')\n                        return true;\n                    const had = Reflect.has(target, p);\n                    const oldValue = had ? Reflect.get(target, p) : undefined;\n                    if (value && typeof value === 'object') {\n                        value = self._wrapData(value, typeof p === 'symbol' ? parentKey : (String(parentKey) + '.' + String(p)));\n                    }\n                    if (!had) {\n                        try {\n                            Reflect.defineProperty(target, p, {\n                                configurable: true,\n                                enumerable: true,\n                                writable: true,\n                                value\n                            });\n                        }\n                        catch {\n                            Reflect.set(target, p, value);\n                        }\n                        self._onDataChange(parentKey);\n                        return true;\n                    }\n                    if (oldValue === value)\n                        return true;\n                    Reflect.set(target, p, value);\n                    if (!self._isSealed)\n                        self._onDataChange(parentKey);\n                    return true;\n                },\n                deleteProperty: (target, p) => {\n                    if (self._isInComputedEvaluation) {\n                        const key = String(parentKey) + (typeof p === 'symbol' ? '' : '.' + String(p));\n                        throw new Error(`[x-tool] Deletion of '${key}' is not allowed during computed evaluation.`);\n                    }\n                    if (self._isFrozen) {\n                        const key = String(parentKey) + (typeof p === 'symbol' ? '' : '.' + String(p));\n                        throw new Error(`[x-tool] Deletion of '${key}' is not allowed while component is frozen.`);\n                    }\n                    const ok = Reflect.deleteProperty(target, p);\n                    if (ok && !self._isSealed)\n                        self._onDataChange(parentKey);\n                    return ok;\n                }\n            });\n            this._deepReactiveCache.set(data, proxy);\n            return proxy;\n        }\n        _createReactiveData(data) {\n            const self = this;\n            return new Proxy(data, {\n                get: (target, property, receiver) => {\n                    const value = Reflect.get(target, property, receiver);\n                    if (property === Symbol.iterator)\n                        return value;\n                    if (typeof property !== 'symbol') {\n                        self._trackDependency(property);\n                    }\n                    if (value && typeof value === 'object') {\n                        return self._wrapData(value, property);\n                    }\n                    return value;\n                },\n                ownKeys: (target) => Reflect.ownKeys(target),\n                has: (target, key) => Reflect.has(target, key),\n                set: (target, property, value, receiver) => {\n                    if (self._isDestroyed)\n                        return true;\n                    if (self._isFrozen)\n                        return true;\n                    if (self._isInComputedEvaluation) {\n                        throw new Error(`[x-tool] Mutation of '${String(property)}' is not allowed during computed evaluation.`);\n                    }\n                    if (property === Symbol.iterator && ARRAY_ISARRAY(target))\n                        return value;\n                    const oldValue = Reflect.get(target, property);\n                    const had = Reflect.has(target, property);\n                    if (!had) {\n                        try {\n                            Reflect.defineProperty(target, property, {\n                                configurable: true,\n                                enumerable: true,\n                                writable: true,\n                                value\n                            });\n                        }\n                        catch {\n                            Reflect.set(target, property, value, receiver);\n                        }\n                    }\n                    else {\n                        Reflect.set(target, property, value, receiver);\n                    }\n                    if (!this._isSealed)\n                        this._onDataChange(property);\n                    if (this._propUpdateActive && property !== '$props') {\n                        const pc = target.$props;\n                        if (pc)\n                            pc[property] = value;\n                        const eff = this._propEffects[property];\n                        if (eff && !this._runningPropEffect && !this._isSealed) {\n                            this._runningPropEffect = true;\n                            this._safeExecute(() => eff.call(this._createMethodContext(), value, oldValue));\n                            this._runningPropEffect = false;\n                        }\n                    }\n                    return true;\n                }\n            });\n        }\n        _createMethodContext(_includeComputed = true) {\n            const specials = {\n                '$log': (..._args) => { },\n                '$destroy': () => this.destroy(),\n                '$forceUpdate': () => this._scheduleRender(),\n                '$addCleanupFunction': (fn) => this._addCleanupFunction(fn),\n                '$nextTick': (cb) => {\n                    if (cb) {\n                        this._nextTickQueue.push(cb);\n                        if (!this._renderScheduled)\n                            quMct(() => {\n                                if (!this._renderScheduled && this._nextTickQueue.length) {\n                                    const q = this._nextTickQueue.splice(0, this._nextTickQueue.length);\n                                    for (const fn of q) {\n                                        this._safeExecute(() => fn());\n                                    }\n                                }\n                            });\n                        return;\n                    }\n                    return new Promise(resolve => {\n                        this._nextTickQueue.push(() => resolve());\n                        if (!this._renderScheduled)\n                            quMct(() => {\n                                if (!this._renderScheduled && this._nextTickQueue.length) {\n                                    const q = this._nextTickQueue.splice(0, this._nextTickQueue.length);\n                                    for (const fn of q) {\n                                        this._safeExecute(() => fn());\n                                    }\n                                }\n                            });\n                    });\n                },\n                '$el': this._element,\n                '$id': this._id,\n                '$isMounted': this._isMounted,\n                '$isDestroyed': this._isDestroyed,\n                '$isSealed': this._isSealed,\n                '$isFrozen': this._isFrozen,\n                '$parent': this._parent,\n                '$children': this._children,\n                '$seal': (on = true) => { this._setSealed(!!on); },\n                '$mutate': (fn) => {\n                    const prevMethod = this._isInMethodExecution;\n                    this._isMutationEnabled = false;\n                    if (this._isInComputedEvaluation) {\n                        throw new Error('[x-tool] $mutate cannot be used inside computed evaluation; computed getters must be pure.');\n                    }\n                    this._isInMethodExecution = false;\n                    try {\n                        return typeof fn === 'function' ? fn() : undefined;\n                    }\n                    finally {\n                        this._isInMethodExecution = prevMethod;\n                        this._isMutationEnabled = true;\n                        this._scheduleRender();\n                    }\n                }\n            };\n            let data = this._data;\n            if (this._isInComputedEvaluation) {\n                data = (this._rawData);\n            }\n            return new Proxy(data, {\n                get: (target, propStr) => {\n                    if (propStr in target) {\n                        this._trackDependency(propStr);\n                        const v = target[propStr];\n                        return v;\n                    }\n                    if (FT_C && (propStr in this._computed)) {\n                        return this._getComputedValue(propStr);\n                    }\n                    if (propStr in specials)\n                        return specials[propStr];\n                    return this._methods[propStr];\n                },\n                set: (_target, propStr, value) => {\n                    if (this._isInComputedEvaluation) {\n                        throw new Error(`[x-tool] Mutation of '${String(propStr)}' is not allowed during computed evaluation.`);\n                    }\n                    if (this._isFrozen) {\n                        throw new Error(`[x-tool] Mutation of '${String(propStr)}' is not allowed while component is frozen.`);\n                    }\n                    this._data[propStr] = value;\n                    return true;\n                }\n            });\n        }\n        _createContextProxy(event, targetElement) {\n            const component = this;\n            const mergedScope = targetElement ? this._collectLoopScope(targetElement) : null;\n            const scopeKeys = mergedScope ? new Set(_Okeys(mergedScope)) : new Set();\n            const gWindow = (typeof window !== 'undefined' ? window : undefined);\n            const gDocument = (typeof document !== 'undefined' ? document : undefined);\n            const cfg = this.framework._getConfig();\n            const sandbox = !!cfg.sandboxExpressions;\n            const allow = new Set((cfg.allowGlobals || []).map(s => String(s)));\n            const ensureInvoker = () => this._currentInvoker || '__anonymous__';\n            const registerResource = (kind, setup) => {\n                const inv = ensureInvoker();\n                let byKind = this._invokerResources.get(inv);\n                if (!byKind) {\n                    byKind = new Map();\n                    this._invokerResources.set(inv, byKind);\n                }\n                const prev = byKind.get(kind);\n                if (prev) {\n                    try {\n                        prev();\n                    }\n                    catch { }\n                    byKind.delete(kind);\n                }\n                const cleanup = setup();\n                if (typeof cleanup === 'function') {\n                    const wrapped = () => {\n                        try {\n                            cleanup();\n                        }\n                        finally {\n                            byKind?.delete(kind);\n                        }\n                    };\n                    byKind.set(kind, wrapped);\n                    this._addCleanupFunction(wrapped);\n                }\n            };\n            const wrapTarget = (target) => {\n                if (!target || typeof target.addEventListener !== 'function')\n                    return target;\n                return new Proxy(target, {\n                    get: (obj, prop) => {\n                        if (prop === 'addEventListener') {\n                            return (eventName, handler, options) => {\n                                if (this._isSealed || this._isFrozen)\n                                    return;\n                                obj.addEventListener(eventName, handler, options);\n                                const optSig = typeof options === 'boolean' ? options : options?.capture ? '1' : '0';\n                                const key = 'listener:' + this._targetKey(obj) + ':' + eventName + ':' + optSig;\n                                registerResource(key, () => () => {\n                                    try {\n                                        obj.removeEventListener(eventName, handler, options);\n                                    }\n                                    catch { }\n                                });\n                            };\n                        }\n                        if (prop === 'removeEventListener') {\n                            return (eventName, handler, options) => {\n                                try {\n                                    obj.removeEventListener(eventName, handler, options);\n                                }\n                                catch { }\n                            };\n                        }\n                        if (prop === 'querySelector') {\n                            return (sel) => wrapTarget(obj.querySelector(sel));\n                        }\n                        if (prop === 'querySelectorAll') {\n                            return (sel) => Array.from(obj.querySelectorAll(sel)).map(wrapTarget);\n                        }\n                        if (prop === 'getElementById') {\n                            return (id) => wrapTarget(obj.getElementById(id));\n                        }\n                        if (prop === 'document') {\n                            const doc = obj.document;\n                            return wrapTarget(doc) || doc;\n                        }\n                        if (prop === 'defaultView') {\n                            const win = obj.defaultView;\n                            return wrapTarget(win) || win;\n                        }\n                        if (prop === 'body') {\n                            const body = obj.body;\n                            return wrapTarget(body) || body;\n                        }\n                        const value = obj[prop];\n                        if (typeof value === 'function') {\n                            try {\n                                return value.bind(obj);\n                            }\n                            catch {\n                                return value;\n                            }\n                        }\n                        return value;\n                    }\n                });\n            };\n            const ctxSetTimeout = (fn, ms, ...args) => {\n                if (this._isSealed || this._isFrozen || this._isDestroyed)\n                    return undefined;\n                const id = gWindow?.setTimeout?.(fn, ms, ...args);\n                if (id != null)\n                    registerResource('timeout', () => () => { try {\n                        gWindow?.clearTimeout?.(id);\n                    }\n                    catch { } });\n                return id;\n            };\n            const ctxSetInterval = (fn, ms, ...args) => {\n                if (this._isSealed || this._isFrozen)\n                    return undefined;\n                const id = gWindow?.setInterval?.(fn, ms, ...args);\n                if (id != null)\n                    registerResource('interval', () => () => { try {\n                        gWindow?.clearInterval?.(id);\n                    }\n                    catch { } });\n                return id;\n            };\n            const ctxRequestAnimationFrame = (cb) => {\n                if (this._isSealed || this._isFrozen)\n                    return undefined;\n                const id = gWindow?.requestAnimationFrame?.(cb);\n                if (id != null)\n                    registerResource('raf', () => () => { try {\n                        gWindow?.cancelAnimationFrame?.(id);\n                    }\n                    catch { } });\n                return id;\n            };\n            const wrapObserverCtor = (Orig, kind) => {\n                if (!Orig)\n                    return undefined;\n                return function (...observerArgs) {\n                    if (component._isSealed || component._isFrozen)\n                        return { observe() { }, disconnect() { }, unobserve() { } };\n                    const inst = new Orig(...observerArgs);\n                    registerResource('observer:' + kind, () => () => { try {\n                        inst.disconnect();\n                    }\n                    catch { } });\n                    return inst;\n                };\n            };\n            const specials = {\n                '$target': targetElement || null,\n                '$event': event || null,\n                ...(sandbox && !allow.has('setTimeout') ? {} : { 'setTimeout': ctxSetTimeout }),\n                ...(sandbox && !allow.has('clearTimeout') ? {} : { 'clearTimeout': (id) => { try {\n                        gWindow?.clearTimeout?.(id);\n                    }\n                    catch { } } }),\n                ...(sandbox && !allow.has('setInterval') ? {} : { 'setInterval': ctxSetInterval }),\n                ...(sandbox && !allow.has('clearInterval') ? {} : { 'clearInterval': (id) => { try {\n                        gWindow?.clearInterval?.(id);\n                    }\n                    catch { } } }),\n                ...(sandbox && !allow.has('requestAnimationFrame') ? {} : { 'requestAnimationFrame': ctxRequestAnimationFrame }),\n                ...(sandbox && !allow.has('cancelAnimationFrame') ? {} : { 'cancelAnimationFrame': (id) => { try {\n                        gWindow?.cancelAnimationFrame?.(id);\n                    }\n                    catch { } } }),\n                ...(sandbox && !allow.has('MutationObserver') ? {} : { 'MutationObserver': wrapObserverCtor(gWindow?.MutationObserver, 'mutation') }),\n                ...(sandbox && !allow.has('ResizeObserver') ? {} : { 'ResizeObserver': wrapObserverCtor(gWindow?.ResizeObserver, 'resize') }),\n                ...(sandbox && !allow.has('IntersectionObserver') ? {} : { 'IntersectionObserver': wrapObserverCtor(gWindow?.IntersectionObserver, 'intersection') }),\n                ...(sandbox && !allow.has('window') ? {} : { 'window': wrapTarget(gWindow) }),\n                ...(sandbox && !allow.has('document') ? {} : { 'document': wrapTarget(gDocument) })\n            };\n            return new Proxy({}, {\n                get: (_t, propStr) => {\n                    if (mergedScope && propStr in mergedScope)\n                        return mergedScope[propStr];\n                    if (propStr in component._data)\n                        return component._data[propStr];\n                    if (propStr in component._computed)\n                        return component._getComputedValue(propStr);\n                    if (propStr in component._methods)\n                        return component._methods[propStr];\n                    if (propStr in specials)\n                        return specials[propStr];\n                    return undefined;\n                },\n                set: (_t, propStr, value) => {\n                    if (mergedScope && scopeKeys.has(propStr)) {\n                        mergedScope[propStr] = value;\n                    }\n                    else {\n                        component._data[propStr] = value;\n                    }\n                    return true;\n                },\n                has: (_t, propStr) => !!(mergedScope && propStr in mergedScope) ||\n                    propStr in component._data ||\n                    propStr in component._computed ||\n                    propStr in component._methods ||\n                    propStr in specials\n            });\n        }\n        _bindCustomDirective(element, _name, expression, directive, modifiers) {\n            const self = this;\n            const evaluator = self._createElementEvaluator(expression, element);\n            const directiveInfo = { type: 'custom', expression, customDirective: directive };\n            if (directive.bind) {\n                self._safeExecute(() => directive.bind(element, evaluator(), expression, self, modifiers, evaluator));\n            }\n            const update = () => {\n                if (directive.update)\n                    self._safeExecute(() => directive.update(element, evaluator(), expression, self, modifiers, evaluator));\n            };\n            const effect = self._createEffect(update);\n            directiveInfo.update = effect;\n            self._addDirective(element, directiveInfo);\n        }\n        _bindAttributeDirective(element, attributeName, expression) {\n            const self = this;\n            const evaluator = self._createElementEvaluator(expression, element);\n            if (attributeName === 'class') {\n                const el = element;\n                if (!self._initialClassSets.get(el)) {\n                    const baseSet = new Set();\n                    const oc = el.className || '';\n                    if (oc)\n                        for (const cls of oc.split(/\\s+/)) {\n                            if (cls)\n                                baseSet.add(cls);\n                        }\n                    self._initialClassSets.set(el, baseSet);\n                }\n            }\n            const elAny = element;\n            let propName = null;\n            if (attributeName in elAny)\n                propName = attributeName;\n            else {\n                const camel = attributeName.replace(/-([a-z])/g, (_, c) => c.toUpperCase());\n                if (camel in elAny)\n                    propName = camel;\n                else if (attributeName.toLowerCase() === 'readonly' && 'readOnly' in elAny)\n                    propName = 'readOnly';\n            }\n            const isBooleanProp = !!(propName && typeof elAny[propName] === 'boolean');\n            const hasNonFunctionProp = !!(propName && (propName in elAny) && typeof elAny[propName] !== 'function');\n            const isKnownBooleanAttr = !!ReactiveComponent._BA[attributeName.toLowerCase()];\n            const update = () => {\n                const value = evaluator();\n                if (attributeName === 'class') {\n                    const el = element;\n                    const base = self._initialClassSets.get(el);\n                    if (typeof value === 'string') {\n                        el.className = base && base.size ? [...base].join(' ') + (value ? ' ' + value : '') : value || '';\n                    }\n                    else if (ARRAY_ISARRAY(value)) {\n                        if (base && base.size)\n                            el.className = [...base, ...value.filter(Boolean)].join(' ');\n                        else\n                            el.className = value.filter(Boolean).join(' ');\n                    }\n                    else if (value && typeof value === 'object') {\n                        if (base && base.size)\n                            el.className = [...base].join(' ');\n                        for (const raw in value) {\n                            const on = !!value[raw];\n                            if (!raw)\n                                continue;\n                            const tokens = raw.split(/\\s+/);\n                            for (let i = 0; i < tokens.length; i++) {\n                                const tk = tokens[i];\n                                if (!tk)\n                                    continue;\n                                el.classList.toggle(tk, on);\n                            }\n                        }\n                    }\n                    else if (value == null && base && base.size) {\n                        el.className = [...base].join(' ');\n                    }\n                    else if (value == null) {\n                        el.removeAttribute('class');\n                    }\n                    return;\n                }\n                if (attributeName === STR_STYLE) {\n                    const el = element;\n                    if (typeof value === 'string') {\n                        el.style.cssText = value;\n                        return;\n                    }\n                    if (value && typeof value === 'object') {\n                        Object.assign(el.style, value);\n                        return;\n                    }\n                    if (value == null)\n                        el.removeAttribute('style');\n                    return;\n                }\n                if ((isBooleanProp && propName) || isKnownBooleanAttr) {\n                    const boolVal = !!value;\n                    if (propName && isBooleanProp)\n                        elAny[propName] = boolVal;\n                    if (boolVal)\n                        element.setAttribute(attributeName, '');\n                    else\n                        element.removeAttribute(attributeName);\n                    return;\n                }\n                let normalized = null;\n                if (value && typeof value === 'object') {\n                    const parts = [];\n                    for (const k in value) {\n                        if (value[k])\n                            parts.push(k);\n                    }\n                    normalized = parts.length ? parts.join(' ') : null;\n                }\n                else if (value !== null && value !== undefined) {\n                    normalized = String(value);\n                }\n                if (hasNonFunctionProp && propName) {\n                    if (normalized !== null) {\n                        try {\n                            elAny[propName] = normalized;\n                        }\n                        catch (e) {\n                            try {\n                                element.setAttribute(attributeName, normalized);\n                            }\n                            catch { }\n                        }\n                    }\n                    else {\n                        element.removeAttribute(attributeName);\n                    }\n                    return;\n                }\n                if (normalized !== null) {\n                    const cur = element.getAttribute(attributeName);\n                    if (cur !== normalized)\n                        element.setAttribute(attributeName, normalized);\n                }\n                else {\n                    if (element.hasAttribute(attributeName))\n                        element.removeAttribute(attributeName);\n                }\n            };\n            const effect = self._createEffect(update);\n            self._addDirective(element, { type: 'bind', expression, update: effect });\n        }\n        _collectLoopScope(el) {\n            if (!el)\n                return null;\n            if (!el.parentElement) {\n                const cur = el.__x_if_current;\n                if (cur && cur.parentElement) {\n                    el = cur;\n                }\n                else {\n                    const anchorParent = el.__x_if_anchorParent;\n                    if (anchorParent)\n                        el = anchorParent;\n                }\n            }\n            const merged = {};\n            let node = el;\n            while (node) {\n                const scope = this._loopScopes.get(node);\n                if (scope)\n                    Object.assign(merged, scope);\n                if (node === this.element)\n                    break;\n                node = node.parentElement;\n            }\n            return _Okeys(merged).length ? merged : null;\n        }\n        _updateElementDirectives(root) {\n            for (const [element, directives] of this._directives) {\n                for (const directive of directives) {\n                    if ((root === element || (element instanceof Element && root.contains(element))) && directive.update) {\n                        if (XTOOL_ENABLE_STATIC_DIRECTIVES && directive._static)\n                            continue;\n                        directive.update();\n                    }\n                }\n            }\n        }\n        _bindForDirective(element, expression) {\n            const self = this;\n            const match = expression.trim().match(/^(?:\\(\\s*([^,\\s]+)\\s*(?:,\\s*([^\\)]+))?\\s*\\)|([^,\\s]+))\\s+(in|of)\\s+(.+)$/);\n            if (!match) {\n                return;\n            }\n            const itemVar = match[1] || match[3];\n            const indexVar = match[2];\n            const listCode = match[5];\n            const placeholder = d.createComment('x-for');\n            element.parentNode?.insertBefore(placeholder, element);\n            let templateToClone;\n            if (element[STR_TAGNAME] === STR_TEMPLATE) {\n                templateToClone = d.createElement('div');\n                templateToClone.style[STR_DISPLAY] = STR_CONTENTS;\n                templateToClone.appendChild(element.content.cloneNode(true));\n                element.parentNode?.removeChild(element);\n            }\n            else {\n                templateToClone = element;\n                element.parentNode?.removeChild(element);\n            }\n            const contextAnchor = placeholder.parentElement || self.element;\n            const listEval = self._createElementEvaluator(listCode.trim(), contextAnchor);\n            const instances = [];\n            const createScope = (item, idxOrKey) => {\n                const scope = { [itemVar]: item };\n                if (indexVar)\n                    scope[indexVar] = idxOrKey;\n                return scope;\n            };\n            const objIds = new WeakMap();\n            let objSeq = 0;\n            const extractId = (o) => {\n                if (!o || typeof o !== 'object')\n                    return null;\n                const v = o.id ?? o._id ?? o.key;\n                if (v == null)\n                    return null;\n                const t = typeof v;\n                return (t === 'string' || t === 'number') ? ('id:' + String(v)) : null;\n            };\n            const keyFor = (item, _i, primSeen) => {\n                if (item && typeof item === 'object') {\n                    const explicit = extractId(item);\n                    if (explicit)\n                        return explicit;\n                    let id = objIds.get(item);\n                    if (!id) {\n                        id = 'o#' + (++objSeq);\n                        objIds.set(item, id);\n                    }\n                    return id;\n                }\n                const base = 'p#' + (typeof item) + ':' + String(item);\n                const n = (primSeen.get(base) || 0) + 1;\n                primSeen.set(base, n);\n                return base + '#' + n;\n            };\n            const update = () => {\n                const norm = self._safeExecute(() => {\n                    const result = listEval();\n                    if (_AisArr(result))\n                        return { list: result, keys: null };\n                    if (typeof Map !== 'undefined' && result instanceof Map) {\n                        return { list: _Afrom(result.values()), keys: _Afrom(result.keys()) };\n                    }\n                    if (typeof Set !== 'undefined' && result instanceof Set) {\n                        return { list: _Afrom(result.values()), keys: null };\n                    }\n                    if (result && typeof result[Symbol.iterator] === 'function') {\n                        return { list: _Afrom(result), keys: null };\n                    }\n                    if (result && typeof result === 'object') {\n                        const keys = Object.keys(result);\n                        const list = keys.map(k => result[k]);\n                        return { list, keys };\n                    }\n                    return { list: [], keys: null };\n                }, { list: [], keys: null });\n                const list = norm.list;\n                const keysArr = norm.keys;\n                const primSeen = new Map();\n                const newKeys = new Array(list.length);\n                for (let i = 0; i < list.length; i++) {\n                    newKeys[i] = keysArr ? String(keysArr[i]) : keyFor(list[i], i, primSeen);\n                }\n                const oldByKey = new Map();\n                for (let i = 0; i < instances.length; i++) {\n                    const n = instances[i];\n                    const k = n.__x_for_key;\n                    if (k)\n                        oldByKey.set(k, n);\n                }\n                const newNodes = new Array(list.length);\n                for (let i = 0; i < list.length; i++) {\n                    const k = newKeys[i];\n                    const prev = oldByKey.get(k);\n                    if (prev) {\n                        newNodes[i] = prev;\n                        const idxOrKey = keysArr ? keysArr[i] : i;\n                        self._loopScopes.set(prev, createScope(list[i], idxOrKey));\n                        const prevRef = prev.__x_itemRef;\n                        const curRef = list[i];\n                        if (prevRef !== curRef) {\n                            self._updateElementDirectives(prev);\n                            prev.__x_itemRef = curRef;\n                        }\n                        oldByKey.delete(k);\n                    }\n                    else {\n                        const clone = templateToClone.cloneNode(true);\n                        clone.removeAttribute('x-for');\n                        const idxOrKey = keysArr ? keysArr[i] : i;\n                        self._loopScopes.set(clone, createScope(list[i], idxOrKey));\n                        try {\n                            self._parseDirectives(clone);\n                        }\n                        catch { }\n                        clone.__x_itemRef = list[i];\n                        newNodes[i] = clone;\n                    }\n                    newNodes[i].__x_for_key = k;\n                }\n                for (const [, node] of oldByKey) {\n                    if (node && node.parentNode)\n                        node.parentNode.removeChild(node);\n                }\n                const parent = placeholder.parentNode;\n                if (parent) {\n                    const oldKeys = instances.map(n => n.__x_for_key);\n                    let different = oldKeys.length !== newNodes.length;\n                    if (!different) {\n                        for (let i = 0; i < newNodes.length; i++) {\n                            if (oldKeys[i] !== newNodes[i].__x_for_key) {\n                                different = true;\n                                break;\n                            }\n                        }\n                    }\n                    if (different) {\n                        for (let i = 0; i < instances.length; i++) {\n                            const n = instances[i];\n                            if (n.parentNode === parent)\n                                parent.removeChild(n);\n                        }\n                        let before = placeholder;\n                        for (let i = 0; i < newNodes.length; i++) {\n                            const node = newNodes[i];\n                            parent.insertBefore(node, before.nextSibling);\n                            before = node;\n                        }\n                    }\n                    else {\n                        let before = placeholder;\n                        for (let i = 0; i < newNodes.length; i++) {\n                            const node = newNodes[i];\n                            if (before.nextSibling !== node)\n                                parent.insertBefore(node, before.nextSibling);\n                            before = node;\n                        }\n                    }\n                }\n                instances.length = 0;\n                for (let i = 0; i < newNodes.length; i++)\n                    instances.push(newNodes[i]);\n            };\n            const dir = { type: 'for', expression };\n            const effect = self._createEffect(update, dir);\n            dir.update = effect;\n            self._addDirective(placeholder, dir);\n        }\n        _render() {\n            const self = this;\n            for (const directives of self._directives.values()) {\n                for (const dr of directives) {\n                    if (XTOOL_ENABLE_STATIC_DIRECTIVES && dr._static)\n                        continue;\n                    if (dr.update) {\n                        try {\n                            dr.update();\n                        }\n                        catch (error) {\n                            if (!(error instanceof ReferenceError)) { }\n                        }\n                    }\n                }\n            }\n        }\n    }\n    ReactiveComponent._BA = {\n        itemscope: 1, formnovalidate: 1, novalidate: 1, default: 1, readonly: 1\n    };\n    const xTool = new XToolFramework();\n    return xTool;\n}();\nif (typeof window !== 'undefined') {\n    const w = window;\n    w.XTool = XToolFramework;\n    w.FyneJS = XToolFramework;\n}\n//# sourceMappingURL=x-tool.js.map"],"mappings":"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","ignoreList":[]}
{"version":3,"names":["ARRAY_ISARRAY","Array","isArray","WkMap","WeakMap","quMct","queueMicrotask","XToolFramework","_se","fn","_tr","s","trim","_Afrom","from","_AisArr","_Okeys","Object","keys","STR_STYLE","STR_DISPLAY","STR_NONE","STR_TAGNAME","STR_TEMPLATE","STR_LENGTH","STR_SOURCE","STR_READONLY","XTOOL_ENABLE_STATIC_DIRECTIVES","d","document","STR_CONTENTS","EV_DELEGATED","head","getElementById","style","createElement","id","textContent","appendChild","PFX","attrCache","Map","attrName","name","cached","get","value","set","TokenType","keywords","Set","visibility","WS_RE","NUM_RE","ReactiveComponent","attachToParent","parent","this","_parent","_addChild","_id","framework","_framework","element","_element","el","isBound","_isBound","v","isMounted","_isMounted","isDestroyed","_isDestroyed","_abortInvokerResources","byKind","_invokerResources","values","cleanup","clear","_cancelUserResources","_resolveBindingMeta","attributeName","elAny","propName","camel","replace","_","c","toUpperCase","toLowerCase","isBooleanProp","hasNonFunctionProp","isKnownBooleanAttr","_BA","_applyGenericBinding","meta","boolVal","setAttribute","removeAttribute","normalized","parts","k","push","length","join","String","getAttribute","_scanDirectiveAttrs","opts","prefixDash","prefixColon","namesOut","hasTextOrHtml","forName","names","getAttributeNames","i","startsWith","skipRootFor","setFrozen","on","_isFrozen","_sealedBeforeFreeze","_isSealed","_scheduleRender","_setSealed","_addDirective","directive","existing","_directives","constructor","def","_propUpdateActive","_runningPropEffect","_beforeMountCalled","_children","_computed","_propEffects","_computedCache","_computedDeps","_computedKeyStack","_isInComputedEvaluation","_isInMethodExecution","_allEffects","_hasComputed","_cleanupFunctions","_directiveAbort","AbortController","_targetIds","_targetSeq","_isMutationEnabled","_effectsToRun","_currentInvoker","_loopScopes","_expressionCache","_propertyDependencies","_activeEffect","_renderScheduled","_nextTickQueue","_changeFrameId","_renderFrameId","_initialClassSets","_rawData","_propParent","_callLifecycleHook","hookName","hook","_lifecycle","_safeExecute","_runWithGlobalInterception","_addCleanupFunction","wrapped","delete","add","_originalMethods","methods","_bindComputed","computed","propEffects","_bindPropEffects","mounted","unmounted","destroyed","updated","beforeMount","beforeUnmount","beforeDestroy","_cloneData","data","_data","_createReactiveData","_methods","_bindMethods","seen","has","arr","Date","getTime","RegExp","source","flags","m","forEach","st","proto","getPrototypeOf","prototype","out","create","key","callBeforeMount","_onDataChange","_property","self","cancelAnimationFrame","effectsToRun","directDeps","size","queue","visited","affectedComputed","queueIdx","base","compKey","baseDeps","entries","compEffects","requestAnimationFrame","effect","_bindFunctionMap","src","kind","makeNoArgCtxRunner","test","isNative","body","compiled","Function","ctx","_createMethodContext","call","original","args","prev","prevInv","newValue","oldValue","prevFlag","_getComputedValue","_trackDependency","getter","undefined","pop","e","propKey","activeEff","deps","includes","stackLen","current","_render","q","splice","fallback","error","bindToElement","completeBinding","getContext","includeComputed","_applyAsyncTemplateResolved","_parseDirectives","_getComponentByElement","_registerElement","child","_removeChild","index","indexOf","wrapper","thisArg","_createContextProxy","apply","destroy","directives","type","customDirective","unbind","abort","_runCleanupCallbacks","_propEffect","idx","_unregisterElement","_deepReactiveCache","_unregisterComponent","_initReactiveProps","expr","evalFn","update","obj","$props","_listen","event","handler","options","signal","addEventListener","capture","merged","_targetKey","target","toString","processElement","isRoot","hasAttribute","isComponentTag","directiveNames","_bindDirective","attr","_bindTextInterpolationsIn","_walkElements","nodes","childNodes","node","nodeType","Node","TEXT_NODE","textNode","raw","nodeValue","__x_ti_bound","segs","charCodeAt","run","start","close","text","slice","repeat","code","nextEsc","nextOpen","end","some","literalOut","map","evaluators","_createElementEvaluator","ei","dirInfo","expression","_createEffect","processor","firstElementChild","next","nextElementSibling","directiveName","isAtEvent","isShortBind","_bindAttributeDirective","_bindSimpleDirective","_bindIfDirective","_bindForDirective","_bindModelDirective","prefix","rest","split","suffix","mods","modifiers","reduce","acc","_getCustomDirective","_bindCustomDirective","_bindEventDirective","_bindIntersectDirective","phase","trimmed","runExpr","_compileHandler","payload","once","rootMargin","unobserve","_ioObserve","cb","entry","info","updateFn","directiveRef","_static","found","evaluator","originalDisplay","_prevShown","innerHTML","property","isCheckbox","isNumeric","isMultiSelect","tagName","multiple","getValueEvaluator","setValueEvaluator","_createEvaluator","checkboxValue","loopScope","_collectLoopScope","inferCheckboxValue","member","checked","sel","selected","setInputValue","t","currentData","parseFloat","getInputValue","currentVal","$value","placeholder","createComment","parentNode","insertBefore","__x_if_anchorParent","parentElement","branches","makeActualElement","content","cloneNode","isTemplate","first","firstEval","__x_tool_bound","originalNodes","sib","isElse","isElseIf","branch","active","orig","removeChild","mountBranch","b","__x_if_current","nextSibling","unmountBranch","eventName","passive","onlySelf","shouldPrevent","prevent","shouldStop","stop","isOutside","outside","deferExec","defer","keyAliasMap","enter","esc","escape","space","tab","backspace","del","arrowup","arrowdown","arrowleft","arrowright","home","pageup","pagedown","comboRequirements","ctrl","alt","shift","buttonMap","left","middle","right","touchSingle","single","touchMulti","multi","modifierKeys","allowedKeys","aliases","allowedButtons","btn","needKeyCheck","needButtonCheck","needTouchCheck","passesFilters","path","composedPath","tgt","contains","TouchEvent","tCount","touches","MouseEvent","button","KeyboardEvent","ctrlKey","altKey","shiftKey","metaKey","ev","createEventHandler","preventDefault","stopPropagation","canDelegate","_getConfig","delegate","remover","_registerDelegated","filter","comp","ownerDocument","isStatement","_extractArrowFunction","match","params","p","Boolean","isBlock","endsWith","paramsList","_compileArrowForEvent","mapArgs","arrow","thisCtx","compiledArrow","executor","result","_assertMutable","parentKey","method","Error","_wrapData","isArr","isSet","isMap","makeCollectionWrapper","beforeLen","beforeFirst","beforeLast","before","existed","proxy","Proxy","receiver","isCollection","Symbol","iterator","Reflect","bind","ownKeys","had","defineProperty","configurable","enumerable","writable","deleteProperty","ok","pc","eff","_includeComputed","specials","$log","$destroy","$forceUpdate","$addCleanupFunction","$nextTick","Promise","resolve","$el","$id","$isMounted","$isDestroyed","$isSealed","$isFrozen","$parent","$children","$seal","$mutate","prevMethod","propStr","_target","targetElement","component","mergedScope","gWindow","window","gDocument","cfg","sandbox","sandboxExpressions","allow","allowGlobals","ensureInvoker","registerResource","setup","inv","wrapTarget","prop","optSig","removeEventListener","querySelector","querySelectorAll","doc","win","defaultView","wrapObserverCtor","Orig","observerArgs","observe","disconnect","inst","$target","$event","_routerEnabled","location","_t","_navigate","href","setTimeout","ms","clearTimeout","setInterval","clearInterval","MutationObserver","ResizeObserver","IntersectionObserver","hasOwnProperty","_name","directiveInfo","isSvg","namespaceURI","baseSet","oc","className","cls","finalCls","tokens","finalStr","baseStr","tk","classList","toggle","cssText","cssProp","setProperty","removeProperty","cur","anchorParent","__x_scope","scope","assign","_updateElementDirectives","root","force","Element","_updateElementDirectivesForVar","varName","re","_cleanupElementSubtree","toDelete","itemVar","indexVar","listCode","keyAttrName","keyExpr","templateToClone","contextAnchor","listEval","keyEval","BP_FOR","BP_KEY","BP_TEXT","BP_HTML","BP_DATA","hydrateFromBlueprint","cloneRoot","bp","instr","_resolveNodeByPath","j","dn","blueprint","walk","isRootEl","scan","dnames","n","concat","buildBlueprint","instances","createScope","item","idxOrKey","objIds","objSeq","keyFor","explicit","o","extractId","evalKeyExpr","dir","norm","list","tag","keysArr","oldByObjKey","oldPrimQueues","__x_for_key","ps","__x_primSig","newNodes","nodeKey","explicitKey","prevIdxRef","__x_idxRef","prevItemRef","__x_itemRef","needsUpdate","indexChanged","clone","initScope","oldIndexMap","seq","oldIdx","lisMask","lis","_computeLISMask","tailAnchor","anchor","ref","predecessors","tails","tailIdx","lo","hi","mid","lisLen","fill","dr","itemscope","formnovalidate","novalidate","default","readonly","_components","_byEl","_pending","_config","_customDirectives","_currentArrayInterceptorComp","_namedComponentDefs","_delegated","_delegatedRootBound","_prefetched","_currentDocURL","_scrollPositions","registerComponent","definition","_getRegisteredComponentDef","_preDiscoveryTasks","init","config","container","debug","staticDirectives","router","enabled","transitionName","_hpf","async","_applyPrefixInitialCSS","allSettled","_autoDiscoverComponents","_ensureRootObserver","_ensureDelegation","_installRouting","_normalizeDocURL","readyState","_inflightComponentLoads","_lazyComponentSources","loadComponents","sources","items","mode","tasks","it","_fetchAndEvalComponent","catch","then","inferredName","status","results","settled","failed","r","createComponent","_generateComponentId","dataAttr","_bindElementAsComponent","componentElements","reusable","_instantiateNamedComponent","_processPending","components","lastComponent","maybe","parentForEval","dataExpression","parentCtx","_parseDataExpression","desc","getOwnPropertyDescriptors","plainData","dsc","initExpr","_finalizeComponentMount","xInitExpr","now","random","Math","substring","componentId","_log","_routerTransitionName","_isSameOrigin","u","URL","baseURI","origin","_isSameDocument","pathname","search","_scrollToHash","hash","decodeURIComponent","CSS","scrollIntoView","block","behavior","defaultPrevented","a","url","prefetchOnHover","preloadEventHandler","link","preload","targetURL","targetKey","err","curKey","x","scrollX","y","scrollY","html","_fetchHTML","history","pushState","_swapDocument","pos","scrollTo","after","message","res","fetch","credentials","cache","redirect","redirected","finalUrl","statusText","DOMParser","parseFromString","newHead","newTitle","applySwap","title","_morphElement","vt","startViewTransition","cont","getPropertyValue","transition","finished","_setAttributes","curAttrs","nextAttrs","val","_attributesEqual","aNames","bNames","_isDynamicNode","nodeName","replaceWith","firstChild","curChildren","nextChildren","max","cn","nn","toRemove","retries","baseDelay","isTypeScript","strings","str","attempt","isIdentifierStart","ch","ID_START_RE","isIdentifierPart","ID_PART_RE","isGenericStartEnd","startIndex","token","skipType","standalone","skipUntil","Whitespace","Punctuation","hasItem","isSimple","Keyword","Identifier","isComplex","depth","hasNewline","isContinued","Arrow","isObjectLiteralStart","prevToken","isWhitespace","isNumber","pred","context","collection","input","createToken","Comment","Number","quoteType","tplExprDepth","nestedDepth","tokenize","isObjectLiteral","isClassBody","braceDepth","lastIdentifier","lastKeyword","objectBraceDepth","outputString","tt","paramToken","pt","pv","gt","stripTypes","delay","pow","finally","_rootObserver","records","addedNodes","removedNodes","isConnected","stack","_onComponentSourceChanged","ro","childList","subtree","attributes","attributeFilter","_ensureIO","_ioObservers","_ioRegistry","io","reg","isIntersecting","visible","leave","onEnter","onLeave","existingMounted","parentComp","lazy","promise","par","props","dynamicPropObj","rawPropExpression","propExpr","initDef","baseData","makeData","compDef","originalChildren","replaceChildren","template","applyTemplate","tpl","slots","slotEl","matched","tplVal","append","nested","cancelBubble","h","captureEvents","bubbleEvents","l","w","XTool","FyneJS"],"sourceRoot":"./dist","sources":["dist/x-tool.js"],"sourcesContent":["\"use strict\";\nconst ARRAY_ISARRAY = Array.isArray;\nconst WkMap = WeakMap;\nconst quMct = queueMicrotask;\nconst FT_C = true;\nconst FT_TI = typeof __FEAT_TEXT_INTERP__ === 'boolean' ? __FEAT_TEXT_INTERP__ : true;\nconst _FT_DR = typeof __FEAT_DEEP_REACTIVE__ === 'boolean' ? __FEAT_DEEP_REACTIVE__ : true;\nconst FT_IFB = typeof __FEAT_IF_BRANCHES__ === 'boolean' ? __FEAT_IF_BRANCHES__ : true;\nconst XToolFramework = function () {\n    const _se = (fn) => { try {\n        fn();\n    }\n    catch { } };\n    const _tr = (s) => (s || '').trim();\n    const _Afrom = Array.from;\n    const _AisArr = ARRAY_ISARRAY;\n    const _Okeys = Object.keys;\n    const STR_STYLE = 'style';\n    const STR_DISPLAY = 'display';\n    const STR_NONE = 'none';\n    const STR_TAGNAME = 'tagName';\n    const STR_TEMPLATE = 'TEMPLATE';\n    const STR_LENGTH = 'length';\n    const STR_SOURCE = 'source';\n    const STR_READONLY = 'readonly';\n    let XTOOL_ENABLE_STATIC_DIRECTIVES = true;\n    const d = (typeof document !== 'undefined' ? document : null);\n    const STR_CONTENTS = 'contents';\n    const EV_CLICK = 'click', EV_INPUT = 'input', EV_CHANGE = 'change', EV_KEYDOWN = 'keydown', EV_KEYUP = 'keyup';\n    const EV_DELEGATED = [EV_CLICK, EV_INPUT, EV_CHANGE, EV_KEYDOWN, EV_KEYUP];\n    const LS_PENDING = 0, LS_LOADING = 1, LS_LOADED = 2, LS_ERROR = 3;\n    try {\n        if (d && d.head && !d.getElementById('x-tool-initial-css')) {\n            const style = d.createElement(STR_STYLE);\n            style.id = 'x-tool-initial-css';\n            style.textContent = '[x-show],[x-if],[x-else],[x-else-if],[x\\\\:show],[x\\\\:if],[x\\\\:else],[x\\\\:else-if]{display:none;}';\n            d.head.appendChild(style);\n        }\n    }\n    catch { }\n    let PFX = 'x';\n    let attrCache = new Map();\n    const attrName = (name) => {\n        const cached = attrCache.get(name);\n        if (cached)\n            return cached;\n        const value = `${PFX}-${name}`;\n        attrCache.set(name, value);\n        return value;\n    };\n    let TokenType;\n    (function (TokenType) {\n        TokenType[TokenType[\"Identifier\"] = 0] = \"Identifier\";\n        TokenType[TokenType[\"Keyword\"] = 1] = \"Keyword\";\n        TokenType[TokenType[\"Punctuation\"] = 2] = \"Punctuation\";\n        TokenType[TokenType[\"String\"] = 3] = \"String\";\n        TokenType[TokenType[\"Comment\"] = 4] = \"Comment\";\n        TokenType[TokenType[\"Whitespace\"] = 5] = \"Whitespace\";\n        TokenType[TokenType[\"Number\"] = 6] = \"Number\";\n        TokenType[TokenType[\"Arrow\"] = 7] = \"Arrow\";\n    })(TokenType || (TokenType = {}));\n    const keywords = new Set([\n        'as', 'interface', 'type', 'import', 'export', 'from', 'extends', 'implements',\n        'declare', 'namespace', 'module', 'any', 'unknown', 'never', 'void',\n        'number', 'string', 'boolean', 'symbol', 'bigint', 'object', 'enum', 'function'\n    ]);\n    const visibility = ['public', 'private', 'protected', 'static', 'abstract', 'readonly'];\n    const WS_RE = /\\s/;\n    const NUM_RE = /\\d/;\n    function stripTypes(source) {\n        const ID_START_RE = /[a-zA-Z_$]/;\n        const ID_PART_RE = /[a-zA-Z0-9_$]/;\n        function isIdentifierStart(ch) { return ID_START_RE.test(ch); }\n        function isIdentifierPart(ch) { return ID_PART_RE.test(ch); }\n        const isWhitespace = (ch) => WS_RE.test(ch);\n        const isNumber = (ch) => NUM_RE.test(ch);\n        function isGenericStartEnd(startIndex, tokens) {\n            const token = tokens[startIndex];\n            const ch = token.value == '<' ? '<' : '>';\n            return token.value == ch && (token.next?.value !== ch && token.prev?.value !== ch);\n        }\n        const skipUntil = (tokens, index, pred) => {\n            const context = { index, depth: 0 };\n            while (index < tokens.length && !pred(tokens[index], context))\n                index++;\n            return index;\n        };\n        const hasItem = (item, collection) => {\n            return collection.indexOf(item) !== -1;\n        };\n        function skipType(tokens, startIndex, standalone = true) {\n            let i = startIndex;\n            const ctx = {};\n            i = skipUntil(tokens, i, t => t.type !== TokenType.Whitespace && !(t.type === TokenType.Punctuation && hasItem(t.value, '|?&:')));\n            let isSimple = hasItem(tokens[i].type, [TokenType.Keyword, TokenType.Identifier]);\n            if (isSimple && tokens[i] && tokens[i].next?.type === TokenType.Punctuation && hasItem(tokens[i].next?.value, '<[{(')) {\n                i = skipUntil(tokens, i, t => t.type === TokenType.Punctuation);\n            }\n            let isComplex = tokens[i].type === TokenType.Punctuation && hasItem(tokens[i].value, '<[{(');\n            while (i < tokens.length) {\n                if (isComplex) {\n                    i = skipUntil(tokens, i, (t, ctx) => {\n                        if (t.type === TokenType.Punctuation) {\n                            if (hasItem(t.value, ']})>'))\n                                ctx.depth--;\n                            else if (hasItem(t.value, '<[{('))\n                                ctx.depth++;\n                        }\n                        return ctx.depth <= 0;\n                    });\n                    i++;\n                }\n                else {\n                    i = skipUntil(tokens, i, t => (TokenType.Whitespace === t.type && t.value !== \" \") || (t.type === TokenType.Punctuation && t.value !== '.'));\n                    if (standalone && tokens[i] && tokens[i].type === TokenType.Punctuation && hasItem(tokens[i].value, '<[{(')) {\n                        let hasNewline = false;\n                        skipUntil(tokens, i, t => { if (t.type === TokenType.Whitespace && hasItem(\"\\n\", t.value))\n                            hasNewline = true; return hasNewline || t.start >= tokens[i].start; });\n                        if (!hasNewline) {\n                            i = skipUntil(tokens, i, (t, ctx) => {\n                                if (t.type === TokenType.Punctuation) {\n                                    if (hasItem(t.value, ']})>'))\n                                        ctx.depth--;\n                                    else if (hasItem(t.value, '<[{('))\n                                        ctx.depth++;\n                                }\n                                return ctx.depth <= 0;\n                            });\n                            i++;\n                        }\n                    }\n                }\n                if (i >= tokens.length) {\n                    break;\n                }\n                if (tokens[i].type === TokenType.Whitespace && hasItem(\"\\n\", tokens[i].value) && tokens[i].prev?.next && tokens[i].prev?.next?.type === TokenType.Punctuation && hasItem(tokens[i].prev?.next?.value, '?&|:')) {\n                    i = skipUntil(tokens, i, t => t.type == TokenType.Punctuation);\n                }\n                if (tokens[i].type === TokenType.Whitespace)\n                    i = skipUntil(tokens, i, t => !t.value.startsWith(' '));\n                let cur = tokens[i];\n                const isContinued = cur.type === TokenType.Punctuation && hasItem(cur.value, \"?&|:\") || (cur.type === TokenType.Arrow && cur.prev?.value === ')');\n                if (!isContinued && (isSimple && cur.type === TokenType.Punctuation && (hasItem(cur.value, '(<[') || standalone && cur.value == '{'))) {\n                    isComplex = true;\n                    i = skipUntil(tokens, i, t => t.type !== TokenType.Whitespace);\n                    continue;\n                }\n                if (isContinued) {\n                    i++;\n                    i = skipUntil(tokens, i, t => !t.value.startsWith(' '));\n                }\n                ctx.isContinued = isContinued;\n                ctx.token = tokens[i];\n                if (!isContinued) {\n                    if (standalone) {\n                        i++;\n                    }\n                    break;\n                }\n                else {\n                    isSimple = hasItem(tokens[i].type, [TokenType.Keyword, TokenType.Identifier]);\n                    isComplex = tokens[i].type === TokenType.Punctuation && hasItem(tokens[i].value, '<[{(');\n                }\n            }\n            return i;\n        }\n        function tokenize(input) {\n            const tokens = [];\n            let pos = 0;\n            const length = input.length;\n            let prevToken;\n            const createToken = (type, start, end) => {\n                const token = {\n                    type,\n                    value: input.slice(start, end),\n                    start,\n                    end\n                };\n                if (prevToken) {\n                    token.prev = prevToken;\n                    prevToken.next = token;\n                }\n                if (type !== TokenType.Whitespace && type !== TokenType.Comment) {\n                    prevToken = token;\n                }\n                return token;\n            };\n            while (pos < length) {\n                const ch = input[pos];\n                let start = pos;\n                if (isWhitespace(ch)) {\n                    do {\n                        pos++;\n                    } while (pos < length && isWhitespace(input[pos]));\n                    tokens.push(createToken(TokenType.Whitespace, start, pos));\n                    continue;\n                }\n                if (isIdentifierStart(ch)) {\n                    pos++;\n                    while (pos < length && isIdentifierPart(input[pos]))\n                        pos++;\n                    const value = input.slice(start, pos);\n                    tokens.push(createToken(keywords.has(value) || hasItem(value, visibility) ? TokenType.Keyword : TokenType.Identifier, start, pos));\n                    continue;\n                }\n                if (isNumber(ch)) {\n                    do {\n                        pos++;\n                    } while (pos < length && isNumber(input[pos]));\n                    tokens.push(createToken(TokenType.Number, start, pos));\n                    continue;\n                }\n                if (ch === '\"' || ch === \"'\" || ch === '`') {\n                    const quoteType = ch;\n                    pos++;\n                    if (quoteType !== '`') {\n                        while (pos < length) {\n                            if (input[pos] === '\\\\')\n                                pos += 2;\n                            else if (input[pos] === quoteType) {\n                                pos++;\n                                break;\n                            }\n                            else\n                                pos++;\n                        }\n                        tokens.push(createToken(TokenType.String, start, pos));\n                        continue;\n                    }\n                    let tplExprDepth = 0;\n                    while (pos < length) {\n                        const c = input[pos];\n                        if (c === '\\\\') {\n                            pos += 2;\n                            continue;\n                        }\n                        if (c === '`' && tplExprDepth === 0) {\n                            pos++;\n                            break;\n                        }\n                        if (c === '$' && pos + 1 < length && input[pos + 1] === '{') {\n                            tplExprDepth++;\n                            pos += 2;\n                            while (pos < length && tplExprDepth > 0) {\n                                const e = input[pos];\n                                if (e === '\\\\') {\n                                    pos += 2;\n                                    continue;\n                                }\n                                if (e === '\"' || e === \"'\") {\n                                    const q = e;\n                                    pos++;\n                                    while (pos < length) {\n                                        if (input[pos] === '\\\\')\n                                            pos += 2;\n                                        else if (input[pos] === q) {\n                                            pos++;\n                                            break;\n                                        }\n                                        else\n                                            pos++;\n                                    }\n                                    continue;\n                                }\n                                if (e === '`') {\n                                    pos++;\n                                    let nestedDepth = 0;\n                                    while (pos < length) {\n                                        const n = input[pos];\n                                        if (n === '\\\\') {\n                                            pos += 2;\n                                            continue;\n                                        }\n                                        if (n === '`' && nestedDepth === 0) {\n                                            pos++;\n                                            break;\n                                        }\n                                        if (n === '$' && pos + 1 < length && input[pos + 1] === '{') {\n                                            nestedDepth++;\n                                            pos += 2;\n                                            continue;\n                                        }\n                                        if (n === '}' && nestedDepth > 0) {\n                                            nestedDepth--;\n                                            pos++;\n                                            continue;\n                                        }\n                                        pos++;\n                                    }\n                                    continue;\n                                }\n                                if (e === '{') {\n                                    tplExprDepth++;\n                                    pos++;\n                                    continue;\n                                }\n                                if (e === '}') {\n                                    tplExprDepth--;\n                                    pos++;\n                                    continue;\n                                }\n                                pos++;\n                            }\n                            continue;\n                        }\n                        pos++;\n                    }\n                    tokens.push(createToken(TokenType.String, start, pos));\n                    continue;\n                }\n                if (ch === '/' && pos + 1 < length) {\n                    if (input[pos + 1] === '/') {\n                        pos += 2;\n                        while (pos < length && input[pos] !== '\\n')\n                            pos++;\n                        tokens.push(createToken(TokenType.Comment, start, pos));\n                        continue;\n                    }\n                    if (input[pos + 1] === '*') {\n                        pos += 2;\n                        while (pos < length && !(input[pos] === '*' && input[pos + 1] === '/'))\n                            pos++;\n                        pos += 2;\n                        tokens.push(createToken(TokenType.Comment, start, pos));\n                        continue;\n                    }\n                }\n                if (ch === '=' && pos + 1 < length && input[pos + 1] === '>') {\n                    pos += 2;\n                    tokens.push(createToken(TokenType.Arrow, start, pos));\n                    continue;\n                }\n                tokens.push(createToken(TokenType.Punctuation, pos, ++pos));\n            }\n            return tokens;\n        }\n        function isObjectLiteralStart(tokens, index) {\n            let j = index - 1;\n            while (j >= 0 && tokens[j].type === TokenType.Whitespace)\n                j--;\n            if (j < 0)\n                return false;\n            const prevToken = tokens[j];\n            if (prevToken.type === TokenType.Arrow)\n                return false;\n            return (prevToken.type === TokenType.Identifier && prevToken.value === 'return') || prevToken.type === TokenType.Punctuation && (prevToken.value === '=' || prevToken.value === '(' || prevToken.value === '[' ||\n                prevToken.value === ',' || prevToken.value === ':' || prevToken.value === '?');\n        }\n        const tokens = tokenize(source);\n        let i = 0;\n        const context = {\n            isObjectLiteral: false,\n            isClassBody: false,\n            braceDepth: 0,\n            lastIdentifier: undefined,\n            lastKeyword: undefined\n        };\n        let objectBraceDepth = 0;\n        let outputString = '';\n        while (i < tokens.length) {\n            const token = tokens[i];\n            const tt = token.type;\n            const v = token.value;\n            if (tt === TokenType.Comment) {\n                i++;\n                continue;\n            }\n            if (tt === TokenType.Identifier) {\n                context.lastIdentifier = v;\n            }\n            if ((tt == TokenType.Identifier || tt == TokenType.Keyword) && ((token.next?.type === TokenType.Keyword && token.next.value == 'enum') || (v == 'enum'))) {\n                i = skipUntil(tokens, i, t => t.value == '}');\n                i++;\n                continue;\n            }\n            if (tt == TokenType.String || (tt != TokenType.Punctuation && TokenType.Whitespace != tt && TokenType.Keyword != tt)) {\n                i++;\n                outputString += v;\n                continue;\n            }\n            if (tt === TokenType.Whitespace) {\n                outputString += (v.includes('\\n') ? '\\n' : v);\n                i++;\n                continue;\n            }\n            if (context.lastIdentifier === 'class') {\n                context.isClassBody = true;\n            }\n            if (tt === TokenType.Punctuation && v === '{') {\n                context.braceDepth++;\n                if (isObjectLiteralStart(tokens, i)) {\n                    objectBraceDepth++;\n                    context.isObjectLiteral = true;\n                }\n                outputString += token.value;\n                i++;\n                continue;\n            }\n            if (tt === TokenType.Punctuation && v === '}') {\n                context.braceDepth--;\n                if (context.isObjectLiteral) {\n                    objectBraceDepth--;\n                    if (objectBraceDepth <= 0)\n                        context.isObjectLiteral = false;\n                }\n                if (context.braceDepth <= 0) {\n                    context.isClassBody = false;\n                }\n                outputString += token.value;\n                i++;\n                continue;\n            }\n            if (tt === TokenType.Keyword) {\n                if (!context.isObjectLiteral && v === 'import') {\n                    i = skipUntil(tokens, i, t => (t.type === TokenType.Keyword && t.value === 'from'));\n                    i = skipUntil(tokens, i, t => t.value === ';' || (t.type === TokenType.Whitespace && t.value.includes(\"\\n\")));\n                    if (i < tokens.length && tokens[i].value === ';')\n                        i++;\n                    continue;\n                }\n                if (v === 'as' && !isObjectLiteralStart(tokens, i)) {\n                    i++;\n                    i = skipUntil(tokens, i, t => t.type !== TokenType.Whitespace);\n                    i = skipType(tokens, i, false);\n                    continue;\n                }\n                if (v === 'export' && !context.isObjectLiteral && (String(token.next?.value + token.next?.next?.value).match(/(const\\s+)?(type|interface|enum|namespace|function)/))) {\n                    i++;\n                    i = skipUntil(tokens, i, t => t.type !== TokenType.Whitespace);\n                    continue;\n                }\n                if (v === 'function' && token.next?.type === TokenType.Identifier && token.next?.next?.type === TokenType.Punctuation && token.next?.next?.value === '(' && token.next?.next?.next && token.next?.next?.next?.type === TokenType.Identifier) {\n                    let j = i + 4;\n                    let depth = 1;\n                    while (j < tokens.length && depth > 0) {\n                        const t = tokens[j];\n                        if (t.type === TokenType.Punctuation) {\n                            if (t.value === '(')\n                                depth++;\n                            else if (t.value === ')')\n                                depth--;\n                        }\n                        j++;\n                    }\n                    j = skipUntil(tokens, j, t => t.type !== TokenType.Whitespace);\n                    if (j < tokens.length && tokens[j].type === TokenType.Punctuation && tokens[j].value === ':') {\n                        j++;\n                        j = skipType(tokens, j, false);\n                        j = skipUntil(tokens, j, t => t.type !== TokenType.Whitespace);\n                    }\n                    if (j < tokens.length && tokens[j].type === TokenType.Punctuation && tokens[j].value === ';') {\n                        i = j + 1;\n                        continue;\n                    }\n                }\n            }\n            if (!context.isObjectLiteral && tt === TokenType.Keyword && !isObjectLiteralStart(tokens, i) && hasItem(v, ['interface', 'type', 'declare', 'namespace', 'module'])) {\n                if (v === 'type')\n                    i = skipUntil(tokens, i, (t, ctx) => {\n                        if (t.type === TokenType.Punctuation) {\n                            if (hasItem(t.value, '<[({')) {\n                                ctx.depth++;\n                            }\n                            else if (hasItem(t.value, '>])}')) {\n                                ctx.depth--;\n                            }\n                        }\n                        return ctx.depth <= 0 && t.type === TokenType.Punctuation && t.value == '=';\n                    }), i++;\n                else\n                    i++;\n                i = skipType(tokens, i, true);\n                continue;\n            }\n            if (!context.isObjectLiteral && tt === TokenType.Keyword && v === 'implements' && token.next?.type !== TokenType.Punctuation && !context.isObjectLiteral) {\n                i++;\n                i = skipUntil(tokens, i, t => t.type === TokenType.Punctuation && t.value == '{');\n                continue;\n            }\n            if (tt === TokenType.Punctuation && v === '!' && token.prev?.type !== TokenType.Punctuation && token.prev?.type !== TokenType.Arrow) {\n                i++;\n                continue;\n            }\n            if (tt === TokenType.Punctuation && v === '(') {\n                if (token.next && token.next.value === '{') {\n                    outputString += token.value;\n                    i++;\n                    continue;\n                }\n                outputString += v;\n                i++;\n                let depth = 1;\n                while (i < tokens.length && depth > 0) {\n                    const paramToken = tokens[i];\n                    const pt = paramToken.type;\n                    const pv = paramToken.value;\n                    if (pt == TokenType.Punctuation && pv == '{' && isObjectLiteralStart(tokens, i)) {\n                        skipUntil(tokens, i, (t, ctx) => {\n                            if (t.type === TokenType.Punctuation) {\n                                if (t.value === '{')\n                                    ctx.depth++;\n                                else if (t.value === '}')\n                                    ctx.depth--;\n                            }\n                            outputString += tokens[i].value;\n                            i++;\n                            return ctx.depth <= 0;\n                        });\n                        continue;\n                    }\n                    if (pt == TokenType.Comment) {\n                        i++;\n                        continue;\n                    }\n                    if (pt === TokenType.Punctuation && pv === '(') {\n                        depth++;\n                    }\n                    else if (pt === TokenType.Punctuation && pv === ')') {\n                        depth--;\n                    }\n                    if (pt === TokenType.Keyword && hasItem(pv, visibility)) {\n                        i++;\n                        if (tokens[i].type === TokenType.Whitespace)\n                            i = skipUntil(tokens, i, t => t.type !== TokenType.Whitespace);\n                        continue;\n                    }\n                    if (pt === TokenType.Punctuation && pv === '!' && paramToken.prev && paramToken.prev.type === TokenType.Identifier) {\n                        i++;\n                        continue;\n                    }\n                    if (pt === TokenType.Punctuation && (pv === ':' || (pv == '?' && paramToken.next?.type == TokenType.Punctuation && paramToken.next?.value == ':')) || (TokenType.Keyword === pt && pv == 'as')) {\n                        i++;\n                        i = skipType(tokens, i, false);\n                        continue;\n                    }\n                    if (i < tokens.length && tokens[i].type === TokenType.Punctuation && tokens[i].value === ')') {\n                        outputString += tokens[i].value;\n                        i++;\n                        if (i < tokens.length && tokens[i].type === TokenType.Punctuation && tokens[i].value === ':') {\n                            i++;\n                            i = skipType(tokens, i, false);\n                        }\n                        continue;\n                    }\n                    outputString += paramToken.value;\n                    i++;\n                }\n                continue;\n            }\n            if (tt === TokenType.Punctuation && (v === ':' || (v === '?' && token.next?.type === TokenType.Punctuation && token.next.value == ':'))) {\n                if (token.prev && token.prev.type === TokenType.Identifier && !context.isObjectLiteral) {\n                    i++;\n                    i = skipType(tokens, i, false);\n                    continue;\n                }\n            }\n            if (tt === TokenType.Punctuation && v === '<' && isGenericStartEnd(i, tokens)) {\n                if (i < tokens.length) {\n                    let j = skipType(tokens, i, false);\n                    if (tokens[j] && tokens[j].type === TokenType.Whitespace)\n                        j = skipUntil(tokens, j, t => t.type !== TokenType.Whitespace);\n                    let gt = tokens[j];\n                    if (gt && gt.type == TokenType.Punctuation && '({['.indexOf(gt.value) !== -1) {\n                        i = j;\n                        continue;\n                    }\n                }\n            }\n            if (!context.isObjectLiteral && tt === TokenType.Keyword &&\n                hasItem(v, visibility)) {\n                i++;\n                continue;\n            }\n            if (tt === TokenType.Keyword) {\n                context.lastKeyword = token.value;\n            }\n            outputString += v;\n            i++;\n        }\n        return outputString;\n    }\n    class XToolFramework {\n        constructor() {\n            this._components = new Map();\n            this._byEl = new WkMap();\n            this._pending = [];\n            this._config = {};\n            this._customDirectives = new Map();\n            this._currentArrayInterceptorComp = null;\n            this._namedComponentDefs = new Map();\n            this._delegated = new WkMap();\n            this._delegatedRootBound = false;\n            this._prefetched = new Set();\n            this._currentDocURL = '';\n            this._scrollPositions = new Map();\n            this.directive = (name, directive) => {\n                if (name.startsWith(PFX + '-')) {\n                    throw new Error(`Custom directive names should not start with \"${PFX}-\". Use: XTool.directive(\"my-directive\", ...)`);\n                }\n                this._customDirectives.set(name, directive);\n                return this;\n            };\n            this.registerComponent = (definition) => {\n                if (!definition || !definition.name)\n                    throw new Error('registerComponent requires a name');\n                const name = definition.name.toLowerCase();\n                if (this._namedComponentDefs.has(name))\n                    return this;\n                this._namedComponentDefs.set(name, definition);\n                return this;\n            };\n            this._getRegisteredComponentDef = (name) => this._namedComponentDefs.get(name.toLowerCase());\n            this._getCustomDirective = (name) => this._customDirectives.get(name);\n            this._getConfig = () => this._config;\n            this._preDiscoveryTasks = [];\n            this.init = (config = {}) => {\n                const base = { container: 'body', debug: false, staticDirectives: true, router: { enabled: false, transitionName: 'route' } };\n                this._config = { ...base, ...config, router: { ...base.router, ...(config.router || {}) } };\n                if (typeof this._config.staticDirectives === 'boolean') {\n                    XTOOL_ENABLE_STATIC_DIRECTIVES = this._config.staticDirectives;\n                }\n                const _hpf = this._config.prefix;\n                if (_hpf && typeof _hpf === 'string' && _hpf[STR_LENGTH] > 0) {\n                    PFX = _hpf;\n                }\n                else {\n                    PFX = 'x';\n                }\n                attrCache.clear();\n                const start = async () => {\n                    this._applyPrefixInitialCSS();\n                    if (this._preDiscoveryTasks.length) {\n                        try {\n                            await Promise.allSettled(this._preDiscoveryTasks);\n                        }\n                        catch { }\n                    }\n                    this._autoDiscoverComponents();\n                    const c = d?.querySelector(this._config.container);\n                    if (c) {\n                        this._ensureRootObserver(c);\n                        if (this._config.delegate)\n                            this._ensureDelegation(c);\n                        if (this._routerEnabled())\n                            this._installRouting(c);\n                    }\n                    try {\n                        this._currentDocURL = this._normalizeDocURL(location.href);\n                    }\n                    catch { }\n                };\n                if (d && d.readyState === 'loading') {\n                    d.addEventListener('DOMContentLoaded', () => { void start(); });\n                }\n                else if (!d || d.readyState === 'complete' || d.readyState === 'interactive') {\n                    void start();\n                }\n                return this;\n            };\n            this._inflightComponentLoads = new Map();\n            this._lazyComponentSources = new Map();\n            this.loadComponents = (sources) => {\n                const items = sources.map(s => typeof s === 'string' ? { path: s, mode: 'preload', name: undefined } : { path: s.path, mode: (s.mode || 'preload'), name: s.name });\n                const tasks = [];\n                for (const it of items) {\n                    if (it.mode === 'defer') {\n                        const p = this._fetchAndEvalComponent(it.path).catch(() => { throw new Error('load failed'); });\n                        this._preDiscoveryTasks.push(p);\n                        tasks.push(p.then(() => { }));\n                    }\n                    else if (it.mode === 'lazy') {\n                        const inferredName = (it.name || it.path.split('/').pop() || '').replace(/\\.(mjs|js|ts)(\\?.*)?$/i, '').toLowerCase();\n                        if (inferredName && !this._lazyComponentSources.has(inferredName)) {\n                            this._lazyComponentSources.set(inferredName, { path: it.path, status: LS_PENDING });\n                        }\n                    }\n                    else {\n                        const p = this._fetchAndEvalComponent(it.path).catch(() => { throw new Error('load failed'); });\n                        tasks.push(p);\n                    }\n                }\n                return Promise.allSettled(tasks).then(results => {\n                    try {\n                        this._autoDiscoverComponents();\n                    }\n                    catch { }\n                    const settled = results.length;\n                    const failed = results.filter(r => r.status === 'rejected').length;\n                    return { settled, failed };\n                });\n            };\n            this.createComponent = (definition) => {\n                const component = new ReactiveComponent(this._generateComponentId(), definition, this);\n                this._components.set(component.id, component);\n                component.callBeforeMount();\n                return component;\n            };\n            this._autoDiscoverComponents = () => {\n                const container = d?.querySelector(this._config.container);\n                if (!container)\n                    return;\n                const dataAttr = attrName('data');\n                if (container.hasAttribute(dataAttr) && !this._getComponentByElement(container)) {\n                    this._bindElementAsComponent(container, undefined);\n                }\n                const componentElements = container.querySelectorAll(`[${dataAttr}]`);\n                for (const element of componentElements) {\n                    if (!this._getComponentByElement(element))\n                        this._bindElementAsComponent(element);\n                }\n                const reusable = container.querySelectorAll('component[source]');\n                for (const el of reusable) {\n                    if (!this._getComponentByElement(el))\n                        this._instantiateNamedComponent(el);\n                }\n                this._processPending();\n                if (componentElements[STR_LENGTH] === 0 && !this._getComponentByElement(container)) {\n                    const components = _Afrom(this._components.values());\n                    const lastComponent = components[components[STR_LENGTH] - 1];\n                    if (lastComponent && !lastComponent.isBound) {\n                        lastComponent.bindToElement(container);\n                    }\n                }\n            };\n            this._processPending = () => {\n                if (!this._pending[STR_LENGTH])\n                    return;\n                for (const p of this._pending) {\n                    let cur = p.el.parentElement;\n                    let parent;\n                    while (cur && !parent) {\n                        const maybe = this._getComponentByElement(cur);\n                        if (maybe)\n                            parent = maybe;\n                        else\n                            cur = cur.parentElement;\n                    }\n                    if (parent) {\n                        p.comp.attachToParent(parent);\n                    }\n                }\n                for (const p of this._pending)\n                    p.comp.completeBinding();\n                this._pending = [];\n            };\n            this._bindElementAsComponent = (element, parentForEval) => {\n                const dataExpression = element.getAttribute(attrName('data'));\n                let data = {};\n                if (dataExpression) {\n                    element.removeAttribute(attrName('data'));\n                    try {\n                        if (parentForEval) {\n                            let parentCtx = {};\n                            if (parentForEval._createMethodContext) {\n                                try {\n                                    parentCtx = parentForEval._createMethodContext();\n                                }\n                                catch { }\n                            }\n                            const evalFn = new Function('parent', `with(parent){ return (${dataExpression}) }`);\n                            data = evalFn(parentCtx);\n                        }\n                        else {\n                            data = this._parseDataExpression(dataExpression);\n                        }\n                        const desc = Object.getOwnPropertyDescriptors(data);\n                        const computed = {};\n                        const plainData = {};\n                        for (const key in desc) {\n                            const dsc = desc[key];\n                            if (typeof dsc.get === 'function') {\n                                const getter = dsc.get;\n                                computed[key] = function () { return getter.call(this); };\n                            }\n                            else if ('value' in dsc) {\n                                plainData[key] = dsc.value;\n                            }\n                        }\n                        const hasOwnMethods = plainData.methods || data.methods;\n                        const methodsObj = data.methods;\n                        const def = hasOwnMethods ? { methods: methodsObj, data: plainData } : { data: plainData };\n                        if (_Okeys(computed).length)\n                            def.computed = computed;\n                        if (parentForEval) {\n                            def.data.$parent = parentForEval;\n                        }\n                        data = def;\n                    }\n                    catch (e) {\n                    }\n                }\n                const comp = this.createComponent(data);\n                const initExpr = element.getAttribute(attrName('init')) || undefined;\n                if (initExpr)\n                    element.removeAttribute(attrName('init'));\n                this._finalizeComponentMount(element, comp, { callBeforeMount: true, xInitExpr: initExpr });\n            };\n            this._generateComponentId = () => {\n                const now = Date.now();\n                const random = Math.random().toString(36).substring(2, 15);\n                const counter = (this._components.size + 1).toString(36);\n                return `component_${now}_${counter}_${random}`;\n            };\n            this._parseDataExpression = (expression) => {\n                try {\n                    return new Function('return ' + expression.trim())();\n                }\n                catch {\n                    return {};\n                }\n            };\n            this._unregisterComponent = (componentId) => { this._components.delete(componentId); };\n            this._log = (..._args) => { };\n            this._registerElement = (element, component) => {\n                this._byEl.set(element, component);\n            };\n            this._unregisterElement = (element) => { try {\n                this._byEl.delete(element);\n            }\n            catch { } };\n        }\n        _routerEnabled() { const c = this._config; return !!(c.router?.enabled); }\n        _routerTransitionName() { const c = this._config; return (c.router?.transitionName ?? 'route'); }\n        _isSameOrigin(href) {\n            try {\n                const u = new URL(href, d?.baseURI || location.href);\n                const cur = new URL(location.href);\n                return u.origin === cur.origin;\n            }\n            catch {\n                return false;\n            }\n        }\n        _isSameDocument(target) {\n            try {\n                const u = typeof target === 'string' ? new URL(target, d?.baseURI || location.href) : target;\n                const cur = new URL(location.href);\n                return (u.origin === cur.origin && u.pathname === cur.pathname && u.search === cur.search);\n            }\n            catch {\n                return false;\n            }\n        }\n        _normalizeDocURL(target) {\n            const u = typeof target === 'string' ? new URL(target, d?.baseURI || location.href) : target;\n            return `${u.origin}${u.pathname}${u.search}`;\n        }\n        _scrollToHash(hash) {\n            try {\n                if (!hash || hash === '#')\n                    return false;\n                const id = decodeURIComponent(hash.replace(/^#/, ''));\n                const el = d.getElementById(id) || d.querySelector(`[name=\"${CSS.escape(id)}\"]`);\n                if (el) {\n                    el.scrollIntoView({ block: 'start', 'behavior': 'instant' });\n                    return true;\n                }\n            }\n            catch { }\n            return false;\n        }\n        _installRouting(root) {\n            const self = this;\n            const preload = (href) => {\n                try {\n                    if (!self._isSameOrigin(href))\n                        return;\n                }\n                catch {\n                    return;\n                }\n                const u = new URL(href, location.href);\n                if (self._isSameDocument(u))\n                    return;\n                u.hash = '';\n                const url = u.toString();\n                if (self._prefetched.has(url))\n                    return;\n                const existing = d?.head?.querySelector(`link[rel=\"prefetch\"][href=\"${CSS.escape(url)}\"]`);\n                if (existing) {\n                    self._prefetched.add(url);\n                    return;\n                }\n                try {\n                    const link = d.createElement('link');\n                    link.setAttribute('rel', 'prefetch');\n                    link.setAttribute('as', 'document');\n                    link.setAttribute('href', url);\n                    d.head.appendChild(link);\n                    self._prefetched.add(url);\n                }\n                catch { }\n            };\n            const onClick = (e) => {\n                const ev = e;\n                if (ev.defaultPrevented || ev.metaKey || ev.ctrlKey || ev.shiftKey || ev.altKey)\n                    return;\n                let el = ev.target;\n                while (el && el !== root && el.tagName !== 'A')\n                    el = el.parentElement;\n                if (!el || el.tagName !== 'A' || el.hasAttribute('download'))\n                    return;\n                const a = el;\n                const href = a.getAttribute('href');\n                if (!href || href.startsWith('#'))\n                    return;\n                const target = a.getAttribute('target');\n                if (target && target.toLowerCase() === '_blank')\n                    return;\n                if (!self._isSameOrigin(href))\n                    return;\n                const url = new URL(href, location.href);\n                if (self._isSameDocument(url))\n                    return;\n                ev.preventDefault();\n                self._navigate(url.toString(), true, 'link').catch(() => { location.assign(url.toString()); });\n            };\n            root.addEventListener('click', onClick);\n            if (this._config.router?.prefetchOnHover) {\n                const preloadEventHandler = (e) => {\n                    const t = e.target;\n                    let el = t;\n                    while (el && el !== root && el.tagName !== 'A')\n                        el = el.parentElement;\n                    if (!el || el.tagName !== 'A' || el.hasAttribute('download'))\n                        return;\n                    const href = el.getAttribute('href');\n                    if (!href || href.startsWith('#'))\n                        return;\n                    preload(href);\n                };\n                root.addEventListener('mouseover', preloadEventHandler, { passive: true });\n                root.addEventListener('touchstart', preloadEventHandler, { passive: true });\n            }\n            window.addEventListener('popstate', () => { self._navigate(location.href, false, 'popstate').catch(() => { }); });\n        }\n        async _navigate(url, push, source = 'program') {\n            if (!this._routerEnabled())\n                return Promise.resolve();\n            if (!this._isSameOrigin(url)) {\n                location.assign(url);\n                return;\n            }\n            const targetURL = new URL(url);\n            const targetKey = this._normalizeDocURL(targetURL);\n            if (source !== 'popstate') {\n                if (this._isSameDocument(targetURL)) {\n                    location.href = url;\n                    return;\n                }\n            }\n            else {\n                if (this._currentDocURL && targetKey === this._currentDocURL) {\n                    this._scrollToHash(targetURL.hash);\n                    return;\n                }\n            }\n            const from = location.href;\n            try {\n                const res = await (this._config.router?.before?.(url, from, { source }));\n                if (res === false)\n                    return;\n            }\n            catch (err) {\n                try {\n                    this._config.router?.error?.(err, url, from);\n                }\n                catch { }\n                return;\n            }\n            const curKey = this._currentDocURL || this._normalizeDocURL(from);\n            this._scrollPositions.set(curKey, { x: window.scrollX || 0, y: window.scrollY || 0 });\n            try {\n                const html = await this._fetchHTML(url);\n                if (push)\n                    history.pushState({}, '', url);\n                await this._swapDocument(html);\n                this._currentDocURL = targetKey;\n                _se(() => {\n                    if (source === 'popstate') {\n                        const pos = this._scrollPositions.get(targetKey);\n                        if (pos)\n                            (window).scrollTo(pos.x, pos.y);\n                        else if (!this._scrollToHash(targetURL.hash))\n                            (window).scrollTo(0, 0);\n                    }\n                    else {\n                        if (!this._scrollToHash(targetURL.hash))\n                            (window).scrollTo(0, 0);\n                    }\n                });\n                try {\n                    await this._config.router?.after?.(url, from, { source });\n                }\n                catch { }\n            }\n            catch (err) {\n                if (err && (err.name === 'XToolRedirect' || err.message === 'XToolRedirect'))\n                    return;\n                _se(() => this._config.router?.error?.(err, url, from));\n                try {\n                    location.assign(url);\n                }\n                catch {\n                    _se(() => location.href = url);\n                }\n            }\n        }\n        async _fetchHTML(url) {\n            const res = await fetch(url, { credentials: 'same-origin', cache: 'default', redirect: 'follow' });\n            if (res.redirected) {\n                const finalUrl = res.url;\n                try {\n                    location.assign(finalUrl);\n                }\n                catch {\n                    _se(() => location.href = finalUrl);\n                }\n                const e = new Error('XToolRedirect');\n                e.name = 'XToolRedirect';\n                e.url = finalUrl;\n                throw e;\n            }\n            if (!res.ok)\n                throw new Error(res.status + ' ' + res.statusText);\n            return await res.text();\n        }\n        async _swapDocument(html) {\n            const parser = new DOMParser();\n            const doc = parser.parseFromString(html, 'text/html');\n            const newHead = doc.head;\n            const newTitle = newHead?.querySelector('title');\n            const applySwap = () => {\n                if (newTitle) {\n                    const t = newTitle.textContent || '';\n                    if (document.title !== t)\n                        document.title = t;\n                }\n                const sel = this._config.container || 'body';\n                const cur = d.querySelector(sel);\n                const next = doc.querySelector(sel);\n                if (cur && next) {\n                    this._morphElement(cur, next);\n                }\n                else if (next) {\n                    d.body.innerHTML = next.innerHTML;\n                }\n                else {\n                    d.body.innerHTML = doc.body.innerHTML;\n                }\n                this._byEl.delete(cur);\n                this._autoDiscoverComponents();\n                const c = d?.querySelector(this._config.container);\n                if (c) {\n                    this._ensureRootObserver(c);\n                    if (this._config.delegate)\n                        this._ensureDelegation(c);\n                }\n            };\n            const vt = (document).startViewTransition?.bind(document);\n            if (vt && this._getConfig().router?.transitionName) {\n                const sel = this._config.container || 'body';\n                const cont = d.querySelector(sel);\n                const prev = cont ? (cont.style.getPropertyValue('view-transition-name') || '') : '';\n                _se(() => { if (cont)\n                    cont.style.setProperty('view-transition-name', this._routerTransitionName()); });\n                try {\n                    const transition = vt(applySwap);\n                    await transition.finished;\n                }\n                finally {\n                    try {\n                        if (cont) {\n                            if (prev)\n                                cont.style.setProperty('view-transition-name', prev);\n                            else\n                                cont.style.removeProperty('view-transition-name');\n                        }\n                    }\n                    catch { }\n                }\n            }\n            else\n                applySwap();\n        }\n        _setAttributes(cur, next) {\n            const curAttrs = cur.getAttributeNames();\n            for (let i = 0; i < curAttrs.length; i++) {\n                const name = curAttrs[i];\n                if (!next.hasAttribute(name))\n                    cur.removeAttribute(name);\n            }\n            const nextAttrs = next.getAttributeNames();\n            for (let i = 0; i < nextAttrs.length; i++) {\n                const name = nextAttrs[i];\n                const val = next.getAttribute(name);\n                if (cur.getAttribute(name) !== val)\n                    cur.setAttribute(name, val);\n            }\n        }\n        _attributesEqual(a, b) {\n            const aNames = a.getAttributeNames();\n            const bNames = b.getAttributeNames();\n            if (aNames.length !== bNames.length)\n                return false;\n            const map = new Map();\n            for (let i = 0; i < aNames.length; i++) {\n                const n = aNames[i];\n                map.set(n, a.getAttribute(n));\n            }\n            for (let i = 0; i < bNames.length; i++) {\n                const n = bNames[i];\n                if (!map.has(n))\n                    return false;\n                if (map.get(n) !== b.getAttribute(n))\n                    return false;\n            }\n            return true;\n        }\n        _isDynamicNode(el) {\n            const tag = el.tagName;\n            if (tag === 'IFRAME' && el.hasAttribute('src'))\n                return true;\n            if (tag === 'COMPONENT' && el.hasAttribute('source'))\n                return true;\n            return false;\n        }\n        _morphElement(cur, next) {\n            if (cur.nodeName !== next.nodeName || this._isDynamicNode(next)) {\n                cur.replaceWith(next.cloneNode(true));\n                return;\n            }\n            this._setAttributes(cur, next);\n            if (!cur.firstChild && !next.firstChild)\n                return;\n            const curChildren = Array.from(cur.childNodes);\n            const nextChildren = Array.from(next.childNodes);\n            const max = nextChildren.length;\n            for (let i = 0; i < max; i++) {\n                const n = nextChildren[i];\n                const c = curChildren[i];\n                if (!c) {\n                    cur.appendChild(n.cloneNode(true));\n                    continue;\n                }\n                if (n.nodeType === c.nodeType) {\n                    if (n.nodeType === 3) {\n                        const a = c;\n                        const b = n;\n                        if (a.data !== b.data)\n                            a.data = b.data;\n                    }\n                    else if (n.nodeType === 1) {\n                        const cn = c;\n                        const nn = n;\n                        if (this._isDynamicNode(nn)) {\n                            try {\n                                cn.replaceWith(nn.cloneNode(true));\n                            }\n                            catch { }\n                        }\n                        else if (cn.nodeName === nn.nodeName && this._attributesEqual(cn, nn)) {\n                            this._morphElement(cn, nn);\n                        }\n                        else {\n                            try {\n                                cn.replaceWith(nn.cloneNode(true));\n                            }\n                            catch { }\n                        }\n                    }\n                    else {\n                        try {\n                            c.replaceWith(n.cloneNode(true));\n                        }\n                        catch { }\n                    }\n                }\n                else {\n                    try {\n                        c.replaceWith(n.cloneNode(true));\n                    }\n                    catch { }\n                }\n            }\n            if (curChildren.length > max) {\n                for (let i = curChildren.length - 1; i >= max; i--) {\n                    const toRemove = cur.childNodes[i];\n                    try {\n                        cur.removeChild(toRemove);\n                    }\n                    catch { }\n                }\n            }\n        }\n        _fetchAndEvalComponent(path, retries = 2, baseDelay = 300) {\n            const existing = this._inflightComponentLoads.get(path);\n            if (existing)\n                return existing;\n            const self = this;\n            const isTypeScript = /\\.ts?$/.test(new URL(path, d?.baseURI || location.href).pathname);\n            const html = (strings, ...values) => strings.reduce((acc, str, i) => acc + str + (i < values.length ? values[i] : ''), '') + `\\n`;\n            const attempt = (n) => {\n                return fetch(path, { cache: 'no-cache' }).then(res => {\n                    if (!res.ok)\n                        throw new Error(res.status + ' ' + res.statusText);\n                    return res.text();\n                }).then(code => {\n                    if (isTypeScript) {\n                        code = stripTypes(code);\n                    }\n                    const wrapped = code + `\\n//# sourceURL=${path}`;\n                    try {\n                        new Function('XTool', 'html', wrapped)(self, html);\n                    }\n                    catch (err) {\n                        console.error(`Error evaluating component script at ${path}:`, err);\n                    }\n                }).catch(err => {\n                    if (n >= retries)\n                        throw err;\n                    const delay = baseDelay * Math.pow(2, n);\n                    return new Promise(resolve => setTimeout(resolve, delay)).then(() => attempt(n + 1));\n                });\n            };\n            const p = attempt(0).finally(() => { this._inflightComponentLoads.delete(path); });\n            this._inflightComponentLoads.set(path, p);\n            return p;\n        }\n        _applyPrefixInitialCSS() {\n            if (!d)\n                return;\n            if (PFX === 'x')\n                return;\n            const id = `x-tool-initial-css-${PFX}`;\n            if (d.head && !d.getElementById(id)) {\n                const style = d.createElement(STR_STYLE);\n                style.id = id;\n                style.textContent = `[${PFX}-show],[${PFX}-if],[${PFX}-else],[${PFX}-else-if],[${PFX}\\\\:show],[${PFX}\\\\:if],[${PFX}\\\\:else],[${PFX}\\\\:else-if]{display:none;}`;\n                d.head.appendChild(style);\n            }\n        }\n        _ensureRootObserver(container) {\n            if (this._rootObserver || typeof MutationObserver === 'undefined')\n                return;\n            this._rootObserver = new MutationObserver(records => {\n                for (const r of records) {\n                    if (r.type === 'childList') {\n                        for (let i = 0; i < r.addedNodes.length; i++) {\n                            const n = r.addedNodes[i];\n                            if (n.nodeType !== 1)\n                                continue;\n                            const el = n;\n                            if (el[STR_TAGNAME] === 'COMPONENT') {\n                                const src = el.getAttribute(STR_SOURCE);\n                                if (src && !this._getComponentByElement(el))\n                                    this._instantiateNamedComponent(el);\n                            }\n                        }\n                        for (let i = 0; i < r.removedNodes.length; i++) {\n                            const n = r.removedNodes[i];\n                            if (n.nodeType !== 1)\n                                continue;\n                            const el = n;\n                            quMct(() => {\n                                if (el.isConnected)\n                                    return;\n                                const stack = [el];\n                                while (stack.length) {\n                                    const cur = stack.pop();\n                                    const comp = this._getComponentByElement(cur);\n                                    if (comp && !comp.isDestroyed) {\n                                        try {\n                                            comp.destroy();\n                                        }\n                                        catch { }\n                                    }\n                                    let child = cur.firstElementChild;\n                                    while (child) {\n                                        stack.push(child);\n                                        child = child.nextElementSibling;\n                                    }\n                                }\n                            });\n                        }\n                    }\n                    else if (r.type === 'attributes') {\n                        const target = r.target;\n                        if (target && target[STR_TAGNAME] === 'COMPONENT') {\n                            if (r.attributeName === STR_SOURCE) {\n                                this._onComponentSourceChanged(target);\n                            }\n                            else if (r.attributeName === STR_READONLY) {\n                                const comp = this._getComponentByElement(target);\n                                if (comp) {\n                                    try {\n                                        const ro = target.hasAttribute(STR_READONLY);\n                                        comp.setFrozen(!!ro);\n                                    }\n                                    catch { }\n                                }\n                            }\n                        }\n                    }\n                }\n                this._processPending();\n            });\n            this._rootObserver.observe(container, { childList: true, subtree: true, attributes: true, attributeFilter: [STR_SOURCE, STR_READONLY] });\n        }\n        _ensureIO(rootMargin) {\n            if (typeof IntersectionObserver === 'undefined')\n                return null;\n            if (!this._ioObservers)\n                this._ioObservers = new Map();\n            if (!this._ioRegistry)\n                this._ioRegistry = new WkMap();\n            const key = rootMargin || '0px';\n            let io = this._ioObservers.get(key);\n            if (io)\n                return io;\n            const handle = (entries) => {\n                for (const entry of entries) {\n                    const el = entry.target;\n                    const reg = this._ioRegistry.get(el);\n                    if (!reg)\n                        continue;\n                    const now = !!entry.isIntersecting;\n                    const before = !!reg.visible;\n                    reg.visible = now;\n                    if (now && (!before)) {\n                        const arr = reg.enter || [];\n                        for (let i = 0; i < arr.length; i++) {\n                            _se(() => arr[i].cb(entry, { phase: 'enter', visible: now, before }));\n                        }\n                        if (arr.length)\n                            reg.enter = arr.filter(a => !a.once);\n                    }\n                    else if (!now && before) {\n                        const arr = reg.leave || [];\n                        for (let i = 0; i < arr.length; i++) {\n                            _se(() => arr[i].cb(entry, { phase: 'leave', visible: now, before }));\n                        }\n                        if (arr.length)\n                            reg.leave = arr.filter(a => !a.once);\n                    }\n                }\n            };\n            io = new IntersectionObserver(handle, { root: null, rootMargin: key });\n            this._ioObservers.set(key, io);\n            return io;\n        }\n        _ioObserve(el, rootMargin, onEnter, onLeave) {\n            const io = this._ensureIO(rootMargin);\n            if (!io)\n                return () => { };\n            if (!this._ioRegistry)\n                this._ioRegistry = new WkMap();\n            let reg = this._ioRegistry.get(el);\n            if (!reg) {\n                reg = { rootMargin };\n                this._ioRegistry.set(el, reg);\n            }\n            if (onEnter && onEnter.cb) {\n                (reg.enter || (reg.enter = [])).push({ cb: onEnter.cb, once: !!onEnter.once });\n            }\n            if (onLeave && onLeave.cb) {\n                (reg.leave || (reg.leave = [])).push({ cb: onLeave.cb, once: !!onLeave.once });\n            }\n            _se(() => io.observe(el));\n            return () => { _se(() => io.unobserve(el)); };\n        }\n        _onComponentSourceChanged(el) {\n            const src = _tr(el.getAttribute('source'));\n            const existing = this._getComponentByElement(el);\n            if (!src) {\n                if (existing && !existing.isDestroyed) {\n                    try {\n                        existing.destroy();\n                    }\n                    catch { }\n                }\n                el.innerHTML = '';\n                return;\n            }\n            if (existing && !existing.isDestroyed) {\n                try {\n                    existing.destroy();\n                }\n                catch { }\n            }\n            el.innerHTML = '';\n            this._instantiateNamedComponent(el);\n        }\n        _finalizeComponentMount(el, comp, opts) {\n            comp.element = el;\n            if (opts?.callBeforeMount) {\n                _se(() => comp.callBeforeMount());\n            }\n            this._registerElement(comp.element, comp);\n            this._pending.push({ el, comp });\n            if (opts?.xInitExpr) {\n                const initExpr = opts.xInitExpr;\n                const existingMounted = comp._lifecycle?.mounted;\n                comp._lifecycle.mounted = function () {\n                    if (existingMounted) {\n                        _se(() => existingMounted.call(this));\n                    }\n                    const evaluator = new Function('ctx', 'with(ctx){' + initExpr + '} ');\n                    quMct(() => {\n                        if (comp.isDestroyed || !comp.element || !comp.element.isConnected)\n                            return;\n                        try {\n                            const ctx = comp._createMethodContext?.() || comp.getContext?.() || {};\n                            const result = evaluator(ctx);\n                            if (typeof result === 'function') {\n                                _se(() => result());\n                            }\n                        }\n                        catch { }\n                    });\n                };\n            }\n        }\n        _instantiateNamedComponent(el) {\n            const source = el.getAttribute('source');\n            if (!source)\n                return;\n            let def = this._getRegisteredComponentDef(source);\n            if (!def) {\n                const name = source.toLowerCase();\n                const lazy = this._lazyComponentSources?.get(name);\n                if (lazy) {\n                    if (lazy.status === LS_PENDING) {\n                        lazy.status = LS_LOADING;\n                        lazy.promise = this._fetchAndEvalComponent(lazy.path)\n                            .then(() => { lazy.status = LS_LOADED; })\n                            .catch(() => { lazy.status = LS_ERROR; });\n                    }\n                    lazy.promise?.then(() => { _se(() => { const again = this._getRegisteredComponentDef(source); if (again)\n                        this._instantiateNamedComponent(el); }); });\n                }\n                return;\n            }\n            let parentComp;\n            let par = el.parentElement;\n            while (par && !parentComp) {\n                const maybe = this._getComponentByElement(par);\n                if (maybe)\n                    parentComp = maybe;\n                else\n                    par = par.parentElement;\n            }\n            let props = null;\n            let dynamicPropObj = null;\n            let rawPropExpression = null;\n            if (!props)\n                props = {};\n            const propExpr = el.getAttribute(attrName('prop'));\n            if (propExpr) {\n                rawPropExpression = propExpr;\n                if (parentComp) {\n                    try {\n                        const fn = new Function('ctx', 'with(ctx){return (' + propExpr + ')}');\n                        const ctx = parentComp.getContext(true);\n                        dynamicPropObj = fn(ctx);\n                    }\n                    catch {\n                        dynamicPropObj = null;\n                    }\n                }\n                else {\n                    try {\n                        dynamicPropObj = new Function('return (' + propExpr + ')')();\n                    }\n                    catch {\n                        dynamicPropObj = null;\n                    }\n                }\n                if (dynamicPropObj && typeof dynamicPropObj === 'object')\n                    for (const k in dynamicPropObj)\n                        if (!(k in props))\n                            props[k] = String(dynamicPropObj[k]);\n                el.removeAttribute(attrName('prop'));\n            }\n            let baseData = {};\n            if (def.makeData) {\n                _se(() => { const result = def.makeData(props); if (result)\n                    baseData = result; });\n            }\n            if (def.data) {\n                for (const k in def.data) {\n                    baseData[k] = def.data[k];\n                }\n            }\n            for (const k in props) {\n                if (!(k in baseData))\n                    baseData[k] = props[k];\n            }\n            baseData.$props = props;\n            let initDef;\n            if (typeof def.init === 'function') {\n                try {\n                    const maybe = def.init(props);\n                    initDef = (maybe && typeof maybe === 'object') ? maybe : undefined;\n                }\n                catch {\n                    initDef = undefined;\n                }\n            }\n            const compDef = {\n                data: baseData,\n                methods: { ...(def.methods || {}), ...(initDef?.methods || {}) },\n                computed: { ...(def.computed || {}), ...(initDef?.computed || {}) },\n                propEffects: { ...(def.propEffects || {}), ...(initDef?.propEffects || {}) },\n                mounted: initDef?.mounted || def.mounted,\n                unmounted: initDef?.unmounted || def.unmounted,\n                beforeMount: initDef?.beforeMount || def.beforeMount,\n                beforeUnmount: initDef?.beforeUnmount || def.beforeUnmount,\n                updated: initDef?.updated || def.updated,\n                destroyed: initDef?.destroyed || def.destroyed,\n                beforeDestroy: initDef?.beforeDestroy || def.beforeDestroy\n            };\n            const comp = this.createComponent(compDef);\n            const originalChildren = Array.from(el.childNodes);\n            if (originalChildren.length)\n                el.replaceChildren();\n            if (def.template) {\n                const applyTemplate = (tpl) => {\n                    el.innerHTML = tpl;\n                    const slots = el.querySelectorAll('slot');\n                    if (slots.length) {\n                        for (const slotEl of slots) {\n                            const name = slotEl.getAttribute('name');\n                            const matched = name\n                                ? originalChildren.filter(n => n.nodeType === 1 && n.getAttribute('slot') === name)\n                                : originalChildren.filter(n => n.nodeType !== 1 || !n.hasAttribute('slot'));\n                            if (matched.length)\n                                slotEl.replaceWith(...matched);\n                        }\n                    }\n                };\n                const tplVal = def.template;\n                if (typeof tplVal === 'string') {\n                    applyTemplate(tplVal);\n                }\n                else if (typeof tplVal === 'function') {\n                    try {\n                        const res = tplVal();\n                        if (res && typeof res.then === 'function') {\n                            el.innerHTML = '';\n                            res.then(html => { applyTemplate(html || ''); _se(() => comp._applyAsyncTemplateResolved()); });\n                        }\n                        else {\n                            applyTemplate(String(res || ''));\n                        }\n                    }\n                    catch {\n                        el.innerHTML = '';\n                    }\n                }\n                else if (tplVal && typeof tplVal.then === 'function') {\n                    el.innerHTML = '';\n                    tplVal.then(html => { applyTemplate(html || ''); _se(() => comp._applyAsyncTemplateResolved()); });\n                }\n            }\n            else {\n                if (originalChildren.length)\n                    el.append(...originalChildren);\n            }\n            this._finalizeComponentMount(el, comp, { callBeforeMount: false });\n            try {\n                const nested = el.querySelectorAll(`[${attrName('data')}]`);\n                for (const node of nested) {\n                    if (!this._getComponentByElement(node))\n                        this._bindElementAsComponent(node, comp);\n                }\n            }\n            catch { }\n            if (rawPropExpression && parentComp) {\n                _se(() => comp._initReactiveProps(rawPropExpression, parentComp));\n            }\n            this._processPending();\n        }\n        _getComponentByElement(element) { return this._byEl.get(element); }\n        observe(_element) { }\n        _ensureDelegation(container) {\n            if (this._delegatedRootBound)\n                return;\n            const root = container;\n            const handler = (e) => {\n                let cur = e.target;\n                while (cur && cur !== root.parentElement) {\n                    if (e.cancelBubble)\n                        break;\n                    const map = this._delegated.get(cur);\n                    if (map) {\n                        const list = map.get(e.type);\n                        if (list && list.length) {\n                            for (const h of [...list]) {\n                                try {\n                                    if (h.comp && h.comp.isDestroyed) {\n                                        const i = list.indexOf(h);\n                                        if (i > -1)\n                                            list.splice(i, 1);\n                                        continue;\n                                    }\n                                    if (!h.filter || h.filter(e)) {\n                                        h.run(e);\n                                        if (h.once) {\n                                            const idx = list.indexOf(h);\n                                            if (idx > -1)\n                                                list.splice(idx, 1);\n                                        }\n                                    }\n                                }\n                                catch { }\n                            }\n                        }\n                    }\n                    cur = cur.parentElement;\n                }\n            };\n            const captureEvents = ['keydown', 'keyup'];\n            const bubbleEvents = ['click', 'input', 'change'];\n            for (const ev of captureEvents)\n                root.addEventListener(ev, handler, true);\n            for (const ev of bubbleEvents)\n                root.addEventListener(ev, handler, false);\n            this._delegatedRootBound = true;\n        }\n        _registerDelegated(element, event, entry) {\n            let map = this._delegated.get(element);\n            if (!map) {\n                map = new Map();\n                this._delegated.set(element, map);\n            }\n            let list = map.get(event);\n            if (!list) {\n                list = [];\n                map.set(event, list);\n            }\n            list.push(entry);\n            return () => {\n                try {\n                    const m = this._delegated.get(element);\n                    const l = m?.get(event);\n                    if (!l)\n                        return;\n                    const idx = l.indexOf(entry);\n                    if (idx > -1)\n                        l.splice(idx, 1);\n                }\n                catch { }\n            };\n        }\n    }\n    class ReactiveComponent {\n        attachToParent(parent) {\n            this._parent = parent;\n            parent._addChild(this);\n        }\n        get id() { return this._id; }\n        get framework() { return this._framework; }\n        get element() { return this._element; }\n        set element(el) { this._element = el; }\n        get isBound() { return this._isBound; }\n        set isBound(v) { this._isBound = v; }\n        get isMounted() { return this._isMounted; }\n        set isMounted(v) { this._isMounted = v; }\n        get isDestroyed() { return this._isDestroyed; }\n        set isDestroyed(v) { this._isDestroyed = v; }\n        _abortInvokerResources() {\n            for (const byKind of this._invokerResources.values()) {\n                for (const cleanup of byKind.values()) {\n                    _se(cleanup);\n                }\n            }\n            this._invokerResources.clear();\n        }\n        _cancelUserResources() {\n            this._abortInvokerResources();\n        }\n        _resolveBindingMeta(element, attributeName) {\n            const elAny = element;\n            let propName = attributeName in elAny ? attributeName : null;\n            if (!propName) {\n                const camel = attributeName.replace(/-([a-z])/g, (_, c) => c.toUpperCase());\n                propName = camel in elAny ? camel : (attributeName.toLowerCase() === 'readonly' && 'readOnly' in elAny ? 'readOnly' : null);\n            }\n            const isBooleanProp = !!(propName && typeof elAny[propName] === 'boolean');\n            const hasNonFunctionProp = !!(propName && typeof elAny[propName] !== 'function');\n            const isKnownBooleanAttr = !!ReactiveComponent._BA[attributeName.toLowerCase()];\n            return { elAny, propName, isBooleanProp, hasNonFunctionProp, isKnownBooleanAttr };\n        }\n        _applyGenericBinding(element, attributeName, value, meta) {\n            const { elAny, propName, isBooleanProp, hasNonFunctionProp, isKnownBooleanAttr } = meta;\n            if ((isBooleanProp && propName) || isKnownBooleanAttr) {\n                const boolVal = !!value;\n                if (propName && isBooleanProp)\n                    elAny[propName] = boolVal;\n                if (boolVal)\n                    element.setAttribute(attributeName, '');\n                else\n                    element.removeAttribute(attributeName);\n                return;\n            }\n            let normalized = null;\n            if (value && typeof value === 'object') {\n                const parts = [];\n                for (const k in value) {\n                    if (value[k])\n                        parts.push(k);\n                }\n                normalized = parts.length ? parts.join(' ') : null;\n            }\n            else if (value !== null && value !== undefined) {\n                normalized = String(value);\n            }\n            if (hasNonFunctionProp && propName) {\n                if (normalized !== null) {\n                    try {\n                        elAny[propName] = normalized;\n                    }\n                    catch {\n                        try {\n                            element.setAttribute(attributeName, normalized);\n                        }\n                        catch { }\n                    }\n                }\n                else {\n                    element.removeAttribute(attributeName);\n                }\n                return;\n            }\n            if (normalized !== null) {\n                const cur = element.getAttribute(attributeName);\n                if (cur !== normalized)\n                    element.setAttribute(attributeName, normalized);\n            }\n            else {\n                element.removeAttribute(attributeName);\n            }\n        }\n        _scanDirectiveAttrs(el, opts) {\n            const prefixDash = PFX + '-';\n            const prefixColon = PFX + ':';\n            const namesOut = [];\n            let hasTextOrHtml = false;\n            let forName = null;\n            const names = el.getAttributeNames();\n            for (let i = 0; i < names.length; i++) {\n                const name = names[i];\n                const isDir = name.startsWith(prefixDash) || name.startsWith(prefixColon) || name.startsWith('@');\n                if (!isDir)\n                    continue;\n                if (opts?.skipRootFor && name === attrName('for'))\n                    continue;\n                namesOut.push(name);\n                if (!hasTextOrHtml && (name === attrName('text') || name === attrName('html')))\n                    hasTextOrHtml = true;\n                if (!forName && name === attrName('for'))\n                    forName = name;\n            }\n            return { names: namesOut, hasTextOrHtml, forName };\n        }\n        setFrozen(on) {\n            if (on === this._isFrozen)\n                return;\n            this._isFrozen = on;\n            if (on) {\n                this._sealedBeforeFreeze = this._isSealed;\n                this._isSealed = true;\n                this._cancelUserResources();\n            }\n            else {\n                if (this._sealedBeforeFreeze !== null) {\n                    this._isSealed = this._sealedBeforeFreeze;\n                }\n                else {\n                    this._isSealed = false;\n                }\n                this._sealedBeforeFreeze = null;\n                try {\n                    this._scheduleRender();\n                }\n                catch { }\n            }\n        }\n        _setSealed(on) {\n            if (on === this._isSealed)\n                return;\n            this._isSealed = on;\n            if (on) {\n                this._cancelUserResources();\n            }\n        }\n        _addDirective(element, directive) {\n            const existing = this._directives.get(element) || [];\n            existing.push(directive);\n            this._directives.set(element, existing);\n        }\n        constructor(id, def, framework) {\n            this._propUpdateActive = false;\n            this._runningPropEffect = false;\n            this._element = null;\n            this._isBound = false;\n            this._isMounted = false;\n            this._isDestroyed = false;\n            this._beforeMountCalled = false;\n            this._children = [];\n            this._parent = null;\n            this._computed = {};\n            this._propEffects = {};\n            this._computedCache = new Map();\n            this._computedDeps = new Map();\n            this._computedKeyStack = [];\n            this._isInComputedEvaluation = false;\n            this._isInMethodExecution = false;\n            this._allEffects = new Set();\n            this._hasComputed = false;\n            this._directives = new Map();\n            this._cleanupFunctions = new Set();\n            this._directiveAbort = new AbortController();\n            this._invokerResources = new Map();\n            this._targetIds = new WkMap();\n            this._targetSeq = 0;\n            this._isSealed = false;\n            this._isFrozen = false;\n            this._sealedBeforeFreeze = null;\n            this._isMutationEnabled = true;\n            this._effectsToRun = new Set();\n            this._currentInvoker = null;\n            this._loopScopes = new WkMap();\n            this._expressionCache = new Map();\n            this._propertyDependencies = new Map();\n            this._activeEffect = null;\n            this._renderScheduled = false;\n            this._nextTickQueue = [];\n            this._changeFrameId = null;\n            this._renderFrameId = null;\n            this._initialClassSets = new WkMap();\n            this._rawData = {};\n            this._propParent = null;\n            this._callLifecycleHook = (hookName) => {\n                const hook = this._lifecycle[hookName];\n                if (typeof hook === 'function') {\n                    this._safeExecute(() => this._runWithGlobalInterception(hook, []));\n                }\n            };\n            this._addCleanupFunction = (fn) => {\n                if (typeof fn !== 'function')\n                    return undefined;\n                const wrapped = () => {\n                    try {\n                        fn();\n                    }\n                    catch { }\n                    this._cleanupFunctions.delete(wrapped);\n                };\n                this._cleanupFunctions.add(wrapped);\n                return () => { this._cleanupFunctions.delete(wrapped); };\n            };\n            this._id = id;\n            this._framework = framework;\n            this._originalMethods = def.methods || {};\n            this._computed = this._bindComputed(def.computed || {});\n            this._propEffects = def.propEffects || {};\n            if (this._propEffects && Object.keys(this._propEffects).length) {\n                this._propEffects = this._bindPropEffects();\n            }\n            this._hasComputed = !!(def.computed && Object.keys(def.computed).length);\n            this._lifecycle = {\n                mounted: def.mounted,\n                unmounted: def.unmounted || def.destroyed,\n                updated: def.updated,\n                beforeMount: def.beforeMount,\n                beforeUnmount: def.beforeUnmount || def.beforeDestroy\n            };\n            this._rawData = this._cloneData(def.data || {});\n            this._data = this._createReactiveData(this._rawData || {});\n            this._methods = this._bindMethods();\n        }\n        _cloneData(value, seen) {\n            if (value === null || typeof value !== 'object')\n                return value;\n            const s = seen || new WeakMap();\n            if (s.has(value))\n                return s.get(value);\n            if (ARRAY_ISARRAY(value)) {\n                const arr = [];\n                s.set(value, arr);\n                for (let i = 0; i < value.length; i++)\n                    arr[i] = this._cloneData(value[i], s);\n                return arr;\n            }\n            if (value instanceof Date)\n                return new Date(value.getTime());\n            if (value instanceof RegExp)\n                return new RegExp(value.source, value.flags);\n            if (typeof Map !== 'undefined' && value instanceof Map) {\n                const m = new Map();\n                s.set(value, m);\n                value.forEach((v, k) => { m.set(this._cloneData(k, s), this._cloneData(v, s)); });\n                return m;\n            }\n            if (typeof Set !== 'undefined' && value instanceof Set) {\n                const st = new Set();\n                s.set(value, st);\n                value.forEach(v => st.add(this._cloneData(v, s)));\n                return st;\n            }\n            const proto = Object.getPrototypeOf(value);\n            if (proto === Object.prototype || proto === null) {\n                const out = Object.create(proto);\n                s.set(value, out);\n                for (const key of Object.keys(value)) {\n                    out[key] = this._cloneData(value[key], s);\n                }\n                return out;\n            }\n            return value;\n        }\n        callBeforeMount() {\n            if (!this._beforeMountCalled) {\n                this._callLifecycleHook('beforeMount');\n                this._beforeMountCalled = true;\n            }\n        }\n        _onDataChange(_property) {\n            if (!this.isBound)\n                return;\n            const self = this;\n            if (self._changeFrameId != null) {\n                _se(() => cancelAnimationFrame(self._changeFrameId));\n                self._changeFrameId = null;\n            }\n            if (this._isMutationEnabled === false)\n                return;\n            const effectsToRun = self._effectsToRun;\n            const directDeps = self._propertyDependencies.get(_property);\n            if (directDeps) {\n                for (let i = 0; i < directDeps.length; i++)\n                    effectsToRun.add(directDeps[i]);\n            }\n            if (FT_C && self._computedDeps.size) {\n                const queue = [_property];\n                const visited = new Set();\n                const affectedComputed = new Set();\n                let queueIdx = 0;\n                while (queueIdx < queue.length) {\n                    const base = queue[queueIdx++];\n                    if (visited.has(base))\n                        continue;\n                    visited.add(base);\n                    for (const [compKey, baseDeps] of self._computedDeps.entries()) {\n                        if (baseDeps.has(base) && !affectedComputed.has(compKey)) {\n                            affectedComputed.add(compKey);\n                            queue.push(compKey);\n                        }\n                    }\n                }\n                for (const compKey of affectedComputed) {\n                    const compEffects = self._propertyDependencies.get(compKey);\n                    if (compEffects) {\n                        for (let i = 0; i < compEffects.length; i++)\n                            effectsToRun.add(compEffects[i]);\n                    }\n                    self._computedCache.delete(compKey);\n                }\n            }\n            self._changeFrameId = requestAnimationFrame(() => {\n                if (FT_C)\n                    self._computedCache.clear();\n                self._changeFrameId = null;\n                if (self.isDestroyed || self._isSealed)\n                    return;\n                for (const effect of effectsToRun)\n                    self._safeExecute(effect);\n                effectsToRun.clear();\n                if (!directDeps?.length && (self._hasComputed || !XTOOL_ENABLE_STATIC_DIRECTIVES)) {\n                    self._scheduleRender();\n                }\n                self._callLifecycleHook('updated');\n            });\n        }\n        _bindMethods() {\n            return this._bindFunctionMap(this._originalMethods, 'methods');\n        }\n        _bindComputed(src) {\n            return this._bindFunctionMap(src, 'computed');\n        }\n        _bindPropEffects() {\n            return this._bindFunctionMap(this._propEffects || {}, 'prop');\n        }\n        _bindFunctionMap(src, kind) {\n            const out = {};\n            const isNative = (fn) => /\\[native code\\]/.test(String(fn));\n            const makeNoArgCtxRunner = (fn) => {\n                try {\n                    if (!isNative(fn)) {\n                        let body = String(fn).trim();\n                        if (!/^function[\\s\\(]/.test(body) && !/^[\\w\\$_][\\w\\d\\$_]*\\s*=>/.test(body) && !/^\\(.*?\\)\\s*=>/.test(body)) {\n                            body = 'function ' + body;\n                        }\n                        const compiled = new Function('ctx', `with(ctx){ const f = (${body}); return f.apply(this, []); }`);\n                        return () => { const ctx = this._createMethodContext(); return compiled.call(ctx, ctx); };\n                    }\n                }\n                catch { }\n                return () => fn.call(this._createMethodContext());\n            };\n            for (const key in (src || {})) {\n                const original = src[key];\n                if (typeof original !== 'function')\n                    continue;\n                if (kind === 'computed') {\n                    out[key] = makeNoArgCtxRunner(original);\n                }\n                else if (kind === 'methods') {\n                    out[key] = (...args) => {\n                        const prev = this._isInMethodExecution;\n                        const prevInv = this._currentInvoker;\n                        this._isInMethodExecution = true;\n                        this._currentInvoker = key;\n                        try {\n                            return this._safeExecute(() => this._runWithGlobalInterception(original, args));\n                        }\n                        finally {\n                            this._isInMethodExecution = prev;\n                            this._currentInvoker = prevInv;\n                        }\n                    };\n                }\n                else {\n                    out[key] = (newValue, oldValue) => {\n                        const prevInv = this._currentInvoker;\n                        const prevFlag = this._runningPropEffect;\n                        this._currentInvoker = `prop:${key}`;\n                        this._runningPropEffect = true;\n                        try {\n                            return this._safeExecute(() => this._runWithGlobalInterception(original, [newValue, oldValue]));\n                        }\n                        finally {\n                            this._runningPropEffect = prevFlag;\n                            this._currentInvoker = prevInv;\n                        }\n                    };\n                }\n            }\n            return out;\n        }\n        _getComputedValue(key) {\n            if (!FT_C)\n                return undefined;\n            this._trackDependency(key);\n            if (this._computedCache.has(key))\n                return this._computedCache.get(key);\n            this._isInComputedEvaluation = true;\n            this._computedKeyStack.push(key);\n            this._computedDeps.set(key, new Set());\n            try {\n                const getter = this._computed[key];\n                const value = typeof getter === 'function' ? getter() : undefined;\n                this._computedKeyStack.pop();\n                this._isInComputedEvaluation = this._computedKeyStack.length > 0;\n                this._computedCache.set(key, value);\n                return value;\n            }\n            catch (e) {\n                this._computedKeyStack.pop();\n                this._isInComputedEvaluation = this._computedKeyStack.length > 0;\n                return undefined;\n            }\n        }\n        _trackDependency(propKey) {\n            const activeEff = this._activeEffect;\n            if (!activeEff)\n                return;\n            let deps = this._propertyDependencies.get(propKey);\n            if (!deps) {\n                deps = [];\n                this._propertyDependencies.set(propKey, deps);\n            }\n            if (!deps.includes(activeEff))\n                deps.push(activeEff);\n            const stackLen = this._computedKeyStack.length;\n            if (this._isInComputedEvaluation && stackLen) {\n                const current = this._computedKeyStack[stackLen - 1];\n                let s = this._computedDeps.get(current);\n                if (!s) {\n                    s = new Set();\n                    this._computedDeps.set(current, s);\n                }\n                s.add(propKey);\n            }\n        }\n        _scheduleRender() {\n            if (this._isSealed || this._isFrozen || this._isDestroyed || this._renderScheduled)\n                return;\n            this._renderScheduled = true;\n            requestAnimationFrame(() => {\n                this._renderFrameId = null;\n                this._renderScheduled = false;\n                if (this._isDestroyed || this._isSealed) {\n                    if (this._nextTickQueue?.length)\n                        this._nextTickQueue.length = 0;\n                    return;\n                }\n                this._render();\n                if (this._nextTickQueue?.length) {\n                    const q = this._nextTickQueue.splice(0);\n                    for (const fn of q) {\n                        _se(fn);\n                    }\n                }\n            });\n        }\n        _safeExecute(fn, fallback) {\n            try {\n                return fn();\n            }\n            catch (error) {\n                console.error(error);\n                return fallback;\n            }\n        }\n        bindToElement(element) {\n            if (this._isBound)\n                return;\n            this._element = element;\n            if (!this._beforeMountCalled) {\n                this.callBeforeMount();\n            }\n            this.completeBinding();\n        }\n        getContext(includeComputed = true) {\n            return this._createMethodContext(includeComputed);\n        }\n        _applyAsyncTemplateResolved() {\n            if (!this._element)\n                return;\n            try {\n                this._parseDirectives(this._element);\n            }\n            catch { }\n            this._scheduleRender();\n        }\n        completeBinding() {\n            if (this._isBound || !this._element)\n                return;\n            if (!this._framework._getComponentByElement(this._element))\n                this._framework._registerElement(this._element, this);\n            this._isBound = true;\n            this._isMounted = true;\n            this._parseDirectives(this._element);\n            this._render();\n            this._callLifecycleHook('mounted');\n        }\n        _addChild(child) {\n            if (!this._children.includes(child)) {\n                this._children.push(child);\n            }\n        }\n        _removeChild(child) {\n            const index = this._children.indexOf(child);\n            if (index > -1) {\n                this._children.splice(index, 1);\n            }\n        }\n        _runWithGlobalInterception(fn, args) {\n            try {\n                const src = String(fn);\n                if (!/\\[native code\\]/.test(src)) {\n                    let body = src.trim();\n                    if (!/^function[\\s\\(]/.test(body) && !/^[\\w\\$_][\\w\\d\\$_]*\\s*=>/.test(body) && !/^\\(.*?\\)\\s*=>/.test(body)) {\n                        body = 'function ' + body;\n                    }\n                    const trySrc = 'with(ctx){ const f = (' + body + '); return f.apply(thisArg, argsArray); }';\n                    const wrapper = new Function('thisArg', 'argsArray', 'ctx', trySrc);\n                    const thisArg = this._createMethodContext();\n                    return wrapper.call(thisArg, thisArg, args, this._createContextProxy(undefined, undefined));\n                }\n            }\n            catch {\n            }\n            return fn.apply(this._createMethodContext(), args);\n        }\n        destroy() {\n            const self = this;\n            if (self._isDestroyed)\n                return;\n            self._callLifecycleHook('beforeUnmount');\n            for (const child of self._children) {\n                if (!child.isDestroyed)\n                    child.destroy();\n            }\n            if (self._parent) {\n                self._parent._removeChild(self);\n            }\n            for (const [element, directives] of self._directives) {\n                for (const directive of directives) {\n                    if (directive.type === 'custom' && directive.customDirective?.unbind) {\n                        _se(() => directive.customDirective.unbind(element, self));\n                    }\n                }\n            }\n            self._directives.clear();\n            try {\n                self._directiveAbort.abort();\n            }\n            catch { }\n            self._directiveAbort = new AbortController();\n            self._abortInvokerResources();\n            self._runCleanupCallbacks();\n            self._computedCache.clear();\n            self._expressionCache.clear();\n            self._propertyDependencies.clear();\n            if (self._propParent && self._propEffect) {\n                for (const deps of self._propParent._propertyDependencies.values()) {\n                    const idx = deps.indexOf(self._propEffect);\n                    if (idx > -1)\n                        deps.splice(idx, 1);\n                }\n            }\n            if (self._element)\n                self._framework._unregisterElement(self._element);\n            if (self._changeFrameId != null) {\n                _se(() => cancelAnimationFrame(self._changeFrameId));\n                self._changeFrameId = null;\n            }\n            if (self._renderFrameId != null) {\n                _se(() => cancelAnimationFrame(self._renderFrameId));\n                self._renderFrameId = null;\n            }\n            self._callLifecycleHook('unmounted');\n            self._isDestroyed = true;\n            self._isMounted = false;\n            self._isBound = false;\n            self._children = [];\n            self._parent = null;\n            self._deepReactiveCache = new WkMap;\n            self._effectsToRun.clear();\n            self._element = null;\n            quMct(() => self._framework._unregisterComponent(self._id));\n            self._data = {};\n            self._rawData = {};\n            self._methods = {};\n            self._computed = {};\n            self._propEffects = {};\n            self._activeEffect = null;\n        }\n        _initReactiveProps(expr, parent) {\n            if (!expr || !parent)\n                return;\n            this._propParent = parent;\n            let evalFn;\n            try {\n                evalFn = new Function('ctx', 'with(ctx){return (' + expr + ')}');\n            }\n            catch {\n                return;\n            }\n            const update = () => {\n                parent._activeEffect = update;\n                let obj;\n                try {\n                    const ctx = parent.getContext(true);\n                    obj = evalFn(ctx);\n                }\n                catch {\n                    obj = null;\n                }\n                parent._activeEffect = null;\n                if (obj && typeof obj === 'object') {\n                    this._data.$props = this._data.$props || {};\n                    this._propUpdateActive = true;\n                    for (const k in obj) {\n                        const v = obj[k];\n                        if (this._data[k] !== v)\n                            this._data[k] = v;\n                    }\n                    this._propUpdateActive = false;\n                }\n            };\n            this._propEffect = update;\n            update();\n        }\n        _runCleanupCallbacks() {\n            for (const fn of this._cleanupFunctions) {\n                _se(fn);\n            }\n            this._cleanupFunctions.clear();\n        }\n        _listen(element, event, handler, options) {\n            const signal = this._directiveAbort.signal;\n            if (typeof options === 'boolean') {\n                element.addEventListener(event, handler, { capture: options, signal });\n            }\n            else if (options) {\n                const merged = options.signal && options.signal !== signal\n                    ? options\n                    : { ...options, signal };\n                element.addEventListener(event, handler, merged);\n            }\n            else {\n                element.addEventListener(event, handler, { signal });\n            }\n        }\n        _targetKey(target) {\n            let id = this._targetIds.get(target);\n            if (!id) {\n                id = (++this._targetSeq).toString(36);\n                this._targetIds.set(target, id);\n            }\n            return id;\n        }\n        _parseDirectives(element) {\n            const self = this;\n            let processedElements = 0;\n            const processElement = (el, isRoot = false) => {\n                if (!isRoot && (el.hasAttribute(attrName('data')) || this._framework._getComponentByElement(el))) {\n                    return false;\n                }\n                const isComponentTag = el[STR_TAGNAME] === 'COMPONENT';\n                const { names: directiveNames, hasTextOrHtml, forName } = self._scanDirectiveAttrs(el);\n                if (directiveNames.length > 0) {\n                    processedElements++;\n                    if (forName) {\n                        self._bindDirective(el, forName, el.getAttribute(forName) || '');\n                        return false;\n                    }\n                    for (const attr of directiveNames) {\n                        self._bindDirective(el, attr, el.getAttribute(attr) || '');\n                    }\n                }\n                if (FT_TI && !hasTextOrHtml)\n                    self._bindTextInterpolationsIn(el);\n                return isRoot || !isComponentTag;\n            };\n            processElement(element, true);\n            self._walkElements(element, processElement);\n        }\n        _bindTextInterpolationsIn(el) {\n            const nodes = Array.from(el.childNodes);\n            for (const node of nodes) {\n                if (node.nodeType !== Node.TEXT_NODE)\n                    continue;\n                const textNode = node;\n                const raw = textNode.nodeValue || '';\n                if (textNode.__x_ti_bound || raw.indexOf('{{') === -1)\n                    continue;\n                const segs = [];\n                let i = 0;\n                while (i < raw.length) {\n                    const ch = raw.charCodeAt(i);\n                    if (ch === 92) {\n                        let run = 0;\n                        const start = i;\n                        while (i < raw.length && raw.charCodeAt(i) === 92) {\n                            run++;\n                            i++;\n                        }\n                        if (raw.startsWith('{{', i)) {\n                            const close = raw.indexOf('}}', i + 2);\n                            if (close === -1) {\n                                segs.push({ type: 'lit', text: raw.slice(start) });\n                                break;\n                            }\n                            if (run > 1)\n                                segs.push({ type: 'lit', text: '\\\\'.repeat(run - 1) });\n                            segs.push({ type: 'lit', text: raw.slice(i, close + 2) });\n                            i = close + 2;\n                            continue;\n                        }\n                        segs.push({ type: 'lit', text: raw.slice(start, i) });\n                        continue;\n                    }\n                    if (raw.startsWith('{{', i)) {\n                        const close = raw.indexOf('}}', i + 2);\n                        if (close === -1) {\n                            segs.push({ type: 'lit', text: raw.slice(i) });\n                            break;\n                        }\n                        const expr = raw.slice(i + 2, close).trim();\n                        if (expr.length === 0)\n                            segs.push({ type: 'lit', text: '{{}}' });\n                        else\n                            segs.push({ type: 'expr', code: expr });\n                        i = close + 2;\n                        continue;\n                    }\n                    const nextEsc = raw.indexOf('\\\\', i);\n                    const nextOpen = raw.indexOf('{{', i);\n                    let end = raw.length;\n                    if (nextEsc !== -1 && nextEsc < end)\n                        end = nextEsc;\n                    if (nextOpen !== -1 && nextOpen < end)\n                        end = nextOpen;\n                    segs.push({ type: 'lit', text: raw.slice(i, end) });\n                    i = end;\n                }\n                const hasExpr = segs.some(s => s.type === 'expr');\n                if (!hasExpr) {\n                    textNode.__x_ti_bound = true;\n                    const literalOut = segs.map(s => s.text || '').join('');\n                    if (textNode.textContent !== literalOut)\n                        textNode.textContent = literalOut;\n                    continue;\n                }\n                const evaluators = [];\n                for (const s of segs)\n                    if (s.type === 'expr')\n                        evaluators.push(this._createElementEvaluator(s.code, el));\n                textNode.__x_ti_bound = true;\n                const update = () => {\n                    let out = '';\n                    let ei = 0;\n                    for (const s of segs) {\n                        if (s.type === 'lit')\n                            out += s.text;\n                        else {\n                            const v = evaluators[ei++]();\n                            out += (v == null ? '' : String(v));\n                        }\n                    }\n                    if (textNode.textContent !== out)\n                        textNode.textContent = out;\n                };\n                const dirInfo = { type: 'text-interpolation', expression: raw, update: undefined };\n                this._addDirective(el, dirInfo);\n                const effect = this._createEffect(update, dirInfo);\n                dirInfo.update = effect;\n            }\n        }\n        _walkElements(parent, processor) {\n            let child = parent.firstElementChild;\n            while (child) {\n                const next = child.nextElementSibling;\n                if (processor(child))\n                    this._walkElements(child, processor);\n                child = next;\n            }\n        }\n        _bindDirective(element, directiveName, expression) {\n            const self = this;\n            const isAtEvent = directiveName.startsWith('@');\n            const isShortBind = directiveName.startsWith(PFX + ':');\n            const type = isAtEvent ? ('on:' + directiveName.slice(1)) : directiveName.slice(PFX.length + 1);\n            if (!isAtEvent && (isShortBind || type === 'class' || type === STR_STYLE)) {\n                element.removeAttribute(directiveName);\n                return self._bindAttributeDirective(element, type, expression);\n            }\n            if (!isAtEvent && (type === 'text' || type === 'html' || type === 'show')) {\n                element.removeAttribute(directiveName);\n                return self._bindSimpleDirective(element, expression, type);\n            }\n            const handled = (!isAtEvent && type === 'model') ? (element.removeAttribute(directiveName), self._bindModelDirective(element, expression), true)\n                : type === 'if' ? (element.removeAttribute(directiveName), self._bindIfDirective(element, expression), true)\n                    : type === 'for' ? (element.removeAttribute(directiveName), self._bindForDirective(element, expression), true)\n                        : false;\n            if (handled)\n                return;\n            if (isAtEvent || type.indexOf(':') > -1) {\n                const [prefix, rest] = type.split(':', 2);\n                const [suffix, ...mods] = rest.split('.');\n                const modifiers = mods.reduce((acc, m) => { if (m)\n                    acc[m] = true; return acc; }, {});\n                if (prefix === 'on') {\n                    element.removeAttribute(directiveName);\n                    const customDirective = self.framework._getCustomDirective(suffix);\n                    return customDirective\n                        ? self._bindCustomDirective(element, suffix, expression, customDirective, modifiers)\n                        : self._bindEventDirective(element, suffix, expression, modifiers);\n                }\n                if (prefix === 'intersect') {\n                    element.removeAttribute(directiveName);\n                    return self._bindIntersectDirective(element, expression, modifiers, suffix);\n                }\n                element.removeAttribute(directiveName);\n                return self._bindAttributeDirective(element, suffix, expression);\n            }\n        }\n        _bindIntersectDirective(element, expression, modifiers, phase) {\n            const self = this;\n            const trimmed = _tr(expression);\n            const runExpr = self._compileHandler(trimmed, element, (payload) => [payload, element]);\n            const run = (payload) => { if (runExpr)\n                runExpr(payload); };\n            const once = !!modifiers['once'];\n            let rootMargin = '0px';\n            for (const m in modifiers) {\n                if (m.startsWith('rootMargin-')) {\n                    rootMargin = m.slice('rootMargin-'.length);\n                    break;\n                }\n            }\n            const onEnter = phase === 'enter' ? { cb: (entry, info) => run({ entry, ...info }), once } : undefined;\n            const onLeave = phase === 'leave' ? { cb: (entry, info) => run({ entry, ...info }), once } : undefined;\n            const unobserve = this.framework._ioObserve(element, rootMargin, onEnter, onLeave);\n            const dir = { type: 'intersect', expression };\n            this._addDirective(element, dir);\n            this._addCleanupFunction(() => { try {\n                unobserve();\n            }\n            catch { } });\n        }\n        _createEffect(updateFn, directiveRef) {\n            const effect = () => {\n                this._activeEffect = effect;\n                try {\n                    updateFn();\n                }\n                finally {\n                    this._activeEffect = null;\n                }\n            };\n            effect();\n            this._allEffects.add(effect);\n            if (XTOOL_ENABLE_STATIC_DIRECTIVES && directiveRef && directiveRef._static === undefined) {\n                let found = false;\n                for (const deps of this._propertyDependencies.values()) {\n                    if (deps.includes(effect)) {\n                        found = true;\n                        break;\n                    }\n                }\n                directiveRef._static = !found;\n            }\n            return effect;\n        }\n        _bindSimpleDirective(element, expression, type) {\n            if (type === 'class' || type === STR_STYLE) {\n                return this._bindAttributeDirective(element, type, expression);\n            }\n            const evaluator = this._createElementEvaluator(expression, element);\n            let originalDisplay;\n            if (type === 'show') {\n                const el = element;\n                originalDisplay = el.style[STR_DISPLAY] !== STR_NONE ? el.style[STR_DISPLAY] : undefined;\n            }\n            let _prevShown = undefined;\n            const update = () => {\n                const value = evaluator();\n                const el = element;\n                switch (type) {\n                    case 'text':\n                        el.textContent = String(value);\n                        break;\n                    case 'html':\n                        el.innerHTML = String(value || '');\n                        break;\n                    case 'show':\n                        const next = !!value;\n                        if (_prevShown === next)\n                            return;\n                        _prevShown = next;\n                        el.style[STR_DISPLAY] = next ? (originalDisplay || '') : STR_NONE;\n                        break;\n                }\n            };\n            const dirInfo = { type, expression, update: undefined, originalDisplay };\n            this._addDirective(element, dirInfo);\n            const effect = this._createEffect(update, dirInfo);\n            dirInfo.update = effect;\n        }\n        _bindModelDirective(element, property) {\n            const isCheckbox = element.type === 'checkbox';\n            const isNumeric = element.type === 'number' || element.type === 'range';\n            const isMultiSelect = element.tagName === 'SELECT' && element.multiple === true;\n            if (!(property in this._data)) {\n                this._data[property] = undefined;\n            }\n            const getValueEvaluator = this._createElementEvaluator(property, element);\n            const setValueEvaluator = this._createEvaluator(`${property} = $value`, true);\n            const inferCheckboxValue = () => {\n                if (element.hasAttribute('value'))\n                    return element.value;\n                const loopScope = this._collectLoopScope(element);\n                if (loopScope) {\n                    const keys = Object.keys(loopScope);\n                    if (keys.length === 1)\n                        return loopScope[keys[0]];\n                }\n                return element.value;\n            };\n            const checkboxValue = isCheckbox ? inferCheckboxValue() : undefined;\n            const getInputValue = () => {\n                if (isCheckbox) {\n                    const currentData = getValueEvaluator();\n                    if (Array.isArray(currentData) && checkboxValue !== undefined) {\n                        return element.checked ? checkboxValue : undefined;\n                    }\n                    return element.hasAttribute('value') ? (element.checked ? element.value : undefined) : element.checked;\n                }\n                if (isMultiSelect) {\n                    const sel = element;\n                    const values = [];\n                    const opts = sel.options;\n                    for (let i = 0; i < opts.length; i++) {\n                        if (opts[i].selected)\n                            values.push(opts[i].value);\n                    }\n                    return values;\n                }\n                return isNumeric ? parseFloat(element.value) || 0 : element.value;\n            };\n            const setInputValue = (value) => {\n                if (isCheckbox) {\n                    if (Array.isArray(value)) {\n                        const member = element.hasAttribute('value') ? element.value : checkboxValue;\n                        element.checked = member != null ? value.includes(member) : false;\n                    }\n                    else {\n                        element.checked = !!value;\n                    }\n                    return;\n                }\n                if (isMultiSelect) {\n                    const sel = element;\n                    const arr = Array.isArray(value) ? value : [];\n                    const opts = sel.options;\n                    for (let i = 0; i < opts.length; i++) {\n                        opts[i].selected = arr.includes(opts[i].value);\n                    }\n                    return;\n                }\n                element.value = String(value ?? (isNumeric ? 0 : ''));\n            };\n            this._createEffect(() => setInputValue(getValueEvaluator()));\n            const ctx = this._createContextProxy(undefined, element);\n            const updateData = () => {\n                const raw = getInputValue();\n                const currentVal = this._safeExecute(() => getValueEvaluator());\n                if (isCheckbox && Array.isArray(currentVal)) {\n                    const member = element.hasAttribute('value') ? element.value : checkboxValue;\n                    if (member !== undefined) {\n                        const idx = currentVal.indexOf(member);\n                        if (element.checked) {\n                            if (idx === -1)\n                                currentVal.push(member);\n                        }\n                        else if (idx > -1) {\n                            currentVal.splice(idx, 1);\n                        }\n                    }\n                }\n                else if (isMultiSelect && Array.isArray(currentVal)) {\n                    currentVal.splice(0, currentVal.length, ...raw);\n                }\n                else {\n                    ctx.$value = raw;\n                    this._safeExecute(() => { setValueEvaluator.call(this._createMethodContext(), ctx); });\n                }\n            };\n            const t = element.type;\n            const eventType = (element[STR_TAGNAME] === 'SELECT' || t === 'checkbox' || t === 'radio' || t === 'file') ? 'change' : 'input';\n            this._listen(element, eventType, updateData);\n            this._addDirective(element, { type: 'model', property });\n        }\n        _bindIfDirective(element, expression) {\n            const self = this;\n            const placeholder = d.createComment('x-if');\n            element.parentNode?.insertBefore(placeholder, element);\n            element.__x_if_anchorParent = placeholder.parentElement || null;\n            const branches = [];\n            const makeActualElement = (el) => {\n                if (el[STR_TAGNAME] === STR_TEMPLATE) {\n                    const wrapper = d.createElement('div');\n                    wrapper.style[STR_DISPLAY] = STR_CONTENTS;\n                    wrapper.appendChild(el.content.cloneNode(true));\n                    return { el: wrapper, isTemplate: true };\n                }\n                return { el: el, isTemplate: false };\n            };\n            const first = makeActualElement(element);\n            const firstEval = self._createElementEvaluator(expression, element);\n            branches.push({ el: first.el, test: firstEval, isTemplate: first.isTemplate });\n            if (!first.isTemplate)\n                first.el.__x_tool_bound = true;\n            const originalNodes = [element];\n            if (FT_IFB) {\n                let sib = element.nextElementSibling;\n                while (sib) {\n                    const isElse = sib.hasAttribute(attrName('else'));\n                    const isElseIf = sib.hasAttribute(attrName('else-if'));\n                    if (!isElse && !isElseIf)\n                        break;\n                    if (sib.hasAttribute(attrName('else-if'))) {\n                        const attr = sib.getAttribute(attrName('else-if')) || '';\n                        const branch = makeActualElement(sib);\n                        const evalFn = self._createElementEvaluator(_tr(attr), sib);\n                        branches.push({ el: branch.el, test: evalFn, isTemplate: branch.isTemplate });\n                        if (!branch.isTemplate)\n                            branch.el.__x_tool_bound = true;\n                    }\n                    else {\n                        const branch = makeActualElement(sib);\n                        branches.push({ el: branch.el, test: null, isTemplate: branch.isTemplate });\n                        if (!branch.isTemplate)\n                            branch.el.__x_tool_bound = true;\n                    }\n                    sib.removeAttribute(attrName('else'));\n                    sib.removeAttribute(attrName('else-if'));\n                    originalNodes.push(sib);\n                    sib = sib.nextElementSibling;\n                }\n            }\n            let active = -1;\n            for (const orig of originalNodes) {\n                if (orig.parentNode)\n                    orig.parentNode.removeChild(orig);\n            }\n            const mountBranch = (idx) => {\n                if (idx < 0)\n                    return;\n                const b = branches[idx];\n                if (!b.el.__x_tool_bound) {\n                    self._parseDirectives(b.el);\n                    b.el.__x_tool_bound = true;\n                }\n                element.__x_if_current?.parentNode?.removeChild(element.__x_if_current);\n                if (!b.el.parentNode) {\n                    placeholder.parentNode?.insertBefore(b.el, placeholder.nextSibling);\n                }\n                element.__x_if_current = b.el;\n                active = idx;\n            };\n            const unmountBranch = (idx, cb) => {\n                if (idx < 0) {\n                    if (cb)\n                        cb();\n                    return;\n                }\n                const b = branches[idx];\n                if (b.el.parentNode) {\n                    if (b.el.parentNode)\n                        b.el.parentNode.removeChild(b.el);\n                    if (cb)\n                        cb();\n                }\n                else if (cb)\n                    cb();\n                active = -1;\n            };\n            const update = () => {\n                let next = -1;\n                for (let i = 0; i < branches[STR_LENGTH]; i++) {\n                    const b = branches[i];\n                    const pass = b.test ? !!b.test() : true;\n                    if (pass) {\n                        next = i;\n                        break;\n                    }\n                }\n                if (next === active)\n                    return;\n                if (active !== -1) {\n                    unmountBranch(active, () => mountBranch(next));\n                }\n                else {\n                    mountBranch(next);\n                }\n            };\n            const effect = self._createEffect(update);\n            self._addDirective(element, { type: 'if', expression, update: effect });\n        }\n        _bindEventDirective(element, eventName, expression, modifiers) {\n            const self = this;\n            const trimmed = _tr(expression);\n            const opts = modifiers ? {\n                once: !!modifiers.once,\n                passive: !!modifiers.passive,\n                capture: !!modifiers.capture,\n            } : undefined;\n            const onlySelf = !!modifiers?.self;\n            const shouldPrevent = !!modifiers?.prevent;\n            const shouldStop = !!modifiers?.stop;\n            const isOutside = !!modifiers?.outside;\n            const deferExec = !!modifiers?.defer;\n            const keyAliasMap = { enter: ['enter'], esc: ['escape', 'esc'], escape: ['escape', 'esc'], space: [' ', 'space', 'spacebar'], tab: ['tab'], backspace: ['backspace'], delete: ['delete', 'del'], del: ['delete', 'del'], arrowup: ['arrowup', 'up'], arrowdown: ['arrowdown', 'down'], arrowleft: ['arrowleft', 'left'], arrowright: ['arrowright', 'right'], home: ['home'], end: ['end'], pageup: ['pageup'], pagedown: ['pagedown'] };\n            const comboRequirements = {\n                ctrl: !!modifiers?.ctrl,\n                alt: !!modifiers?.alt,\n                shift: !!modifiers?.shift,\n                meta: !!modifiers?.meta,\n            };\n            const buttonMap = { left: 0, middle: 1, right: 2 };\n            const touchSingle = !!modifiers?.single;\n            const touchMulti = !!modifiers?.multi;\n            const modifierKeys = modifiers ? _Okeys(modifiers) : [];\n            const allowedKeys = [];\n            for (const m of modifierKeys) {\n                const aliases = keyAliasMap[m.toLowerCase()];\n                if (aliases)\n                    allowedKeys.push(...aliases);\n            }\n            const allowedButtons = [];\n            for (const m of modifierKeys) {\n                const btn = buttonMap[m.toLowerCase()];\n                if (btn !== undefined)\n                    allowedButtons.push(btn);\n            }\n            const needKeyCheck = allowedKeys.length > 0 || comboRequirements.ctrl || comboRequirements.alt || comboRequirements.shift || comboRequirements.meta;\n            const needButtonCheck = allowedButtons.length > 0;\n            const needTouchCheck = touchSingle || touchMulti;\n            const passesFilters = (event) => {\n                const path = event.composedPath ? event.composedPath() : null;\n                const tgt = (path && path.length ? path[0] : event.target);\n                if (isOutside) {\n                    if (!tgt)\n                        return false;\n                    if (element instanceof Node && (element === tgt || element.contains(tgt)))\n                        return false;\n                }\n                if (onlySelf && event.target !== element)\n                    return false;\n                if (needTouchCheck) {\n                    if (event instanceof TouchEvent) {\n                        const tCount = event.touches.length;\n                        if (touchSingle && tCount !== 1)\n                            return false;\n                        if (touchMulti && tCount < 2)\n                            return false;\n                    }\n                    else\n                        return false;\n                }\n                if (needButtonCheck) {\n                    if (event instanceof MouseEvent) {\n                        if (!allowedButtons.includes(event.button))\n                            return false;\n                    }\n                    else\n                        return false;\n                }\n                if (needKeyCheck) {\n                    if (!(event instanceof KeyboardEvent))\n                        return false;\n                    const k = (event.key || '').toLowerCase();\n                    if (allowedKeys.length > 0 && !allowedKeys.includes(k))\n                        return false;\n                    const { ctrlKey, altKey, shiftKey, metaKey } = event;\n                    if ((comboRequirements.ctrl && !ctrlKey) || (comboRequirements.alt && !altKey) ||\n                        (comboRequirements.shift && !shiftKey) || (comboRequirements.meta && !metaKey))\n                        return false;\n                }\n                return true;\n            };\n            const runExpr = self._compileHandler(trimmed, element, (ev) => [ev, element]);\n            const createEventHandler = (event) => {\n                if (!passesFilters(event))\n                    return;\n                if (shouldPrevent)\n                    event.preventDefault();\n                if (shouldStop)\n                    event.stopPropagation();\n                if (!runExpr)\n                    return;\n                if (deferExec && typeof quMct === 'function') {\n                    const ev = event;\n                    quMct(() => self._safeExecute(() => runExpr(ev)));\n                    return;\n                }\n                self._safeExecute(() => runExpr(event));\n            };\n            const cfg = this.framework._getConfig();\n            const canDelegate = !!cfg.delegate && EV_DELEGATED.includes(eventName);\n            if (!isOutside && canDelegate) {\n                const remover = this.framework._registerDelegated(element, eventName, { filter: (e) => passesFilters(e), run: (e) => createEventHandler(e), once: !!modifiers?.once, comp: this });\n                this._addCleanupFunction(remover);\n            }\n            else {\n                const target = isOutside ? (element?.ownerDocument || d || document) : element;\n                self._listen(target, eventName, createEventHandler, opts);\n            }\n        }\n        _createEvaluator(expression, isStatement = false) {\n            const key = `${isStatement ? 's' : 'r'}:${expression}`;\n            let fn = this._expressionCache.get(key);\n            if (!fn) {\n                fn = new Function('ctx', `with(ctx){${isStatement ? expression : `return (${expression})`}}`);\n                this._expressionCache.set(key, fn);\n            }\n            return fn;\n        }\n        _createElementEvaluator(expression, element) {\n            const self = this;\n            const compiled = self._createEvaluator(expression);\n            return () => this._safeExecute(() => compiled.call(self._createMethodContext(), self._createContextProxy(undefined, element)));\n        }\n        _extractArrowFunction(expression) {\n            let m = expression.match(/^\\s*\\(\\s*([^)]*?)\\s*\\)\\s*=>\\s*([\\s\\S]+)$/);\n            if (!m)\n                m = expression.match(/^\\s*([a-zA-Z_$][a-zA-Z0-9_$]*)\\s*=>\\s*([\\s\\S]+)$/);\n            if (!m)\n                return null;\n            const params = (m[1] || '')\n                .split(',')\n                .map(p => p.trim())\n                .filter(Boolean);\n            const body = _tr(m[2]);\n            const isBlock = body.startsWith('{') && body.endsWith('}');\n            const finalBody = isBlock ? body.slice(1, -1) : body;\n            return { paramsList: params, body: finalBody, isBlock };\n        }\n        _compileArrowForEvent(params, body, isBlock) {\n            const content = isBlock ? body : 'return ( ' + body + ' );';\n            return new Function('ctx', ...params, 'with(ctx){ ' + content + ' }');\n        }\n        _compileHandler(expression, element, mapArgs) {\n            const self = this;\n            const trimmed = _tr(expression);\n            if (!trimmed)\n                return null;\n            const arrow = self._extractArrowFunction(trimmed);\n            const thisCtx = self._createMethodContext();\n            if (arrow) {\n                const { paramsList, body, isBlock } = arrow;\n                const compiledArrow = self._compileArrowForEvent(paramsList, body, isBlock);\n                return (payload) => {\n                    const ctx = self._createContextProxy(payload, element);\n                    const args = mapArgs(payload);\n                    self._safeExecute(() => compiledArrow.call(thisCtx, ctx, ...args.slice(0, paramsList.length)));\n                };\n            }\n            const isStatement = trimmed.includes(';');\n            const executor = self._createEvaluator(trimmed, isStatement);\n            return (payload) => {\n                const ctx = self._createContextProxy(payload, element);\n                const result = executor.call(thisCtx, ctx);\n                if (typeof result === 'function') {\n                    try {\n                        result.call(thisCtx, payload);\n                    }\n                    catch { }\n                }\n            };\n        }\n        _assertMutable(parentKey, method) {\n            if (this._isInComputedEvaluation) {\n                throw new Error(`[x-tool] Mutation via '${String(parentKey)}.${method}()' is not allowed during computed evaluation.`);\n            }\n            if (this._isFrozen) {\n                throw new Error(`[x-tool] Mutation via '${String(parentKey)}.${method}()' is not allowed while component is frozen.`);\n            }\n        }\n        _wrapData(data, parentKey) {\n            const isArr = ARRAY_ISARRAY(data);\n            const isSet = (typeof Set !== 'undefined') && (data instanceof Set);\n            const isMap = (typeof Map !== 'undefined') && (data instanceof Map);\n            if (!(Object.getPrototypeOf(data) === Object.prototype || isArr || isSet || isMap))\n                return data;\n            const self = this;\n            if (!this._deepReactiveCache)\n                this._deepReactiveCache = new WkMap();\n            if (this._deepReactiveCache.has(data))\n                return this._deepReactiveCache.get(data);\n            const makeCollectionWrapper = (name, fn, isArray) => function (...args) {\n                self._assertMutable(parentKey, name);\n                if (isArray) {\n                    const arr = this;\n                    const beforeLen = arr.length;\n                    const beforeFirst = arr[0];\n                    const beforeLast = arr[beforeLen - 1];\n                    const result = fn.apply(this, args);\n                    if (!self._isSealed && (arr.length !== beforeLen || arr[0] !== beforeFirst || arr[arr.length - 1] !== beforeLast)) {\n                        self._onDataChange(parentKey);\n                    }\n                    return result;\n                }\n                else {\n                    const before = this.size;\n                    const existed = (name === 'set') ? this.has(args[0]) : false;\n                    const result = fn.apply(this, args);\n                    if (!self._isSealed && (this.size !== before || (name === 'set' && !existed)))\n                        self._onDataChange(parentKey);\n                    return result;\n                }\n            };\n            const proxy = new Proxy(data, {\n                get: (target, p, receiver) => {\n                    const isCollection = isSet || isMap;\n                    if (isArr) {\n                        if (p === Symbol.iterator || p === 'length' || (typeof p === 'string' && /^\\d+$/.test(p))) {\n                            self._trackDependency(parentKey);\n                            if (p === Symbol.iterator)\n                                return Reflect.get(target, p, receiver);\n                        }\n                    }\n                    else if (isCollection) {\n                        if (p === 'size' || p === Symbol.iterator || p === 'keys' || p === 'values' || p === 'entries') {\n                            self._trackDependency(parentKey);\n                        }\n                    }\n                    else {\n                        self._trackDependency(parentKey);\n                    }\n                    const value = Reflect.get(target, p, receiver);\n                    if (isCollection && typeof value === 'function' && (p === Symbol.iterator || p === 'keys' || p === 'values' || p === 'entries')) {\n                        return function (...args) { return value.apply(target, args); };\n                    }\n                    if (typeof value === 'function') {\n                        if (isArr && ['push', 'pop', 'shift', 'unshift', 'splice', 'reverse', 'copyWithin', 'fill', 'sort'].includes(p)) {\n                            return makeCollectionWrapper(String(p), value, true).bind(target);\n                        }\n                        if (isSet && (p === 'add' || p === 'delete' || p === 'clear')) {\n                            return makeCollectionWrapper(String(p), value, false).bind(target);\n                        }\n                        if (isMap && (p === 'set' || p === 'delete' || p === 'clear')) {\n                            return makeCollectionWrapper(String(p), value, false).bind(target);\n                        }\n                    }\n                    return (value && typeof value === 'object') ? self._wrapData(value, parentKey) : value;\n                },\n                ownKeys: Reflect.ownKeys,\n                has: Reflect.has,\n                set: (target, p, value) => {\n                    if (self._isDestroyed || typeof p === 'symbol')\n                        return true;\n                    const key = String(parentKey) + '.' + String(p);\n                    if (self._isInComputedEvaluation)\n                        throw new Error(`[x-tool] Mutation of '${key}' is not allowed during computed evaluation.`);\n                    if (self._isFrozen)\n                        throw new Error(`[x-tool] Mutation of '${key}' is not allowed while component is frozen.`);\n                    const had = Reflect.has(target, p);\n                    const oldValue = had ? Reflect.get(target, p) : undefined;\n                    if (value && typeof value === 'object') {\n                        value = self._wrapData(value, (String(parentKey) + '.' + String(p)));\n                    }\n                    if (!had) {\n                        _se(() => Reflect.defineProperty(target, p, { configurable: true, enumerable: true, writable: true, value }));\n                        if (!Reflect.has(target, p))\n                            Reflect.set(target, p, value);\n                        self._onDataChange(parentKey);\n                        return true;\n                    }\n                    if (oldValue === value)\n                        return true;\n                    Reflect.set(target, p, value);\n                    if (!self._isSealed)\n                        self._onDataChange(parentKey);\n                    return true;\n                },\n                deleteProperty: (target, p) => {\n                    const key = String(parentKey) + (typeof p === 'symbol' ? '' : '.' + String(p));\n                    if (self._isInComputedEvaluation)\n                        throw new Error(`[x-tool] Deletion of '${key}' is not allowed during computed evaluation.`);\n                    if (self._isFrozen)\n                        throw new Error(`[x-tool] Deletion of '${key}' is not allowed while component is frozen.`);\n                    const ok = Reflect.deleteProperty(target, p);\n                    if (ok && !self._isSealed)\n                        self._onDataChange(parentKey);\n                    return ok;\n                }\n            });\n            this._deepReactiveCache.set(data, proxy);\n            return proxy;\n        }\n        _createReactiveData(data) {\n            const self = this;\n            return new Proxy(data, {\n                get: (target, property, receiver) => {\n                    const value = Reflect.get(target, property, receiver);\n                    if (property === Symbol.iterator)\n                        return value;\n                    if (typeof property !== 'symbol') {\n                        self._trackDependency(property);\n                    }\n                    if (value && typeof value === 'object') {\n                        return self._wrapData(value, property);\n                    }\n                    return value;\n                },\n                ownKeys: (target) => Reflect.ownKeys(target),\n                has: (target, key) => Reflect.has(target, key),\n                set: (target, property, value, receiver) => {\n                    if (self._isDestroyed)\n                        return true;\n                    if (self._isFrozen)\n                        return true;\n                    if (self._isInComputedEvaluation) {\n                        throw new Error(`[x-tool] Mutation of '${String(property)}' is not allowed during computed evaluation.`);\n                    }\n                    if (property === Symbol.iterator && ARRAY_ISARRAY(target))\n                        return value;\n                    const oldValue = Reflect.get(target, property);\n                    const had = Reflect.has(target, property);\n                    if (!had) {\n                        try {\n                            Reflect.defineProperty(target, property, {\n                                configurable: true,\n                                enumerable: true,\n                                writable: true,\n                                value\n                            });\n                        }\n                        catch {\n                            Reflect.set(target, property, value, receiver);\n                        }\n                    }\n                    else {\n                        Reflect.set(target, property, value, receiver);\n                    }\n                    if (!this._isSealed)\n                        this._onDataChange(property);\n                    if (this._propUpdateActive && property !== '$props') {\n                        const pc = target.$props;\n                        if (pc)\n                            pc[property] = value;\n                        const eff = this._propEffects[property];\n                        if (eff && !this._isSealed) {\n                            eff(value, oldValue);\n                        }\n                    }\n                    return true;\n                }\n            });\n        }\n        _createMethodContext(_includeComputed = true) {\n            const specials = {\n                '$log': (..._args) => { },\n                '$destroy': () => this.destroy(),\n                '$forceUpdate': () => this._scheduleRender(),\n                '$addCleanupFunction': (fn) => this._addCleanupFunction(fn),\n                '$nextTick': (cb) => {\n                    if (cb) {\n                        this._nextTickQueue.push(cb);\n                        if (!this._renderScheduled)\n                            quMct(() => {\n                                if (!this._renderScheduled && this._nextTickQueue.length) {\n                                    const q = this._nextTickQueue.splice(0, this._nextTickQueue.length);\n                                    for (const fn of q) {\n                                        this._safeExecute(() => fn());\n                                    }\n                                }\n                            });\n                        return;\n                    }\n                    return new Promise(resolve => {\n                        this._nextTickQueue.push(() => resolve());\n                        if (!this._renderScheduled)\n                            quMct(() => {\n                                if (!this._renderScheduled && this._nextTickQueue.length) {\n                                    const q = this._nextTickQueue.splice(0, this._nextTickQueue.length);\n                                    for (const fn of q) {\n                                        this._safeExecute(() => fn());\n                                    }\n                                }\n                            });\n                    });\n                },\n                '$el': this._element,\n                '$id': this._id,\n                '$isMounted': this._isMounted,\n                '$isDestroyed': this._isDestroyed,\n                '$isSealed': this._isSealed,\n                '$isFrozen': this._isFrozen,\n                '$parent': this._parent,\n                '$children': this._children,\n                '$seal': (on = true) => { this._setSealed(!!on); },\n                '$mutate': (fn) => {\n                    const prevMethod = this._isInMethodExecution;\n                    this._isMutationEnabled = false;\n                    if (this._isInComputedEvaluation) {\n                        throw new Error('[x-tool] $mutate cannot be used inside computed evaluation; computed getters must be pure.');\n                    }\n                    this._isInMethodExecution = false;\n                    try {\n                        return typeof fn === 'function' ? fn() : undefined;\n                    }\n                    finally {\n                        this._isInMethodExecution = prevMethod;\n                        this._isMutationEnabled = true;\n                        this._scheduleRender();\n                    }\n                }\n            };\n            let data = this._data;\n            if (this._isInComputedEvaluation) {\n                data = (this._rawData);\n            }\n            return new Proxy(data, {\n                get: (target, propStr) => {\n                    if (propStr in target) {\n                        this._trackDependency(propStr);\n                        const v = target[propStr];\n                        return v;\n                    }\n                    if (FT_C && (propStr in this._computed)) {\n                        return this._getComputedValue(propStr);\n                    }\n                    if (propStr in specials)\n                        return specials[propStr];\n                    return this._methods[propStr];\n                },\n                set: (_target, propStr, value) => {\n                    if (this._isInComputedEvaluation) {\n                        throw new Error(`[x-tool] Mutation of '${String(propStr)}' is not allowed during computed evaluation.`);\n                    }\n                    if (this._isFrozen) {\n                        throw new Error(`[x-tool] Mutation of '${String(propStr)}' is not allowed while component is frozen.`);\n                    }\n                    this._data[propStr] = value;\n                    return true;\n                }\n            });\n        }\n        _createContextProxy(event, targetElement) {\n            const component = this;\n            const mergedScope = targetElement ? this._collectLoopScope(targetElement) : null;\n            const gWindow = (typeof window !== 'undefined' ? window : undefined);\n            const gDocument = (typeof document !== 'undefined' ? document : undefined);\n            const cfg = this.framework._getConfig();\n            const sandbox = !!cfg.sandboxExpressions;\n            const allow = new Set((cfg.allowGlobals || []).map(s => String(s)));\n            const ensureInvoker = () => this._currentInvoker || '__anonymous__';\n            const registerResource = (kind, setup) => {\n                const inv = ensureInvoker();\n                let byKind = this._invokerResources.get(inv);\n                if (!byKind) {\n                    byKind = new Map();\n                    this._invokerResources.set(inv, byKind);\n                }\n                const prev = byKind.get(kind);\n                if (prev) {\n                    try {\n                        prev();\n                    }\n                    catch { }\n                    byKind.delete(kind);\n                }\n                const cleanup = setup();\n                if (typeof cleanup === 'function') {\n                    const wrapped = () => {\n                        try {\n                            cleanup();\n                        }\n                        finally {\n                            byKind?.delete(kind);\n                        }\n                    };\n                    byKind.set(kind, wrapped);\n                    this._addCleanupFunction(wrapped);\n                }\n            };\n            const wrapTarget = (target) => {\n                if (!target || typeof target.addEventListener !== 'function')\n                    return target;\n                return new Proxy(target, {\n                    get: (obj, prop) => {\n                        if (prop === 'addEventListener') {\n                            return (eventName, handler, options) => {\n                                if (this._isSealed || this._isFrozen)\n                                    return;\n                                obj.addEventListener(eventName, handler, options);\n                                const optSig = typeof options === 'boolean' ? options : options?.capture ? '1' : '0';\n                                const key = 'listener:' + this._targetKey(obj) + ':' + eventName + ':' + optSig;\n                                registerResource(key, () => () => {\n                                    try {\n                                        obj.removeEventListener(eventName, handler, options);\n                                    }\n                                    catch { }\n                                });\n                            };\n                        }\n                        if (prop === 'removeEventListener') {\n                            return (eventName, handler, options) => {\n                                try {\n                                    obj.removeEventListener(eventName, handler, options);\n                                }\n                                catch { }\n                            };\n                        }\n                        if (prop === 'querySelector') {\n                            return (sel) => wrapTarget(obj.querySelector(sel));\n                        }\n                        if (prop === 'querySelectorAll') {\n                            return (sel) => Array.from(obj.querySelectorAll(sel)).map(wrapTarget);\n                        }\n                        if (prop === 'getElementById') {\n                            return (id) => wrapTarget(obj.getElementById(id));\n                        }\n                        if (prop === 'document') {\n                            const doc = obj.document;\n                            return wrapTarget(doc) || doc;\n                        }\n                        if (prop === 'defaultView') {\n                            const win = obj.defaultView;\n                            return wrapTarget(win) || win;\n                        }\n                        if (prop === 'body') {\n                            const body = obj.body;\n                            return wrapTarget(body) || body;\n                        }\n                        const value = obj[prop];\n                        if (typeof value === 'function') {\n                            try {\n                                return value.bind(obj);\n                            }\n                            catch {\n                                return value;\n                            }\n                        }\n                        return value;\n                    }\n                });\n            };\n            const ctxSetTimeout = (fn, ms, ...args) => {\n                if (this._isSealed || this._isFrozen || this._isDestroyed)\n                    return undefined;\n                const id = gWindow?.setTimeout?.(fn, ms, ...args);\n                if (id != null)\n                    registerResource('timeout', () => () => { try {\n                        gWindow?.clearTimeout?.(id);\n                    }\n                    catch { } });\n                return id;\n            };\n            const ctxSetInterval = (fn, ms, ...args) => {\n                if (this._isSealed || this._isFrozen)\n                    return undefined;\n                const id = gWindow?.setInterval?.(fn, ms, ...args);\n                if (id != null)\n                    registerResource('interval', () => () => { try {\n                        gWindow?.clearInterval?.(id);\n                    }\n                    catch { } });\n                return id;\n            };\n            const ctxRequestAnimationFrame = (cb) => {\n                if (this._isSealed || this._isFrozen)\n                    return undefined;\n                const id = gWindow?.requestAnimationFrame?.(cb);\n                if (id != null)\n                    registerResource('raf', () => () => { try {\n                        gWindow?.cancelAnimationFrame?.(id);\n                    }\n                    catch { } });\n                return id;\n            };\n            const wrapObserverCtor = (Orig, kind) => {\n                if (!Orig)\n                    return undefined;\n                return function (...observerArgs) {\n                    if (component._isSealed || component._isFrozen)\n                        return { observe() { }, disconnect() { }, unobserve() { } };\n                    const inst = new Orig(...observerArgs);\n                    registerResource('observer:' + kind, () => () => { try {\n                        inst.disconnect();\n                    }\n                    catch { } });\n                    return inst;\n                };\n            };\n            const specials = {\n                '$target': targetElement || null,\n                '$event': event || null,\n                ...(this.framework._routerEnabled() ? {\n                    'location': new Proxy(gWindow?.location || location, {\n                        get: (t, p) => t[p],\n                        set: (_t, p, v) => {\n                            const key = String(p);\n                            if (key === 'href') {\n                                try {\n                                    this.framework._navigate(String(v), true, 'program');\n                                }\n                                catch {\n                                    location.href = String(v);\n                                }\n                                return true;\n                            }\n                            try {\n                                location[p] = v;\n                            }\n                            catch { }\n                            return true;\n                        }\n                    })\n                } : {}),\n                ...(sandbox && !allow.has('setTimeout') ? {} : { 'setTimeout': ctxSetTimeout }),\n                ...(sandbox && !allow.has('clearTimeout') ? {} : { 'clearTimeout': (id) => { try {\n                        gWindow?.clearTimeout?.(id);\n                    }\n                    catch { } } }),\n                ...(sandbox && !allow.has('setInterval') ? {} : { 'setInterval': ctxSetInterval }),\n                ...(sandbox && !allow.has('clearInterval') ? {} : { 'clearInterval': (id) => { try {\n                        gWindow?.clearInterval?.(id);\n                    }\n                    catch { } } }),\n                ...(sandbox && !allow.has('requestAnimationFrame') ? {} : { 'requestAnimationFrame': ctxRequestAnimationFrame }),\n                ...(sandbox && !allow.has('cancelAnimationFrame') ? {} : { 'cancelAnimationFrame': (id) => { try {\n                        gWindow?.cancelAnimationFrame?.(id);\n                    }\n                    catch { } } }),\n                ...(sandbox && !allow.has('MutationObserver') ? {} : { 'MutationObserver': wrapObserverCtor(gWindow?.MutationObserver, 'mutation') }),\n                ...(sandbox && !allow.has('ResizeObserver') ? {} : { 'ResizeObserver': wrapObserverCtor(gWindow?.ResizeObserver, 'resize') }),\n                ...(sandbox && !allow.has('IntersectionObserver') ? {} : { 'IntersectionObserver': wrapObserverCtor(gWindow?.IntersectionObserver, 'intersection') }),\n                ...(sandbox && !allow.has('window') ? {} : { 'window': wrapTarget(gWindow) }),\n                ...(sandbox && !allow.has('document') ? {} : { 'document': wrapTarget(gDocument) })\n            };\n            return new Proxy({}, {\n                get: (_t, propStr) => {\n                    if (mergedScope && propStr in mergedScope)\n                        return mergedScope[propStr];\n                    if (propStr in component._data)\n                        return component._data[propStr];\n                    if (propStr in component._computed)\n                        return component._getComputedValue(propStr);\n                    if (propStr in component._methods)\n                        return component._methods[propStr];\n                    if (propStr in specials)\n                        return specials[propStr];\n                    return undefined;\n                },\n                set: (_t, propStr, value) => {\n                    if (mergedScope) {\n                        let s = mergedScope;\n                        while (s) {\n                            if (Object.prototype.hasOwnProperty.call(s, propStr)) {\n                                s[propStr] = value;\n                                return true;\n                            }\n                            s = Object.getPrototypeOf(s);\n                        }\n                    }\n                    component._data[propStr] = value;\n                    return true;\n                },\n                has: (_t, propStr) => !!(mergedScope && propStr in mergedScope) ||\n                    propStr in component._data ||\n                    propStr in component._computed ||\n                    propStr in component._methods ||\n                    propStr in specials\n            });\n        }\n        _bindCustomDirective(element, _name, expression, directive, modifiers) {\n            const self = this;\n            const evaluator = self._createElementEvaluator(expression, element);\n            const directiveInfo = { type: 'custom', expression, customDirective: directive };\n            if (directive.bind) {\n                self._safeExecute(() => directive.bind(element, evaluator(), expression, self, modifiers, evaluator));\n            }\n            const update = () => {\n                if (directive.update)\n                    self._safeExecute(() => directive.update(element, evaluator(), expression, self, modifiers, evaluator));\n            };\n            const effect = self._createEffect(update);\n            directiveInfo.update = effect;\n            self._addDirective(element, directiveInfo);\n        }\n        _bindAttributeDirective(element, attributeName, expression) {\n            const self = this;\n            const evaluator = self._createElementEvaluator(expression, element);\n            const isSvg = element.namespaceURI === 'http://www.w3.org/2000/svg';\n            if (attributeName === 'class') {\n                const el = element;\n                if (!self._initialClassSets.get(el)) {\n                    const baseSet = new Set();\n                    const oc = isSvg ? (element.getAttribute('class') || '') : (element.className || '');\n                    if (oc)\n                        for (const cls of oc.split(/\\s+/)) {\n                            if (cls)\n                                baseSet.add(cls);\n                        }\n                    self._initialClassSets.set(el, baseSet);\n                }\n            }\n            const meta = self._resolveBindingMeta(element, attributeName);\n            const update = () => {\n                const value = evaluator();\n                if (attributeName === 'class') {\n                    const base = self._initialClassSets.get(element);\n                    if (typeof value === 'string') {\n                        const finalCls = base && base.size ? [...base].join(' ') + (value ? ' ' + value : '') : value || '';\n                        if (isSvg) {\n                            if (finalCls)\n                                element.setAttribute('class', finalCls);\n                            else\n                                element.removeAttribute('class');\n                        }\n                        else {\n                            element.className = finalCls;\n                        }\n                    }\n                    else if (ARRAY_ISARRAY(value)) {\n                        const tokens = value.filter(Boolean);\n                        const finalList = base && base.size ? [...base, ...tokens] : tokens;\n                        const finalStr = finalList.join(' ');\n                        if (isSvg) {\n                            if (finalStr)\n                                element.setAttribute('class', finalStr);\n                            else\n                                element.removeAttribute('class');\n                        }\n                        else {\n                            element.className = finalStr;\n                        }\n                    }\n                    else if (value && typeof value === 'object') {\n                        if (base && base.size) {\n                            const baseStr = [...base].join(' ');\n                            if (isSvg) {\n                                if (baseStr)\n                                    element.setAttribute('class', baseStr);\n                                else\n                                    element.removeAttribute('class');\n                            }\n                            else {\n                                element.className = baseStr;\n                            }\n                        }\n                        const elAny = element;\n                        for (const raw in value) {\n                            const on = !!value[raw];\n                            if (!raw)\n                                continue;\n                            const tokens = raw.split(/\\s+/);\n                            for (let i = 0; i < tokens.length; i++) {\n                                const tk = tokens[i];\n                                if (!tk)\n                                    continue;\n                                elAny.classList?.toggle(tk, on);\n                            }\n                        }\n                    }\n                    else if (value == null && base && base.size) {\n                        const baseStr = [...base].join(' ');\n                        if (isSvg) {\n                            if (baseStr)\n                                element.setAttribute('class', baseStr);\n                            else\n                                element.removeAttribute('class');\n                        }\n                        else {\n                            element.className = baseStr;\n                        }\n                    }\n                    else if (value == null) {\n                        element.removeAttribute('class');\n                    }\n                    return;\n                }\n                if (attributeName === STR_STYLE) {\n                    const el = element;\n                    if (typeof value === 'string') {\n                        el.style.cssText = value;\n                        return;\n                    }\n                    if (value && typeof value === 'object') {\n                        for (const k in value) {\n                            const v = value[k];\n                            const cssProp = k.startsWith('--') ? k : k.replace(/[A-Z]/g, m => '-' + m.toLowerCase());\n                            if (v != null)\n                                el.style.setProperty(cssProp, String(v));\n                            else\n                                el.style.removeProperty(cssProp);\n                        }\n                        return;\n                    }\n                    if (value == null)\n                        el.removeAttribute('style');\n                    return;\n                }\n                self._applyGenericBinding(element, attributeName, value, meta);\n            };\n            const effect = self._createEffect(update);\n            self._addDirective(element, { type: 'bind', expression, update: effect });\n        }\n        _collectLoopScope(el) {\n            if (!el)\n                return null;\n            if (!el.parentElement) {\n                const cur = el.__x_if_current;\n                if (cur && cur.parentElement) {\n                    el = cur;\n                }\n                else {\n                    const anchorParent = el.__x_if_anchorParent;\n                    if (anchorParent)\n                        el = anchorParent;\n                }\n            }\n            let node = el;\n            while (node) {\n                const s = node.__x_scope;\n                if (s)\n                    return s;\n                node = node.parentElement;\n            }\n            const merged = {};\n            node = el;\n            while (node) {\n                const scope = this._loopScopes.get(node);\n                if (scope)\n                    Object.assign(merged, scope);\n                if (node === this.element)\n                    break;\n                node = node.parentElement;\n            }\n            return _Okeys(merged).length ? merged : null;\n        }\n        _updateElementDirectives(root, force) {\n            for (const [element, directives] of this._directives) {\n                for (const directive of directives) {\n                    if ((root === element || (element instanceof Element && root.contains(element))) && directive.update) {\n                        if (XTOOL_ENABLE_STATIC_DIRECTIVES && directive._static && !force)\n                            continue;\n                        directive.update();\n                    }\n                }\n            }\n        }\n        _updateElementDirectivesForVar(root, varName) {\n            const re = new RegExp('(^|[^$\\\\w])' + varName.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&') + '([^$\\\\w]|$)');\n            for (const [element, directives] of this._directives) {\n                if (!(root === element || (element instanceof Element && root.contains(element))))\n                    continue;\n                for (const directive of directives) {\n                    if (!directive.update)\n                        continue;\n                    const expr = directive.expression || '';\n                    if (re.test(expr)) {\n                        directive.update();\n                    }\n                }\n            }\n        }\n        _cleanupElementSubtree(root) {\n            const toDelete = [];\n            for (const [element, directives] of this._directives) {\n                if (root === element || (element instanceof Element && root.contains(element))) {\n                    for (const directive of directives) {\n                        if (directive.type === 'custom' && directive.customDirective?.unbind) {\n                            try {\n                                directive.customDirective.unbind(element, this);\n                            }\n                            catch { }\n                        }\n                    }\n                    toDelete.push(element);\n                }\n            }\n            if (toDelete.length) {\n                for (const el of toDelete)\n                    this._directives.delete(el);\n            }\n        }\n        _bindForDirective(element, expression) {\n            const self = this;\n            const match = expression.trim().match(/^(?:\\(\\s*([^,\\s]+)\\s*(?:,\\s*([^\\)]+))?\\s*\\)|([^,\\s]+))\\s+(in|of)\\s+(.+)$/);\n            if (!match) {\n                return;\n            }\n            const itemVar = match[1] || match[3];\n            const indexVar = match[2];\n            const listCode = match[5];\n            const keyAttrName = attrName('key');\n            const keyExpr = element.getAttribute(keyAttrName) || null;\n            if (keyExpr)\n                element.removeAttribute(keyAttrName);\n            const placeholder = d.createComment('x-for');\n            element.parentNode?.insertBefore(placeholder, element);\n            let templateToClone;\n            if (element[STR_TAGNAME] === STR_TEMPLATE) {\n                templateToClone = d.createElement('div');\n                templateToClone.style[STR_DISPLAY] = STR_CONTENTS;\n                templateToClone.appendChild(element.content.cloneNode(true));\n                element.parentNode?.removeChild(element);\n            }\n            else {\n                templateToClone = element;\n                element.parentNode?.removeChild(element);\n            }\n            const contextAnchor = placeholder.parentElement || self.element;\n            const listEval = self._createElementEvaluator(listCode.trim(), contextAnchor);\n            const keyEval = keyExpr ? self._createEvaluator(keyExpr) : null;\n            const BP_FOR = attrName('for');\n            const BP_KEY = attrName('key');\n            const BP_TEXT = attrName('text');\n            const BP_HTML = attrName('html');\n            const BP_DATA = attrName('data');\n            const buildBlueprint = (root) => {\n                const bp = [];\n                const walk = (el, path, isRootEl) => {\n                    if (!isRootEl && el.hasAttribute(BP_DATA))\n                        return;\n                    const isComponentTag = el[STR_TAGNAME] === 'COMPONENT';\n                    const scan = self._scanDirectiveAttrs(el, { skipRootFor: isRootEl });\n                    const dnames = scan.names.filter(n => n !== BP_KEY && (!isRootEl || n !== BP_FOR));\n                    const hasTextOrHtml = scan.names.includes(BP_TEXT) || scan.names.includes(BP_HTML);\n                    const forName = scan.forName;\n                    if (dnames.length) {\n                        if (forName) {\n                            bp.push({ path, directiveNames: [forName], hasTextOrHtml: hasTextOrHtml, forName });\n                            return;\n                        }\n                        bp.push({ path, directiveNames: dnames, hasTextOrHtml });\n                    }\n                    else {\n                        if (FT_TI && !hasTextOrHtml) {\n                            bp.push({ path, directiveNames: [], hasTextOrHtml });\n                        }\n                    }\n                    if (isComponentTag)\n                        return;\n                    let idx = 0;\n                    let child = el.firstElementChild;\n                    while (child) {\n                        const next = child.nextElementSibling;\n                        walk(child, path.concat(idx), false);\n                        idx++;\n                        child = next;\n                    }\n                };\n                walk(root, [], true);\n                return bp;\n            };\n            const hydrateFromBlueprint = (cloneRoot, bp) => {\n                for (let i = 0; i < bp.length; i++) {\n                    const instr = bp[i];\n                    const target = this._resolveNodeByPath(cloneRoot, instr.path);\n                    if (instr.forName) {\n                        const expr = target.getAttribute(instr.forName) || '';\n                        self._bindDirective(target, instr.forName, expr);\n                        continue;\n                    }\n                    for (let j = 0; j < instr.directiveNames.length; j++) {\n                        const dn = instr.directiveNames[j];\n                        const expr = target.getAttribute(dn) || '';\n                        if (dn === BP_KEY)\n                            continue;\n                        self._bindDirective(target, dn, expr);\n                    }\n                    if (FT_TI && !instr.hasTextOrHtml)\n                        self._bindTextInterpolationsIn(target);\n                }\n            };\n            const blueprint = buildBlueprint(templateToClone);\n            const instances = [];\n            const createScope = (item, idxOrKey, existing) => {\n                const scope = existing || {};\n                scope[itemVar] = item;\n                if (indexVar)\n                    scope[indexVar] = idxOrKey;\n                return scope;\n            };\n            const objIds = new WeakMap();\n            let objSeq = 0;\n            const extractId = (o) => {\n                if (!o || typeof o !== 'object')\n                    return null;\n                const v = o.id ?? o._id ?? o.key;\n                if (v == null)\n                    return null;\n                const t = typeof v;\n                return (t === 'string' || t === 'number') ? ('id:' + String(v)) : null;\n            };\n            const keyFor = (item) => {\n                if (item && typeof item === 'object') {\n                    const explicit = extractId(item);\n                    if (explicit)\n                        return explicit;\n                    let id = objIds.get(item);\n                    if (!id) {\n                        id = 'o#' + (++objSeq);\n                        objIds.set(item, id);\n                    }\n                    return id;\n                }\n                return 'p#' + (typeof item) + ':' + String(item);\n            };\n            const evalKeyExpr = (item, idxOrKey) => {\n                if (!keyEval)\n                    return null;\n                try {\n                    const base = self._createContextProxy(undefined, contextAnchor);\n                    const ctx = Object.create(base);\n                    ctx[itemVar] = item;\n                    if (indexVar)\n                        ctx[indexVar] = idxOrKey;\n                    const v = keyEval.call(self._createMethodContext(), ctx);\n                    const t = typeof v;\n                    return (t === 'string' || t === 'number') ? v : (v != null ? String(v) : null);\n                }\n                catch {\n                    return null;\n                }\n            };\n            const update = () => {\n                const norm = self._safeExecute(() => {\n                    const result = listEval();\n                    if (_AisArr(result))\n                        return { list: result, keys: null, src: result };\n                    const tag = result && Object.prototype.toString.call(result);\n                    const isMap = typeof Map !== 'undefined' && (result instanceof Map || tag === '[object Map]' || (result && typeof result.get === 'function' && typeof result.set === 'function' && typeof result.keys === 'function'));\n                    if (isMap) {\n                        return { list: _Afrom(result.values()), keys: _Afrom(result.keys()), src: result };\n                    }\n                    const isSet = typeof Set !== 'undefined' && (result instanceof Set || tag === '[object Set]' || (result && typeof result.add === 'function' && typeof result.has === 'function' && typeof result.values === 'function'));\n                    if (isSet) {\n                        return { list: _Afrom(result.values()), keys: null, src: result };\n                    }\n                    if (result && typeof result[Symbol.iterator] === 'function') {\n                        return { list: _Afrom(result), keys: null, src: result };\n                    }\n                    if (result && typeof result === 'object') {\n                        const keys = Object.keys(result);\n                        const list = keys.map(k => result[k]);\n                        return { list, keys, src: result };\n                    }\n                    return { list: [], keys: null, src: null };\n                }, { list: [], keys: null, src: null });\n                const list = norm.list;\n                const keysArr = norm.keys;\n                const oldByObjKey = new Map();\n                const oldPrimQueues = new Map();\n                for (let i = 0; i < instances.length; i++) {\n                    const n = instances[i];\n                    const k = n.__x_for_key;\n                    const ps = n.__x_primSig;\n                    if (ps) {\n                        let q = oldPrimQueues.get(ps);\n                        if (!q) {\n                            q = [];\n                            oldPrimQueues.set(ps, q);\n                        }\n                        q.push(n);\n                    }\n                    else if (k) {\n                        oldByObjKey.set(k, n);\n                    }\n                }\n                const newNodes = new Array(list.length);\n                const parent = placeholder.parentNode;\n                for (let i = 0; i < list.length; i++) {\n                    const item = list[i];\n                    const idxOrKey = keysArr ? keysArr[i] : i;\n                    let node;\n                    let nodeKey;\n                    const explicitKey = keyEval ? evalKeyExpr(item, idxOrKey) : null;\n                    if (explicitKey != null) {\n                        nodeKey = 'k:' + String(explicitKey);\n                        const prev = oldByObjKey.get(nodeKey);\n                        if (prev) {\n                            node = prev;\n                            oldByObjKey.delete(nodeKey);\n                        }\n                    }\n                    if (!node) {\n                        const k = keyFor(item);\n                        if (k && k.startsWith('o#') || (k && k.startsWith('id:'))) {\n                            nodeKey = k;\n                            const prev = oldByObjKey.get(k);\n                            if (prev) {\n                                node = prev;\n                                oldByObjKey.delete(k);\n                            }\n                        }\n                        else if (k && k.startsWith('p#')) {\n                            const ps = k;\n                            const q = oldPrimQueues.get(ps);\n                            if (q && q.length) {\n                                node = q.shift();\n                            }\n                            if (node) {\n                                nodeKey = node.__x_for_key;\n                            }\n                            if (node) {\n                                node.__x_primSig = ps;\n                            }\n                        }\n                    }\n                    if (!node) {\n                        const clone = templateToClone.cloneNode(true);\n                        clone.removeAttribute('x-for');\n                        if (keyExpr)\n                            clone.removeAttribute(keyAttrName);\n                        const initScope = createScope(item, idxOrKey, {});\n                        clone.__x_scope = initScope;\n                        clone.__x_itemRef = item;\n                        if (indexVar)\n                            clone.__x_idxRef = idxOrKey;\n                        self._loopScopes.set(clone, initScope);\n                        try {\n                            hydrateFromBlueprint(clone, blueprint);\n                        }\n                        catch { }\n                        node = clone;\n                        node.__x_for_key = (nodeKey !== undefined) ? nodeKey : ('n#' + (++objSeq));\n                    }\n                    else {\n                        const existingScope = node.__x_scope;\n                        const prevIdxRef = node.__x_idxRef;\n                        const prevItemRef = node.__x_itemRef;\n                        const scope = createScope(item, idxOrKey, existingScope);\n                        node.__x_scope = scope;\n                        self._loopScopes.set(node, scope);\n                        let needsUpdate = false;\n                        if (prevItemRef !== item) {\n                            needsUpdate = true;\n                            node.__x_itemRef = item;\n                        }\n                        const indexChanged = !!indexVar && prevIdxRef !== idxOrKey;\n                        if (indexChanged) {\n                            needsUpdate = true;\n                            node.__x_idxRef = idxOrKey;\n                        }\n                        if (needsUpdate) {\n                            if (indexChanged && indexVar)\n                                self._updateElementDirectivesForVar(node, indexVar);\n                            else\n                                self._updateElementDirectives(node);\n                        }\n                    }\n                    if (nodeKey)\n                        node.__x_for_key = nodeKey;\n                    const sig = (!keyExpr && !(item && typeof item === 'object')) ? ('p#' + (typeof item) + ':' + String(item)) : undefined;\n                    node.__x_primSig = sig;\n                    newNodes[i] = node;\n                }\n                for (const [, node] of oldByObjKey) {\n                    if (node && node.parentNode) {\n                        self._cleanupElementSubtree(node);\n                        node.parentNode.removeChild(node);\n                    }\n                }\n                for (const [, queue] of oldPrimQueues) {\n                    for (const node of queue) {\n                        if (node && node.parentNode) {\n                            self._cleanupElementSubtree(node);\n                            node.parentNode.removeChild(node);\n                        }\n                    }\n                }\n                if (parent) {\n                    const oldIndexMap = new Map();\n                    for (let i = 0; i < instances.length; i++) {\n                        const k = instances[i].__x_for_key;\n                        if (k !== undefined)\n                            oldIndexMap.set(k, i);\n                    }\n                    const seq = new Array(newNodes.length);\n                    for (let i = 0; i < newNodes.length; i++) {\n                        const k = newNodes[i].__x_for_key;\n                        const oldIdx = oldIndexMap.has(k) ? oldIndexMap.get(k) : -1;\n                        seq[i] = oldIdx;\n                    }\n                    const { lisMask: lis } = this._computeLISMask(seq);\n                    const tailAnchor = instances.length ? (instances[instances.length - 1].nextSibling) : placeholder.nextSibling;\n                    let anchor = null;\n                    for (let i = newNodes.length - 1; i >= 0; i--) {\n                        const node = newNodes[i];\n                        const ref = anchor ?? tailAnchor;\n                        if (seq[i] === -1) {\n                            parent.insertBefore(node, ref);\n                        }\n                        else if (!lis[i]) {\n                            parent.insertBefore(node, ref);\n                        }\n                        anchor = node;\n                    }\n                }\n                instances.length = 0;\n                for (let i = 0; i < newNodes.length; i++)\n                    instances.push(newNodes[i]);\n            };\n            const dir = { type: 'for', expression };\n            const effect = self._createEffect(update, dir);\n            dir.update = effect;\n            self._addDirective(placeholder, dir);\n        }\n        _resolveNodeByPath(root, path) {\n            let node = root;\n            for (let i = 0; i < path.length; i++) {\n                let idx = 0;\n                let child = node.firstElementChild;\n                while (child && idx < path[i]) {\n                    child = child.nextElementSibling;\n                    idx++;\n                }\n                node = child || node;\n            }\n            return node;\n        }\n        _computeLISMask(seq) {\n            const predecessors = new Array(seq.length);\n            const tails = [];\n            const tailIdx = [];\n            for (let i = 0; i < seq.length; i++) {\n                const v = seq[i];\n                if (v < 0) {\n                    predecessors[i] = -1;\n                    continue;\n                }\n                let lo = 0, hi = tails.length;\n                while (lo < hi) {\n                    const mid = (lo + hi) >> 1;\n                    if (seq[tails[mid]] < v)\n                        lo = mid + 1;\n                    else\n                        hi = mid;\n                }\n                if (lo === tails.length) {\n                    tails.push(i);\n                }\n                else {\n                    tails[lo] = i;\n                }\n                predecessors[i] = lo > 0 ? tails[lo - 1] : -1;\n                tailIdx[lo] = i;\n            }\n            const lisLen = tails.length;\n            const lis = new Array(seq.length).fill(false);\n            let k = lisLen ? tails[lisLen - 1] : -1;\n            while (k >= 0) {\n                lis[k] = true;\n                k = predecessors[k];\n            }\n            return { lisMask: lis, lisLen };\n        }\n        _render() {\n            const self = this;\n            for (const directives of self._directives.values()) {\n                for (const dr of directives) {\n                    if (XTOOL_ENABLE_STATIC_DIRECTIVES && dr._static)\n                        continue;\n                    if (dr.update) {\n                        try {\n                            dr.update();\n                        }\n                        catch (error) {\n                            if (!(error instanceof ReferenceError)) { }\n                        }\n                    }\n                }\n            }\n        }\n    }\n    ReactiveComponent._BA = {\n        itemscope: 1, formnovalidate: 1, novalidate: 1, default: 1, readonly: 1\n    };\n    const xTool = new XToolFramework();\n    return xTool;\n}();\nif (typeof window !== 'undefined') {\n    const w = window;\n    w.XTool = XToolFramework;\n    w.FyneJS = XToolFramework;\n}\n//# sourceMappingURL=x-tool.js.map"],"mappings":"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","ignoreList":[]}
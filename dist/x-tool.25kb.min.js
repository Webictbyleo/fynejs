'use strict'
const t=Array.isArray,e=function(){const e=Array.from,s=t,i=Object.keys,n=(...t)=>{},o='style',r='display',c='none',h='tagName',f='TEMPLATE',l='length'
let u=!0
const a='undefined'!=typeof document?document:null
try{if(a&&a.head&&!a.getElementById('x-tool-initial-css')){const t=a.createElement(o)
t.id='x-tool-initial-css',t.textContent='[x-show],[x-if],[x-else],[x-else-if],[x\\:show],[x\\:if],[x\\:else],[x\\:else-if]{display:none;}',a.head.appendChild(t)}}catch{}let y='x'
const p=t=>`${y}-${t}`
class d{attachToParent(t){this.t=t,t.i(this)}get id(){return this.o}get framework(){return this.h}get element(){return this.l}set element(t){this.l=t}get isBound(){return this.u}set isBound(t){this.u=t}get isMounted(){return this.p}set isMounted(t){this.p=t}get isDestroyed(){return this.m}set isDestroyed(t){this.m=t}v(t,e){const s=this.M.get(t)||[]
s.push(e),this.M.set(t,s)}constructor(t,e,s){this._=!1,this.$=!1,this.l=null,this.u=!1,this.p=!1,this.m=!1,this.k=!1,this.D=[],this.t=null,this.O={},this.R={},this.A=new Map,this.S=new Map,this.T=new Map,this.C=null,this.F=!1,this.j=!1,this.P=!1,this.M=new Map,this.I=new Set,this.q=[],this.B=new WeakMap,this.L=new Map,this.N=new Map,this.W=null,this.U=!1,this.K=[],this.Z=new WeakMap,this.J=new WeakMap,this.V=null,this.X=t=>{if(!t)return void this.A.clear()
const e=this.T.get(t)
if(e)for(const t of e)this.A.delete(t)},this.G=t=>{const e=this.H[t]
'function'==typeof e&&this.Y(()=>e.call(this.tt()),`Error in '${t+''}'`)},this.et=t=>{if('function'!=typeof t)return
const e=()=>{try{t()}catch{}try{this.I.delete(e)}catch{}}
return this.I.add(e),()=>{try{this.I.delete(e)}catch{}}},this.it=(t,e,s,i)=>{t.addEventListener(e,s,i),this.q.push({element:t,event:e,handler:s,options:i})},this.o=t,this.h=s,this.nt=e.methods||{},this.O=e.computed||{},this.R=e.propEffects||{},this.P=!(!e.computed||!Object.keys(e.computed).length),this.H={mounted:e.mounted,unmounted:e.unmounted||e.destroyed,updated:e.updated,beforeMount:e.beforeMount,beforeUnmount:e.beforeUnmount||e.beforeDestroy},this.st=this.ot(e.data||{}),this.rt=this.ct()}callBeforeMount(){this.k||(this.G('beforeMount'),this.k=!0)}ht(t){if(this.isBound){this.X(t)
const e=new Set,s=this.N.get(t)
if(s)for(let t=0;t<s.length;t++)e.add(s[t])
for(const t of e)this.Y(t,'Error in reactive effect')
!this.P&&u||this.ft(),this.G('updated')}}ct(){const t={}
for(const e in this.nt){const s=this.nt[e]
let i=null
try{if(!/\[native code\]/.test(s+'')){let e=(s+'').trim();/^function[\s\(]/.test(e)||/^[\w\$_][\w\d\$_]*\s*=>/.test(e)||/^\(.*?\)\s*=>/.test(e)||(e='function '+e)
const n='with(ctx){const fn = ('+e+');return fn.apply(thisArg,argsArray);}'
try{i=Function('thisArg','argsArray','ctx',n)}catch(t){i=null}}}catch{i=null}t[e]=(...t)=>{const n=this.tt(),o=this.j
this.j=!0
try{const o=this.lt(0,0)
if(i)try{return this.Y(()=>i.call(0,n,t,o),`Error in method '${e}'`)}catch(t){throw t}return this.Y(()=>s.call(n,...t),`Error in method '${e}'`)}finally{this.j=o}}}return t}ut(t){if(this.dt(t),this.A.has(t))return this.A.get(t)
try{const e=this.O[t]
this.F=!0,this.C=t
const s=this.S.get(t)
if(s)for(const e of s){const s=this.T.get(e)
s&&s.delete(t)}this.S.set(t,new Set)
const i=e.call(this.tt())
return this.F=!1,this.C=null,this.A.set(t,i),i}catch{return this.F=!1,void(this.C=null)}}dt(t){if(!this.W)return
let e=this.N.get(t)
e||(e=[],this.N.set(t,e)),e.includes(this.W)||e.push(this.W)}ft(){this.U||(this.U=!0,requestAnimationFrame(()=>{if(this.U=!1,this.yt(),this.K&&this.K.length){const t=this.K.splice(0,this.K.length)
for(const e of t)try{e()}catch{}}}))}Y(t,e,s){try{return t()}catch(t){return s}}bindToElement(t){this.u||(this.l=t,this.k||this.callBeforeMount(),this.completeBinding())}getContext(t=!0){return this.tt(t)}vt(){if(this.l){try{this.wt(this.l)}catch{}this.ft()}}completeBinding(){!this.u&&this.l&&(this.h.bt(this.l)||this.h.xt(this.l,this),this.u=!0,this.p=!0,this.wt(this.l),this.gt(),this.yt(),this.G('mounted'))}i(t){this.D.includes(t)||this.D.push(t)}Mt(t){const e=this.D.indexOf(t)
e>-1&&this.D.splice(e,1)}gt(){}destroy(){const t=this
if(!t.m){t.G('beforeUnmount')
for(const e of t.D)e.isDestroyed||e.destroy()
t.t&&t.t.Mt(t)
for(const[e,s]of t.M)for(const i of s)if('custom'===i.type&&i.customDirective?.unbind)try{i.customDirective.unbind(e,t)}catch{n()}t.M.clear()
for(const{element:e,event:s,handler:i,options:n}of t.q)e.removeEventListener(s,i,n)
t.q=[]
for(const e of Array.from(t.I))try{e()}catch{n()}if(t.I.clear(),t.A.clear(),t.L.clear(),t.N.clear(),t.V&&t._t)for(const e of t.V.N.values()){const s=e.indexOf(t._t)
s>-1&&e.splice(s,1)}t.l&&t.h.$t(t.l),t.G('unmounted'),t.m=!0,t.p=!1,t.u=!1,t.D=[],t.t=null,this.kt=new WeakMap,t.l=null,queueMicrotask(()=>t.h.Et(t.o))}}Dt(t,e){if(!t||!e)return
let s
this.V=e
try{s=Function('ctx','with(ctx){return ('+t+')}')}catch{return}const i=()=>{let t
e.W=i
try{const i=e.getContext(!0)
t=s(i)}catch{t=null}if(e.W=null,t&&'object'==typeof t){this.st.$props=this.st.$props||{},this._=!0
for(const e in t){const s=t[e]
this.st[e]!==s&&(this.st[e]=s)}this._=!1}}
this._t=i,i()}wt(t){const e=this,s=(t,s=!1)=>{if(!s&&(t.hasAttribute(p('data'))||this.h.bt(t)))return!1
const i='COMPONENT'===t[h],n=[]
let o=!1,r=null
for(const e of t.attributes){const t=e.name;(t.startsWith(y+'-')||t.startsWith(y+':'))&&(n.push(e),o||t!==p('text')&&t!==p('html')||(o=!0),r||t!==p('for')||(r=e))}if(n.length>0){if(r)return e.Ot(t,r.name,r.value),!1
for(const s of n)e.Ot(t,s.name,s.value)}return s||!i}
s(t,!0),e.Rt(t,s)}At(t){const e=Array.from(t.childNodes)
for(const s of e){if(s.nodeType!==Node.TEXT_NODE)continue
const e=s,i=e.nodeValue||''
if(e.St||-1===i.indexOf('{{'))continue
const n=(e.parentElement?.tagName||'').toLowerCase(),o='code'===n||'pre'===n,r=[]
let c=0
for(;c<i.length;){const t=i.indexOf('{{',c)
if(-1===t){r.push({literal:i.slice(c)})
break}let e=0
for(let s=t-1;s>=0&&92===i.charCodeAt(s);s--)e++
if(e>0){const s=c,n=t-e
n>s&&r.push({literal:i.slice(s,n)}),e>1&&r.push({literal:'\\'.repeat(e-1)})
const o=i.indexOf('}}',t+2)
if(-1===o){r.push({literal:i.slice(t,i.length)}),c=i.length
break}r.push({literal:i.slice(t,o+2)}),c=o+2
continue}{t>c&&r.push({literal:i.slice(c,t)})
const e=i.indexOf('}}',t+2)
if(-1===e){r.push({literal:i.slice(t)}),c=i.length
break}const s=i.slice(t+2,e).trim()
s?r.push({expr:s}):r.push({literal:''}),c=e+2
continue}}const h=r.some(t=>t.expr),f=r.some(t=>t.literal&&t.literal.includes('{{'))
if(!h&&!f)continue
e.St=!0
const l=h&&!o?r.filter(t=>t.expr).map(e=>this.Tt(e.expr,t)):[]
let u=0
const a=()=>{u=0
let t=''
for(const e of r)if(null!=e.literal)t+=e.literal
else if(e.expr)if(o)t+='{{'+e.expr+'}}'
else{const e=l[u++]()
t+=null==e?'':e+''}e.textContent!==t&&(e.textContent=t)},y={type:'text-interpolation',expression:i,update:0}
this.v(t,y)
const p=this.Ct(a,y)
y.update=p}}Rt(t,e){let s=t.firstElementChild
for(;s;){const t=s.nextElementSibling
e(s)&&this.Rt(s,e),s=t}}Ot(t,e,s){const i=this,n=e.startsWith(y+':'),r=e.slice(y.length+1)
if(n||'class'===r||r===o)return t.removeAttribute(e),i.Ft(t,r,s)
if('transition'===r)return t.removeAttribute(e),i.jt(t,s)
if('text'===r||'html'===r||'show'===r)return t.removeAttribute(e),i.Pt(t,s,r)
if(!('model'===r?(t.removeAttribute(e),i.It(t,s),1):'if'===r?(t.removeAttribute(e),i.qt(t,s),1):'for'===r&&(t.removeAttribute(e),i.Bt(t,s),1))&&r.indexOf(':')>-1){const[n,o]=r.split(':',2),[c,...h]=o.split('.'),f=h.reduce((t,e)=>(e&&(t[e]=!0),t),{})
if('on'===n){t.removeAttribute(e)
const n=i.framework.Lt(c)
return n?i.Nt(t,c,s,n,f):i.Wt(t,c,s,f)}return t.removeAttribute(e),i.Ft(t,c,s)}}jt(t,e){}zt(t,e){e&&e()}Ut(t,e){e&&e()}Kt(t,e){let s=!1
const i=()=>{if(!s){s=!0
try{t.removeEventListener('transitionend',i),t.removeEventListener('animationend',i)}catch{}e()}}
try{t.addEventListener('transitionend',i),t.addEventListener('animationend',i),setTimeout(i,500)}catch{e()}}Ct(t,e){const s=()=>{this.W=s
try{t()}finally{this.W=null}}
if(s(),u&&e&&0===e.Zt){let t=!1
for(const e of this.N.values())if(e.includes(s)){t=!0
break}e.Zt=!t}return s}Pt(t,e,s){if('class'===s||s===o)return this.Ft(t,s,e)
const i=this.Tt(e,t)
let n,h
if('show'===s){const e=t
n=e.style[r]!==c?e.style[r]:0}const f={type:s,expression:e,update:0,originalDisplay:n}
this.v(t,f)
const l=this.Ct(()=>{const e=i(),o=t
switch(s){case'text':o.textContent=e+''
break
case'html':o.innerHTML=(e||'')+''
break
case'show':const t=!!e
if(h===t)return
h=t,t?(o.style[r]=n||'',this.zt(o)):this.Ut(o,()=>{o.style[r]=c})}},f)
f.update=l}It(t,e){const s='checkbox'===t.type,i='number'===t.type||'range'===t.type,n='SELECT'===t.tagName&&!0===t.multiple
Reflect.has(this.st,e)||Reflect.defineProperty(this.st,e,{configurable:!0,enumerable:!0,writable:!0})
const o=this.Tt(e,t),r=this.Jt(e+' = $value',!0),c=s?(()=>{if(t.hasAttribute('value'))return t.value
const e=this.Vt(t)
if(e){const t=Object.keys(e)
if(1===t.length)return e[t[0]]}return t.value})():0
this.Ct(()=>(e=>{if(s)if(Array.isArray(e)){const s=t.hasAttribute('value')?t.value:c
t.checked=null!=s&&e.includes(s)}else t.checked=!!e
else{if(n){const s=t,i=Array.isArray(e)?e:[]
for(let t=0;t<s.options.length;t++){const e=s.options[t]
e.selected=i.includes(e.value)}return}t.value=(e??(i?0:''))+''}})(o()))
const f=this.lt(0,t),l=t.type,u='SELECT'===t[h]||'checkbox'===l||'radio'===l||'file'===l?'change':'input'
this.it(t,u,()=>{const e=(()=>{if(s)return Array.isArray(o())&&0!==c?t.checked?c:0:t.hasAttribute('value')?t.checked?t.value:0:t.checked
if(n){const e=t,s=[]
for(let t=0;t<e.options.length;t++){const i=e.options[t]
i.selected&&s.push(i.value)}return s}return i?parseFloat(t.value)||0:t.value})(),h=this.Y(()=>o(),'model read',0)
if(s&&Array.isArray(h)){const e=h,s=t.hasAttribute('value')?t.value:c
if(0!==s){const i=e.indexOf(s)
t.checked?-1===i&&e.push(s):i>-1&&e.splice(i,1)}}else if(n&&Array.isArray(h)){const t=h
t.splice(0,t.length),e.forEach(e=>t.push(e))}else f.$value=e,this.Y(()=>{r.call(this.tt(),f)})}),this.v(t,{type:'model',property:e})}qt(t,e){const s=this,i=a.createComment('x-if')
t.parentNode?.insertBefore(i,t),t.Xt=i.parentElement||0
const n=[],o=(t=>{if(t[h]===f){const e=a.createElement('div')
return e.style[r]='contents',e.appendChild(t.content.cloneNode(!0)),{el:e,isTemplate:!0}}return{el:t,isTemplate:!1}})(t),c=s.Tt(e,t)
n.push({el:o.el,test:c,isTemplate:o.isTemplate}),o.isTemplate||(o.el.Gt=!0)
const u=[t]
let y=-1
for(const t of u)t.parentNode&&t.parentNode.removeChild(t)
const p=e=>{if(0>e)return
const o=n[e]
o.el.Gt||(s.wt(o.el),o.el.Gt=!0),t.Ht?.parentNode?.removeChild(t.Ht),o.el.parentNode||(i.parentNode?.insertBefore(o.el,i.nextSibling),this.zt(o.el)),t.Ht=o.el,y=e},d=(t,e)=>{if(0>t)return void(e&&e())
const s=n[t]
s.el.parentNode?this.Ut(s.el,()=>{s.el.parentNode&&s.el.parentNode.removeChild(s.el),e&&e()}):e&&e(),y=-1},w=s.Ct(()=>{let t=-1
for(let e=0;e<n[l];e++){const s=n[e]
if(!s.test||s.test()){t=e
break}}t!==y&&(-1!==y?d(y,()=>p(t)):p(t))})
s.v(t,{type:'if',expression:e,update:w})}Wt(t,e,s,n){const o=this,r=(s||'').trim(),c=o.Qt(r),h=n?{once:!!n.once,passive:!!n.passive,capture:!!n.capture}:0,f=!!n?.self,l=!!n?.prevent,u=!!n?.stop,a={enter:['enter'],esc:['escape','esc'],escape:['escape','esc'],space:[' ','space','spacebar'],tab:['tab'],backspace:['backspace'],delete:['delete','del'],del:['delete','del'],arrowup:['arrowup','up'],arrowdown:['arrowdown','down'],arrowleft:['arrowleft','left'],arrowright:['arrowright','right'],home:['home'],end:['end'],pageup:['pageup'],pagedown:['pagedown']},y={ctrl:!!n?.ctrl,alt:!!n?.alt,shift:!!n?.shift,meta:!!n?.meta},p={left:0,middle:1,right:2},d=!!n?.single,w=!!n?.multi,m=n?i(n):[],b=[]
for(const t of m){const e=a[t.toLowerCase()]
e&&b.push(...e)}const v=[]
for(const t of m){const e=p[t.toLowerCase()]
0!==e&&v.push(e)}const x=b.length>0||y.ctrl||y.alt||y.shift||y.meta,g=v.length>0,M=d||w,$=e=>{if(f&&e.target!==t)return!1
if(M){if(!(e instanceof TouchEvent))return!1
{const t=e.touches.length
if(d&&1!==t)return!1
if(w&&2>t)return!1}}if(g){if(!(e instanceof MouseEvent))return!1
if(!v.includes(e.button))return!1}if(x){if(!(e instanceof KeyboardEvent))return!1
const t=(e.key||'').toLowerCase()
if(b.length>0&&!b.includes(t))return!1
if(y.ctrl&&!e.ctrlKey)return!1
if(y.alt&&!e.altKey)return!1
if(y.shift&&!e.shiftKey)return!1
if(y.meta&&!e.metaKey)return!1}return!0},k=!!r
let O=null
const E=o.tt()
if(c){const e=o.Yt(c.paramsList,c.body,c.isBlock),s=c.paramsList.length?e=>c.paramsList.map((s,i)=>0===i?e:1===i?t:0):()=>[]
O=i=>{const n=o.lt(i,t)
e.call(E,n,...s(i))}}else if(k){const e=r.includes(';'),s=o.Jt(r,e)
O=e=>{const i=o.lt(e,t),n=s.call(E,i)
'function'==typeof n&&n.call(E,e)}}const A=t=>{o.Y(()=>{$(t)&&(l&&'function'==typeof t.preventDefault&&t.preventDefault(),u&&'function'==typeof t.stopPropagation&&t.stopPropagation(),O&&O(t))})}
if(this.framework.te().delegate&&['click','input','change','keydown','keyup'].includes(e)){const s=this.framework.ee(t,e,{filter:t=>$(t),run:t=>A(t),once:!!n?.once,comp:this})
this.et(s)}else o.it(t,e,A,h)}Jt(t,e=!1){const s=`${e?'s':'r'}:${t}`
let i=this.L.get(s)
return i||(i=Function('ctx',`with(ctx){${e?t:`return (${t})`}}`),this.L.set(s,i)),i}Tt(t,e){const s=this,i=s.Jt(t)
return()=>this.Y(()=>i.call(s.tt(),s.lt(0,e)),'Error evaluating expression: '+t)}Qt(t){let e=t.match(/^\s*\(\s*([^)]*?)\s*\)\s*=>\s*([\s\S]+)$/)
if(e||(e=t.match(/^\s*([a-zA-Z_$][a-zA-Z0-9_$]*)\s*=>\s*([\s\S]+)$/)),!e)return null
const s=(e[1]||'').split(',').map(t=>t.trim()).filter(Boolean),i=(e[2]||'').trim(),n=i.startsWith('{')&&i.endsWith('}')
return{paramsList:s,body:n?i.slice(1,-1):i,isBlock:n}}Yt(t,e,s){return Function('ctx',...t,'with(ctx){'+(s?e:'return ( '+e+' );')+'}')}ie(e,s){if(Object.getPrototypeOf(e)!==Object.prototype&&!t(e))return e
const i=this
if(this.kt||(this.kt=new WeakMap),this.kt.has(e))return this.kt.get(e)
const n=new Proxy(e,{get(e,n,o){if(t(e)){if(n===Symbol.iterator)return i.dt(s),Reflect.get(e,n,o);('length'===n||'string'==typeof n&&/^\d+$/.test(n))&&i.dt(s)}else i.dt(s)
const r=Reflect.get(e,n,o)
return t(e)&&'function'==typeof r&&['push','pop','shift','unshift','splice','sort','reverse','copyWithin','fill'].includes(n)?(...t)=>{const n=e,o=n.length,c=n[0],h=n[o-1],f=r.apply(e,t)
return n.length===o&&n[0]===c&&n[n.length-1]===h||i.ht(s),f}:r&&'object'==typeof r?i.ie(r,s):r},ownKeys:t=>Reflect.ownKeys(t),has:(t,e)=>Reflect.has(t,e),set(t,e,n){if(i.m)return!0
if('symbol'==typeof e)return!0
const o=Reflect.has(t,e),r=o?Reflect.get(t,e):0
if(n&&'object'==typeof n&&i.ie(n,s),!o){try{Reflect.defineProperty(t,e,{configurable:!0,enumerable:!0,writable:!0,value:n})}catch{Reflect.set(t,e,n)}return i.ht(s),!0}return r===n||(Reflect.set(t,e,n),i.ht(s)),!0},deleteProperty:(t,e)=>Reflect.deleteProperty(t,e)})
return this.kt.set(e,n),n}ot(e){const s=this
return new Proxy(e,{get(t,e,i){const n=Reflect.get(t,e,i)
return e===Symbol.iterator?n:('symbol'!=typeof e&&s.dt(e),n&&'object'==typeof n?s.ie(n,e):n)},ownKeys:t=>Reflect.ownKeys(t),has:(t,e)=>Reflect.has(t,e),set:(e,i,n,o)=>{if(s.m)return!0
if(i===Symbol.iterator&&t(e))return n
const r=Reflect.get(e,i)
if(r===n)return!0
if(Reflect.has(e,i))Reflect.set(e,i,n,o)
else try{Reflect.defineProperty(e,i,{configurable:!0,enumerable:!0,writable:!0,value:n})}catch{Reflect.set(e,i,n,o)}if(this.ht(i),this._&&'$props'!==i){const t=e.$props
t&&(t[i]=n)
const s=this.R[i]
s&&!this.$&&(this.$=!0,this.Y(()=>s.call(this.tt(),n,r)),this.$=!1)}return!0}})}tt(t=!0){const e={$log(...t){},$destroy:()=>this.destroy(),$forceUpdate:()=>this.ft(),$addCleanupFunction:t=>this.et(t),$nextTick:t=>t?(this.K.push(t),void(this.U||queueMicrotask(()=>{if(!this.U&&this.K.length){const t=this.K.splice(0,this.K.length)
for(const e of t)try{e()}catch{}}}))):new Promise(t=>{this.K.push(()=>t()),this.U||queueMicrotask(()=>{if(!this.U&&this.K.length){const t=this.K.splice(0,this.K.length)
for(const e of t)try{e()}catch{}}})}),$el:this.l,$id:this.o,$isMounted:this.p,$isDestroyed:this.m,$parent:this.t,$children:this.D,$mutate:t=>{const e=this.j,s=this.F
this.j=!1,this.F=!1
try{return'function'==typeof t?t():0}finally{this.j=e,this.F=s,this.ft()}}}
return new Proxy(this.st,{get:(t,s)=>{if(s in t){if(this.dt(s),this.C){let t=this.S.get(this.C)
t||(t=new Set,this.S.set(this.C,t)),t.add(s)
let e=this.T.get(s)
e||(e=new Set,this.T.set(s,e)),e.add(this.C)}return t[s]}return s in this.O?this.ut(s):s in e?e[s]:this.rt[s]},set:(t,e,s)=>(this.F||(this.st[e]=s),!0)})}lt(t,e){const s=this,n=e?this.Vt(e):null,o=n?new Set(i(n)):new Set,r='undefined'!=typeof window?window:0,c='undefined'!=typeof document?document:0,h=this.framework.te(),f=!!h.sandboxExpressions,l=new Set((h.allowGlobals||[]).map(t=>t+'')),u=t=>{if(!t)return t
if('function'!=typeof t.addEventListener)return t
const e=new WeakMap,i=(t,e)=>{try{return t+'|'+(0===e?'':'object'==typeof e?JSON.stringify(e):e+'')}catch{return t+'|'}}
return new Proxy(t,{get(t,n,o){if('addEventListener'===n)return(n,o,r)=>{t.addEventListener(n,o,r)
const c=s.et(()=>{try{t.removeEventListener(n,o,r)}catch{}})
try{if('function'==typeof o&&c){let t=e.get(o)
t||(t=new Map,e.set(o,t)),t.set(i(n,r),c)}}catch{}}
if('removeEventListener'===n)return(s,n,o)=>{try{t.removeEventListener(s,n,o)}catch{}try{if('function'==typeof n){const t=e.get(n)
if(t){const r=i(s,o),c=t.get(r)
if(c){try{c()}catch{}t.delete(r)}0===t.size&&e.delete(n)}}}catch{}}
if('querySelector'===n)return e=>{const s=t.querySelector(e)
return u(s)}
if('querySelectorAll'===n)return e=>{const s=t.querySelectorAll(e)
return Array.from(s).map(u)}
if('getElementById'===n)return e=>{const s=t.getElementById(e)
return u(s)}
if('document'===n){const e=t.document
return u(e)||e}return Reflect.get(t,n,o)}})},a=new Map,y=new Map,p=new Map,d=t=>{if(!t)return
const e=(...e)=>{const i=new t(...e)
return s.et(()=>{try{i.disconnect()}catch{}}),i}
return e.prototype=t.prototype,e},w={$target:e||0,$event:t||0,...f&&!l.has('setTimeout')?{}:{setTimeout(t,e,...i){const n=r?.setTimeout?.(t,e,...i)
if(null!=n){const t=s.et(()=>{try{r?.clearTimeout?.(n)}catch{}})
a.set(n,t)}return n}},...f&&!l.has('clearTimeout')?{}:{clearTimeout(t){try{r?.clearTimeout?.(t)}catch{}finally{try{const e=a.get(t)
e&&(e(),a.delete(t))}catch{}}}},...f&&!l.has('setInterval')?{}:{setInterval(t,e,...i){const n=r?.setInterval?.(t,e,...i)
if(null!=n){const t=s.et(()=>{try{r?.clearInterval?.(n)}catch{}})
y.set(n,t)}return n}},...f&&!l.has('clearInterval')?{}:{clearInterval(t){try{r?.clearInterval?.(t)}catch{}finally{try{const e=y.get(t)
e&&(e(),y.delete(t))}catch{}}}},...f&&!l.has('requestAnimationFrame')?{}:{requestAnimationFrame(t){const e=r?.requestAnimationFrame?.(t)
if(null!=e){const t=s.et(()=>{try{r?.cancelAnimationFrame?.(e)}catch{}})
p.set(e,t)}return e}},...f&&!l.has('cancelAnimationFrame')?{}:{cancelAnimationFrame(t){try{r?.cancelAnimationFrame?.(t)}catch{}finally{try{const e=p.get(t)
e&&(e(),p.delete(t))}catch{}}}},...f&&!l.has('MutationObserver')?{}:{MutationObserver:d(r?.MutationObserver)},...f&&!l.has('ResizeObserver')?{}:{ResizeObserver:d(r?.ResizeObserver)},...f&&!l.has('IntersectionObserver')?{}:{IntersectionObserver:d(r?.IntersectionObserver)},...f&&!l.has('window')?{}:{window:u(r)},...f&&!l.has('document')?{}:{document:u(c)}}
return new Proxy({},{get:(t,e)=>n&&e in n?n[e]:e in s.st?s.st[e]:e in s.O?s.ut(e):e in s.rt?s.rt[e]:e in w?w[e]:0,set:(t,e,i)=>(n&&o.has(e)?n[e]=i:s.st[e]=i,!0),has:(t,e)=>!(!n||!(e in n))||e in s.st||e in s.O||e in s.rt||e in w})}Nt(t,e,s,i,n){const o=this,r=o.Tt(s,t),c={type:'custom',expression:s,customDirective:i}
i.bind&&o.Y(()=>i.bind(t,r(),s,o,n,r))
const h=o.Ct(()=>{i.update&&o.Y(()=>i.update(t,r(),s,o,n,r))})
c.update=h,o.v(t,c)}Ft(e,s,i){const n=this,r=n.Tt(i,e)
if('class'===s){const t=e
if(!n.J.get(t)){const e=new Set,s=t.className||''
if(s)for(const t of s.split(/\s+/))t&&e.add(t)
n.J.set(t,e)}}const c=e
let h=null
if(s in c)h=s
else{const t=s.replace(/-([a-z])/g,(t,e)=>e.toUpperCase())
t in c?h=t:'readonly'===s.toLowerCase()&&'readOnly'in c&&(h='readOnly')}const f=!(!h||'boolean'!=typeof c[h]),l=!(!h||!(h in c)||'function'==typeof c[h]),u=!!d.ne[s.toLowerCase()],a=n.Ct(()=>{const i=r()
if('class'===s){const s=e,o=n.J.get(s)
if('string'==typeof i)s.className=o&&o.size?[...o].join(' ')+(i?' '+i:''):i||''
else if(t(i))o&&o.size?s.className=[...o,...i.filter(Boolean)].join(' '):s.className=i.filter(Boolean).join(' ')
else if(i&&'object'==typeof i){o&&o.size&&(s.className=[...o].join(' '))
for(const t in i){const e=!!i[t]
if(!t)continue
const n=t.split(/\s+/)
for(let t=0;t<n.length;t++){const i=n[t]
i&&s.classList.toggle(i,e)}}}else null==i&&o&&o.size?s.className=[...o].join(' '):null==i&&s.removeAttribute('class')
return}if(s===o){const t=e
return'string'==typeof i?void(t.style.cssText=i):i&&'object'==typeof i?void Object.assign(t.style,i):void(null==i&&t.removeAttribute('style'))}if(f&&h||u){const t=!!i
return h&&f&&(c[h]=t),void(t?e.setAttribute(s,''):e.removeAttribute(s))}let a=null
if(i&&'object'==typeof i){const t=[]
for(const e in i)i[e]&&t.push(e)
a=t.length?t.join(' '):null}else null!=i&&(a=i+'')
if(l&&h)if(null!==a)try{c[h]=a}catch(t){try{e.setAttribute(s,a)}catch{}}else e.removeAttribute(s)
else null!==a?e.getAttribute(s)!==a&&e.setAttribute(s,a):e.hasAttribute(s)&&e.removeAttribute(s)})
n.v(e,{type:'bind',expression:i,update:a})}Vt(t){if(!t)return null
if(!t.parentElement){const e=t.Ht
if(e&&e.parentElement)t=e
else{const e=t.Xt
e&&(t=e)}}const e={}
let s=t
for(;s;){const t=this.B.get(s)
if(t&&Object.assign(e,t),s===this.element)break
s=s.parentElement}return i(e).length?e:null}se(t){for(const[e,s]of this.M)for(const i of s)(t===e||e instanceof Element&&t.contains(e))&&i.update&&i.update()}Bt(t,i){const n=this,o=i.trim().match(/^(?:\(\s*([^,\s]+)\s*(?:,\s*([^\)]+))?\s*\)|([^,\s]+))\s+(in|of)\s+(.+)$/)
if(!o)return
const c=o[1]||o[3],l=o[2],u=o[5],y=a.createComment('x-for')
let p
t.parentNode?.insertBefore(y,t),t[h]===f?(p=a.createElement('div'),p.style[r]='contents',p.appendChild(t.content.cloneNode(!0)),t.parentNode?.removeChild(t)):(p=t,t.parentNode?.removeChild(t))
const d=y.parentElement||n.element,w=n.Tt(u.trim(),d),m=[],b=(t,e)=>{const s={[c]:t}
return l&&(s[l]=e),s},v={type:'for',expression:i},x=n.Ct(()=>{const t=n.Y(()=>{const t=w()
if(s(t))return{list:t,keys:null}
if('undefined'!=typeof Map&&t instanceof Map)return{list:e(t.values()),keys:e(t.keys())}
if('undefined'!=typeof Set&&t instanceof Set)return{list:e(t.values()),keys:null}
if(t&&'function'==typeof t[Symbol.iterator])return{list:e(t),keys:null}
if(t&&'object'==typeof t){const e=Object.keys(t)
return{list:e.map(e=>t[e]),keys:e}}return{list:[],keys:null}},'x-for eval error',{list:[],keys:null}),i=t.list,o=t.keys
if(m.length>i.length)for(;m.length>i.length;){const t=m.pop()
t.parentNode&&t.parentNode.removeChild(t)}const r=Math.min(m.length,i.length)
for(let t=0;r>t;t++){const e=m[t],s=o?o[t]:t
n.B.set(e,b(i[t],s)),n.se(e)}if(i.length>m.length){const t=a.createDocumentFragment(),e=m.length
for(let s=e;s<i.length;s++){const e=p.cloneNode(!0)
e.removeAttribute('x-for')
const r=o?o[s]:s
n.B.set(e,b(i[s],r))
try{n.wt(e)}catch{}t.appendChild(e),m.push(e)}const s=m[e-1]||y
s.parentNode&&s.parentNode.insertBefore(t,s.nextSibling)}},v)
v.update=x,n.v(y,v)}yt(){const t=this
for(const e of t.M.values())for(const s of e)if((!u||!s.Zt)&&s.update)try{s.update()}catch(t){}}}return d.ne={itemscope:1,formnovalidate:1,novalidate:1,default:1},new class{constructor(){this.oe=new Map,this.re=new WeakMap,this.ce=[],this.he={},this.fe=new Map,this.le=new Map,this.ae=new WeakMap,this.ue=!1,this.directive=(t,e)=>{if(t.startsWith(y+'-'))throw Error(`Custom directive names should not start with "${y}-". Use: XTool.directive("my-directive",...)`)
return this.fe.set(t,e),this},this.registerComponent=t=>{if(!t||!t.name)throw Error('registerComponent requires a name')
const e=t.name.toLowerCase()
if(this.le.has(e))throw Error(`Component name "${e}" already registered`)
return this.le.set(e,t),this},this.de=t=>this.le.get(t.toLowerCase()),this.Lt=t=>this.fe.get(t),this.te=()=>this.he,this.init=(t={})=>{this.he={container:'body',debug:!1,staticDirectives:!0,...t},'boolean'==typeof this.he.staticDirectives&&(u=this.he.staticDirectives)
const e=this.he.prefix
if(y=e&&'string'==typeof e&&e[l]>0?e:'x',a&&'loading'===a.readyState)a.addEventListener('DOMContentLoaded',()=>{this.ye(),this.pe()
const t=a?.querySelector(this.he.container)
t&&(this.me(t),this.he.delegate&&this.ve(t))})
else if(!a||'complete'===a.readyState||'interactive'===a.readyState){this.ye(),this.pe()
const t=a?.querySelector(this.he.container)
t&&(this.me(t),this.he.delegate&&this.ve(t))}return this},this.createComponent=t=>{const e=new d(this.we(),t,this)
return this.oe.set(e.id,e),e.callBeforeMount(),e},this.pe=()=>{const t=a?.querySelector(this.he.container)
if(!t)return
const s=t.querySelectorAll(`[${p('data')}]`)
for(const t of s)this.bt(t)||this.be(t)
const i=t.querySelectorAll('component[source]')
for(const t of i)this.bt(t)||this.xe(t)
if(this.ge(),0===s[l]&&!this.bt(t)){const s=e(this.oe.values()),i=s[s[l]-1]
i&&!i.isBound&&i.bindToElement(t)}},this.ge=()=>{if(this.ce[l]){for(const t of this.ce){let e,s=t.el.parentElement
for(;s&&!e;){const t=this.bt(s)
t?e=t:s=s.parentElement}e&&t.comp.attachToParent(e)}for(const t of this.ce)t.comp.completeBinding()
this.ce=[]}},this.be=(t,e)=>{const s=t.getAttribute(p('data'))
let i={}
if(s){t.removeAttribute(p('data'))
try{if(e){let t={}
try{t=e.tt?.()||{}}catch{t={}}i=Function('parent',`with(parent){return (${s})}`)(t)}else i=this.Me(s)
i=i.methods?{methods:i.methods,data:{...i}}:{data:{...i}},e&&(i.data.$parent=e)}catch(t){}}const n=this.createComponent(i)
n.element=t,n.callBeforeMount(),this.xt(n.element,n),this.ce.push({el:t,comp:n})
const o=t.getAttribute(p('init'))
if(o){t.removeAttribute(p('init'))
const e=n.H?.mounted
n.H.mounted=function(){if(e)try{e.call(this)}catch{}const t=Function('ctx','with(ctx){'+o+'} ')
queueMicrotask(()=>{if(!n.isDestroyed&&n.element&&n.element.isConnected)try{const e=n.tt?.()||n.getContext?.()||{},s=t(e)
if('function'==typeof s)try{s()}catch{}}catch{}})}}},this.we=()=>'component_'+Date.now()+'_'+Math.random().toString(36).substring(2,9),this.Me=t=>{try{return Function('return '+t.trim())()}catch{return{}}},this.Et=t=>{this.oe.delete(t)},this.Oe=(...t)=>{},this.xt=(t,e)=>{this.re.set(t,e)},this.$t=t=>{try{this.re.delete(t)}catch{}}}ye(){if(!a)return
if('x'===y)return
const t='x-tool-initial-css-'+y
if(a.head&&!a.getElementById(t)){const e=a.createElement(o)
e.id=t,e.textContent=`[${y}-show],[${y}-if],[${y}-else],[${y}-else-if],[${y}\\:show],[${y}\\:if],[${y}\\:else],[${y}\\:else-if]{display:none;}`,a.head.appendChild(e)}}me(t){this.$e||'undefined'==typeof MutationObserver||(this.$e=new MutationObserver(t=>{for(const e of t)if('childList'===e.type){for(let t=0;t<e.addedNodes.length;t++){const s=e.addedNodes[t]
if(1!==s.nodeType)continue
const i=s
'COMPONENT'===i[h]&&i.getAttribute('source')&&!this.bt(i)&&this.xe(i)}for(let t=0;t<e.removedNodes.length;t++){const s=e.removedNodes[t]
if(1!==s.nodeType)continue
const i=s
queueMicrotask(()=>{if(i.isConnected)return
const t=[i]
for(;t.length;){const e=t.pop(),s=this.bt(e)
if(s&&!s.isDestroyed)try{s.destroy()}catch{}let i=e.firstElementChild
for(;i;)t.push(i),i=i.nextElementSibling}})}}else if('attributes'===e.type){const t=e.target
t&&'COMPONENT'===t[h]&&'source'===e.attributeName&&this.ke(t)}this.ge()}),this.$e.observe(t,{childList:!0,subtree:!0,attributes:!0,attributeFilter:['source']}))}ke(t){const e=(t.getAttribute('source')||'').trim(),s=this.bt(t)
if(e){if(s&&!s.isDestroyed)try{s.destroy()}catch{}t.innerHTML='',this.xe(t)}else{if(s&&!s.isDestroyed)try{s.destroy()}catch{}t.innerHTML=''}}xe(t){const e=t.getAttribute('source')
if(!e)return
const s=this.de(e)
if(!s)return
let i,n=t.parentElement
for(;n&&!i;){const t=this.bt(n)
t?i=t:n=n.parentElement}let o=null,r=null,c=null
o||(o={})
const h=t.getAttribute(p('prop'))
if(h){if(c=h,i)try{r=Function('ctx','with(ctx){return ('+h+')}')(i.getContext(!0))}catch{r=null}else try{r=Function('return ('+h+')')()}catch{r=null}if(r&&'object'==typeof r)for(const t in r)t in o||(o[t]=r[t]+'')
t.removeAttribute(p('prop'))}let f,l={}
if(s.makeData)try{l=s.makeData(o)||{}}catch{l={}}if(s.data)for(const t in s.data)l[t]=s.data[t]
for(const t in o)t in l||(l[t]=o[t])
if(l.$props=o,'function'==typeof s.init)try{const t=s.init(o)
f=t&&'object'==typeof t?t:0}catch{f=0}const u={data:l,methods:{...s.methods||{},...f?.methods||{}},computed:{...s.computed||{},...f?.computed||{}},propEffects:{...s.propEffects||{},...f?.propEffects||{}},mounted:f?.mounted||s.mounted,unmounted:f?.unmounted||s.unmounted,beforeMount:f?.beforeMount||s.beforeMount,beforeUnmount:f?.beforeUnmount||s.beforeUnmount,updated:f?.updated||s.updated,destroyed:f?.destroyed||s.destroyed,beforeDestroy:f?.beforeDestroy||s.beforeDestroy},y=this.createComponent(u)
y.element=t
const d=[]
for(;t.firstChild;){const e=t.firstChild
d.push(e),t.removeChild(e)}if(s.template){const e=e=>{t.innerHTML=e
const s=t.querySelectorAll('slot')
if(s.length)for(const t of s){const e=t.getAttribute('name')
let s=[]
if(s=e?d.filter(t=>1===t.nodeType&&t.getAttribute('slot')===e):d.filter(t=>1!==t.nodeType||!t.hasAttribute('slot')),s.length){const e=a.createDocumentFragment()
for(const t of s)e.appendChild(t)
t.parentNode?.replaceChild(e,t)}}},i=s.template
if('string'==typeof i)e(i)
else if('function'==typeof i)try{const s=i()
s&&'function'==typeof s.then?(t.innerHTML='',s.then(t=>{e(t||'')
try{y.vt()}catch{}})):e((s||'')+'')}catch{t.innerHTML=''}else i&&'function'==typeof i.then&&(t.innerHTML='',i.then(t=>{e(t||'')
try{y.vt()}catch{}}))}else for(const e of d)t.appendChild(e)
this.xt(t,y)
try{const e=t.querySelectorAll(`[${p('data')}]`)
for(const t of e)this.bt(t)||this.be(t,y)}catch{}if(this.ce.push({el:t,comp:y}),c&&i)try{y.Dt(c,i)}catch{}this.ge()}bt(t){return this.re.get(t)}observe(t){}ve(t){if(this.ue)return
const e=t,s=t=>{let s=t.target
for(;s&&s!==e.parentElement;){const e=this.ae.get(s)
if(e){const i=e.get(t.type)
if(i&&i.length)for(const e of[...i])try{if(!this.re.get(s))continue
if((!e.filter||e.filter(t))&&(e.run(t),e.once)){const t=i.indexOf(e)
t>-1&&i.splice(t,1)}}catch{}}s=s.parentElement}},i=['click','input','change','keydown','keyup']
for(const t of i)e.addEventListener(t,s,!0)
this.ue=!0}ee(t,e,s){let i=this.ae.get(t)
i||(i=new Map,this.ae.set(t,i))
let n=i.get(e)
return n||(n=[],i.set(e,n)),n.push(s),()=>{try{const i=this.ae.get(t),n=i?.get(e)
if(!n)return
const o=n.indexOf(s)
o>-1&&n.splice(o,1)}catch{}}}}}()
'undefined'!=typeof window&&(window.XTool=e)
